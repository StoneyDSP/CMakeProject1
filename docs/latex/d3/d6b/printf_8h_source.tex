\hypertarget{printf_8h_source}{}\doxysection{printf.\+h}
\label{printf_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/printf.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/printf.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ legacy printf implementation}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ 2016, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_PRINTF\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_PRINTF\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <algorithm>}  \textcolor{comment}{// std::max}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <limits>}     \textcolor{comment}{// std::numeric\_limits}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{17 FMT\_MODULE\_EXPORT\_BEGIN}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structprintf__formatter}{printf\_formatter}} \{ \mbox{\hyperlink{structprintf__formatter}{printf\_formatter}}() = \textcolor{keyword}{delete}; \};}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{22 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__printf__parse__context}{basic\_printf\_parse\_context}} : \textcolor{keyword}{public} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}}<Char> \{}
\DoxyCodeLine{23   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}}<Char>\mbox{\hyperlink{classbasic__format__parse__context}{::basic\_format\_parse\_context}};}
\DoxyCodeLine{24 \};}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context}} \{}
\DoxyCodeLine{27  \textcolor{keyword}{private}:}
\DoxyCodeLine{28   OutputIt out\_;}
\DoxyCodeLine{29   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_printf\_context>}} args\_;}
\DoxyCodeLine{30 }
\DoxyCodeLine{31  \textcolor{keyword}{public}:}
\DoxyCodeLine{32   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{33   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__arg}{format\_arg}} = \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<basic\_printf\_context>}};}
\DoxyCodeLine{34   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__printf__parse__context}{parse\_context\_type}} = \mbox{\hyperlink{classbasic__printf__parse__context}{basic\_printf\_parse\_context<Char>}};}
\DoxyCodeLine{35   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }\mbox{\hyperlink{structprintf__formatter}{formatter\_type}} = \mbox{\hyperlink{structprintf__formatter}{printf\_formatter<T>}};}
\DoxyCodeLine{36 }
\DoxyCodeLine{43   \mbox{\hyperlink{classbasic__printf__context_adfdcf4066bb737766d1d1905f7b3e320}{basic\_printf\_context}}(OutputIt out,}
\DoxyCodeLine{44                        \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_printf\_context>}} args)}
\DoxyCodeLine{45       : out\_(out), args\_(args) \{\}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   OutputIt out() \{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{48   \textcolor{keywordtype}{void} advance\_to(OutputIt it) \{ out\_ = it; \}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50   detail::locale\_ref locale() \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52   format\_arg arg(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id})\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} args\_.\mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{55     detail::error\_handler().on\_error(message);}
\DoxyCodeLine{56   \}}
\DoxyCodeLine{57 \};}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{60 }
\DoxyCodeLine{61 \textcolor{comment}{// Checks if a value fits in int -\/ used to avoid warnings about comparing}}
\DoxyCodeLine{62 \textcolor{comment}{// signed and unsigned integers.}}
\DoxyCodeLine{63 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IsSigned> \textcolor{keyword}{struct }\mbox{\hyperlink{structint__checker}{int\_checker}} \{}
\DoxyCodeLine{64   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{65     \textcolor{keywordtype}{unsigned} max = max\_value<int>();}
\DoxyCodeLine{66     \textcolor{keywordflow}{return} \mbox{\hyperlink{classvalue}{value}} <= max;}
\DoxyCodeLine{67   \}}
\DoxyCodeLine{68   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(\textcolor{keywordtype}{bool}) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{69 \};}
\DoxyCodeLine{70 }
\DoxyCodeLine{71 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structint__checker}{int\_checker}}<true> \{}
\DoxyCodeLine{72   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{73     \textcolor{keywordflow}{return} \mbox{\hyperlink{classvalue}{value}} >= (std::numeric\_limits<int>::min)() \&\&}
\DoxyCodeLine{74            \mbox{\hyperlink{classvalue}{value <= max\_value<int>}}();}
\DoxyCodeLine{75   \}}
\DoxyCodeLine{76   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{77 \};}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 \textcolor{keyword}{class }\mbox{\hyperlink{classprintf__precision__handler}{printf\_precision\_handler}} \{}
\DoxyCodeLine{80  \textcolor{keyword}{public}:}
\DoxyCodeLine{81   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{82   \textcolor{keywordtype}{int} operator()(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{83     \textcolor{keywordflow}{if} (!\mbox{\hyperlink{structint__checker}{int\_checker}}<std::numeric\_limits<T>::is\_signed>::fits\_in\_int(\mbox{\hyperlink{classvalue}{value}}))}
\DoxyCodeLine{84       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{85     \textcolor{keywordflow}{return} (std::max)(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}}), 0);}
\DoxyCodeLine{86   \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{89   \textcolor{keywordtype}{int} operator()(T) \{}
\DoxyCodeLine{90     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}precision is not integer"{}}));}
\DoxyCodeLine{91     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{92   \}}
\DoxyCodeLine{93 \};}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{comment}{// An argument visitor that returns true iff arg is a zero integer.}}
\DoxyCodeLine{96 \textcolor{keyword}{class }\mbox{\hyperlink{classis__zero__int}{is\_zero\_int}} \{}
\DoxyCodeLine{97  \textcolor{keyword}{public}:}
\DoxyCodeLine{98   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{99   \textcolor{keywordtype}{bool} operator()(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{100     \textcolor{keywordflow}{return} \mbox{\hyperlink{classvalue}{value}} == 0;}
\DoxyCodeLine{101   \}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{104   \textcolor{keywordtype}{bool} operator()(T) \{}
\DoxyCodeLine{105     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{106   \}}
\DoxyCodeLine{107 \};}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structmake__unsigned__or__bool}{make\_unsigned\_or\_bool}} : std::make\_unsigned<T> \{\};}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmake__unsigned__or__bool}{make\_unsigned\_or\_bool}}<bool> \{ \textcolor{keyword}{using }type = bool; \};}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classarg__converter}{arg\_converter}} \{}
\DoxyCodeLine{114  \textcolor{keyword}{private}:}
\DoxyCodeLine{115   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{116 }
\DoxyCodeLine{117   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}\& arg\_;}
\DoxyCodeLine{118   char\_type type\_;}
\DoxyCodeLine{119 }
\DoxyCodeLine{120  \textcolor{keyword}{public}:}
\DoxyCodeLine{121   \mbox{\hyperlink{classarg__converter}{arg\_converter}}(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}\& arg, char\_type type)}
\DoxyCodeLine{122       : arg\_(arg), type\_(type) \{\}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124   \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{bool} \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{125     \textcolor{keywordflow}{if} (type\_ != \textcolor{charliteral}{'s'}) operator()<\textcolor{keywordtype}{bool}>(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{126   \}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<U>::value)>}
\DoxyCodeLine{129   \textcolor{keywordtype}{void} operator()(U \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{130     \textcolor{keywordtype}{bool} is\_signed = type\_ == \textcolor{charliteral}{'d'} || type\_ == \textcolor{charliteral}{'i'};}
\DoxyCodeLine{131     \textcolor{keyword}{using }target\_type = conditional\_t<std::is\_same<T, void>::value, U, T>;}
\DoxyCodeLine{132     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(target\_type) <= \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}))) \{}
\DoxyCodeLine{133       \textcolor{comment}{// Extra casts are used to silence warnings.}}
\DoxyCodeLine{134       \textcolor{keywordflow}{if} (is\_signed) \{}
\DoxyCodeLine{135         arg\_ = detail::make\_arg<Context>(}
\DoxyCodeLine{136             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}target\_type\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}})));}
\DoxyCodeLine{137       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{138         \textcolor{keyword}{using }unsigned\_type = \textcolor{keyword}{typename} \mbox{\hyperlink{structmake__unsigned__or__bool}{make\_unsigned\_or\_bool<target\_type>::type}};}
\DoxyCodeLine{139         arg\_ = detail::make\_arg<Context>(}
\DoxyCodeLine{140             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}unsigned\_type\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}})));}
\DoxyCodeLine{141       \}}
\DoxyCodeLine{142     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{143       \textcolor{keywordflow}{if} (is\_signed) \{}
\DoxyCodeLine{144         \textcolor{comment}{// glibc's printf doesn't sign extend arguments of smaller types:}}
\DoxyCodeLine{145         \textcolor{comment}{//   std::printf("{}\%lld"{}, -\/42);  // prints "{}4294967254"{}}}
\DoxyCodeLine{146         \textcolor{comment}{// but we don't have to do the same because it's a UB.}}
\DoxyCodeLine{147         arg\_ = detail::make\_arg<Context>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}}));}
\DoxyCodeLine{148       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{149         arg\_ = detail::make\_arg<Context>(}
\DoxyCodeLine{150             \textcolor{keyword}{static\_cast<}typename \mbox{\hyperlink{structmake__unsigned__or__bool}{make\_unsigned\_or\_bool<U>::type}}\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}}));}
\DoxyCodeLine{151       \}}
\DoxyCodeLine{152     \}}
\DoxyCodeLine{153   \}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<U>::value)>}
\DoxyCodeLine{156   \textcolor{keywordtype}{void} operator()(U) \{\}  \textcolor{comment}{// No conversion needed for non-\/integral types.}}
\DoxyCodeLine{157 \};}
\DoxyCodeLine{158 }
\DoxyCodeLine{159 \textcolor{comment}{// Converts an integer argument to T for printf, if T is an integral type.}}
\DoxyCodeLine{160 \textcolor{comment}{// If T is void, the argument is converted to corresponding signed or unsigned}}
\DoxyCodeLine{161 \textcolor{comment}{// type depending on the type specifier: 'd' and 'i' -\/ signed, other -\/}}
\DoxyCodeLine{162 \textcolor{comment}{// unsigned).}}
\DoxyCodeLine{163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{164 \textcolor{keywordtype}{void} convert\_arg(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}\& arg, Char type) \{}
\DoxyCodeLine{165   visit\_format\_arg(\mbox{\hyperlink{classarg__converter}{arg\_converter<T, Context>}}(arg, type), arg);}
\DoxyCodeLine{166 \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{comment}{// Converts an integer argument to char for printf.}}
\DoxyCodeLine{169 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classchar__converter}{char\_converter}} \{}
\DoxyCodeLine{170  \textcolor{keyword}{private}:}
\DoxyCodeLine{171   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}\& arg\_;}
\DoxyCodeLine{172 }
\DoxyCodeLine{173  \textcolor{keyword}{public}:}
\DoxyCodeLine{174   \textcolor{keyword}{explicit} \mbox{\hyperlink{classchar__converter}{char\_converter}}(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}\& arg) : arg\_(arg) \{\}}
\DoxyCodeLine{175 }
\DoxyCodeLine{176   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{177   \textcolor{keywordtype}{void} operator()(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{178     arg\_ = detail::make\_arg<Context>(}
\DoxyCodeLine{179         \textcolor{keyword}{static\_cast<}typename Context::char\_type\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}}));}
\DoxyCodeLine{180   \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{183   \textcolor{keywordtype}{void} operator()(T) \{\}  \textcolor{comment}{// No conversion needed for non-\/integral types.}}
\DoxyCodeLine{184 \};}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{comment}{// An argument visitor that return a pointer to a C string if argument is a}}
\DoxyCodeLine{187 \textcolor{comment}{// string or null otherwise.}}
\DoxyCodeLine{188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structget__cstring}{get\_cstring}} \{}
\DoxyCodeLine{189   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{const} Char* operator()(T) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{190   \textcolor{keyword}{const} Char* operator()(\textcolor{keyword}{const} Char* s) \{ \textcolor{keywordflow}{return} s; \}}
\DoxyCodeLine{191 \};}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 \textcolor{comment}{// Checks if an argument is a valid printf width specifier and sets}}
\DoxyCodeLine{194 \textcolor{comment}{// left alignment if it is negative.}}
\DoxyCodeLine{195 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classprintf__width__handler}{printf\_width\_handler}} \{}
\DoxyCodeLine{196  \textcolor{keyword}{private}:}
\DoxyCodeLine{197   \textcolor{keyword}{using }\mbox{\hyperlink{structbasic__format__specs}{format\_specs}} = \mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}};}
\DoxyCodeLine{198 }
\DoxyCodeLine{199   \mbox{\hyperlink{structbasic__format__specs}{format\_specs}}\& specs\_;}
\DoxyCodeLine{200 }
\DoxyCodeLine{201  \textcolor{keyword}{public}:}
\DoxyCodeLine{202   \textcolor{keyword}{explicit} \mbox{\hyperlink{classprintf__width__handler}{printf\_width\_handler}}(\mbox{\hyperlink{structbasic__format__specs}{format\_specs}}\& specs) : specs\_(specs) \{\}}
\DoxyCodeLine{203 }
\DoxyCodeLine{204   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{205   \textcolor{keywordtype}{unsigned} operator()(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{206     \textcolor{keyword}{auto} width = \textcolor{keyword}{static\_cast<}uint32\_or\_64\_or\_128\_t<T>\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{207     \textcolor{keywordflow}{if} (detail::is\_negative(\mbox{\hyperlink{classvalue}{value}})) \{}
\DoxyCodeLine{208       specs\_.align = align::left;}
\DoxyCodeLine{209       width = 0 -\/ width;}
\DoxyCodeLine{210     \}}
\DoxyCodeLine{211     \textcolor{keywordtype}{unsigned} int\_max = max\_value<int>();}
\DoxyCodeLine{212     \textcolor{keywordflow}{if} (width > int\_max) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{213     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(width);}
\DoxyCodeLine{214   \}}
\DoxyCodeLine{215 }
\DoxyCodeLine{216   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{217   \textcolor{keywordtype}{unsigned} operator()(T) \{}
\DoxyCodeLine{218     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}width is not integer"{}}));}
\DoxyCodeLine{219     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{220   \}}
\DoxyCodeLine{221 \};}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{comment}{// The ``printf`` argument formatter.}}
\DoxyCodeLine{224 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{225 \textcolor{keyword}{class }\mbox{\hyperlink{classprintf__arg__formatter}{printf\_arg\_formatter}} : \textcolor{keyword}{public} \mbox{\hyperlink{structarg__formatter}{arg\_formatter}}<Char> \{}
\DoxyCodeLine{226  \textcolor{keyword}{private}:}
\DoxyCodeLine{227   \textcolor{keyword}{using }\mbox{\hyperlink{structarg__formatter}{base}} = \mbox{\hyperlink{structarg__formatter}{arg\_formatter<Char>}};}
\DoxyCodeLine{228   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__printf__context}{context\_type}} = \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<OutputIt, Char>}};}
\DoxyCodeLine{229   \textcolor{keyword}{using }\mbox{\hyperlink{structbasic__format__specs}{format\_specs}} = \mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}};}
\DoxyCodeLine{230 }
\DoxyCodeLine{231   \mbox{\hyperlink{classbasic__printf__context}{context\_type}}\& context\_;}
\DoxyCodeLine{232 }
\DoxyCodeLine{233   OutputIt write\_null\_pointer(\textcolor{keywordtype}{bool} \mbox{\hyperlink{structis__string}{is\_string}} = \textcolor{keyword}{false}) \{}
\DoxyCodeLine{234     \textcolor{keyword}{auto} s = this-\/>specs;}
\DoxyCodeLine{235     s.type = presentation\_type::none;}
\DoxyCodeLine{236     \textcolor{keywordflow}{return} write\_bytes(this-\/>out, \mbox{\hyperlink{structis__string}{is\_string}} ? \textcolor{stringliteral}{"{}(null)"{}} : \textcolor{stringliteral}{"{}(nil)"{}}, s);}
\DoxyCodeLine{237   \}}
\DoxyCodeLine{238 }
\DoxyCodeLine{239  \textcolor{keyword}{public}:}
\DoxyCodeLine{240   \mbox{\hyperlink{classprintf__arg__formatter}{printf\_arg\_formatter}}(OutputIt iter, \mbox{\hyperlink{structbasic__format__specs}{format\_specs}}\& s, \mbox{\hyperlink{classbasic__printf__context}{context\_type}}\& ctx)}
\DoxyCodeLine{241       : \mbox{\hyperlink{structarg__formatter}{base}}\{iter, s, \mbox{\hyperlink{classlocale__ref}{locale\_ref}}()\}, context\_(ctx) \{\}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243   OutputIt operator()(\mbox{\hyperlink{structmonostate}{monostate}} \mbox{\hyperlink{classvalue}{value}}) \{ \textcolor{keywordflow}{return} base::operator()(\mbox{\hyperlink{classvalue}{value}}); \}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(detail::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{246   OutputIt operator()(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{247     \textcolor{comment}{// MSVC2013 fails to compile separate overloads for bool and Char so use}}
\DoxyCodeLine{248     \textcolor{comment}{// std::is\_same instead.}}
\DoxyCodeLine{249     \textcolor{keywordflow}{if} (std::is\_same<T, Char>::value) \{}
\DoxyCodeLine{250       \mbox{\hyperlink{structbasic__format__specs}{format\_specs}} fmt\_specs = this-\/>specs;}
\DoxyCodeLine{251       \textcolor{keywordflow}{if} (fmt\_specs.type != presentation\_type::none \&\&}
\DoxyCodeLine{252           fmt\_specs.type != presentation\_type::chr) \{}
\DoxyCodeLine{253         \textcolor{keywordflow}{return} (*\textcolor{keyword}{this})(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}}));}
\DoxyCodeLine{254       \}}
\DoxyCodeLine{255       fmt\_specs.sign = sign::none;}
\DoxyCodeLine{256       fmt\_specs.alt = \textcolor{keyword}{false};}
\DoxyCodeLine{257       fmt\_specs.fill[0] = \textcolor{charliteral}{' '};  \textcolor{comment}{// Ignore '0' flag for char types.}}
\DoxyCodeLine{258       \textcolor{comment}{// align::numeric needs to be overwritten here since the '0' flag is}}
\DoxyCodeLine{259       \textcolor{comment}{// ignored for non-\/numeric types}}
\DoxyCodeLine{260       \textcolor{keywordflow}{if} (fmt\_specs.align == align::none || fmt\_specs.align == align::numeric)}
\DoxyCodeLine{261         fmt\_specs.align = align::right;}
\DoxyCodeLine{262       \textcolor{keywordflow}{return} write<Char>(this-\/>out, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}}), fmt\_specs);}
\DoxyCodeLine{263     \}}
\DoxyCodeLine{264     \textcolor{keywordflow}{return} base::operator()(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{265   \}}
\DoxyCodeLine{266 }
\DoxyCodeLine{267   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{float}ing\_po\textcolor{keywordtype}{int}<T>::value)>}
\DoxyCodeLine{268   OutputIt operator()(T \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{269     \textcolor{keywordflow}{return} base::operator()(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{270   \}}
\DoxyCodeLine{271 }
\DoxyCodeLine{273   OutputIt \mbox{\hyperlink{classprintf__arg__formatter_a0ee64afba0825732d80e28c63992c10f}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{274     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classvalue}{value}}) \textcolor{keywordflow}{return} base::operator()(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{275     \textcolor{keywordflow}{return} write\_null\_pointer(this-\/>specs.type != presentation\_type::pointer);}
\DoxyCodeLine{276   \}}
\DoxyCodeLine{277 }
\DoxyCodeLine{279   OutputIt \mbox{\hyperlink{classprintf__arg__formatter_a48d4afbaf5a4d0e6e0d0e26fe7a902c0}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{280     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classvalue}{value}}) \textcolor{keywordflow}{return} base::operator()(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{281     \textcolor{keywordflow}{return} write\_null\_pointer(this-\/>specs.type != presentation\_type::pointer);}
\DoxyCodeLine{282   \}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284   OutputIt operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{285     \textcolor{keywordflow}{return} base::operator()(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{286   \}}
\DoxyCodeLine{287 }
\DoxyCodeLine{289   OutputIt \mbox{\hyperlink{classprintf__arg__formatter_a06c4c8137ac92b3a196c9ca4a6361a0b}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{290     \textcolor{keywordflow}{return} \mbox{\hyperlink{classvalue}{value}} ? base::operator()(\mbox{\hyperlink{classvalue}{value}}) : write\_null\_pointer();}
\DoxyCodeLine{291   \}}
\DoxyCodeLine{292 }
\DoxyCodeLine{294   OutputIt \mbox{\hyperlink{classprintf__arg__formatter_af500a78738619292860f14983044a7d4}{operator()}}(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<context\_type>::handle}} handle) \{}
\DoxyCodeLine{295     \textcolor{keyword}{auto} parse\_ctx =}
\DoxyCodeLine{296         \mbox{\hyperlink{classbasic__printf__parse__context}{basic\_printf\_parse\_context<Char>}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}());}
\DoxyCodeLine{297     handle.format(parse\_ctx, context\_);}
\DoxyCodeLine{298     \textcolor{keywordflow}{return} this-\/>out;}
\DoxyCodeLine{299   \}}
\DoxyCodeLine{300 \};}
\DoxyCodeLine{301 }
\DoxyCodeLine{302 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{303 \textcolor{keywordtype}{void} parse\_flags(\mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}}\& specs, \textcolor{keyword}{const} Char*\& it,}
\DoxyCodeLine{304                  \textcolor{keyword}{const} Char* end) \{}
\DoxyCodeLine{305   \textcolor{keywordflow}{for} (; it != end; ++it) \{}
\DoxyCodeLine{306     \textcolor{keywordflow}{switch} (*it) \{}
\DoxyCodeLine{307     \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{308       specs.align = align::left;}
\DoxyCodeLine{309       \textcolor{keywordflow}{break};}
\DoxyCodeLine{310     \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{311       specs.sign = sign::plus;}
\DoxyCodeLine{312       \textcolor{keywordflow}{break};}
\DoxyCodeLine{313     \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{314       specs.fill[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{315       \textcolor{keywordflow}{break};}
\DoxyCodeLine{316     \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{317       \textcolor{keywordflow}{if} (specs.sign != sign::plus) \{}
\DoxyCodeLine{318         specs.sign = sign::space;}
\DoxyCodeLine{319       \}}
\DoxyCodeLine{320       \textcolor{keywordflow}{break};}
\DoxyCodeLine{321     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\#'}:}
\DoxyCodeLine{322       specs.alt = \textcolor{keyword}{true};}
\DoxyCodeLine{323       \textcolor{keywordflow}{break};}
\DoxyCodeLine{324     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{325       \textcolor{keywordflow}{return};}
\DoxyCodeLine{326     \}}
\DoxyCodeLine{327   \}}
\DoxyCodeLine{328 \}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} GetArg>}
\DoxyCodeLine{331 \textcolor{keywordtype}{int} parse\_header(\textcolor{keyword}{const} Char*\& it, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{332                  \mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}}\& specs, GetArg get\_arg) \{}
\DoxyCodeLine{333   \textcolor{keywordtype}{int} arg\_index = -\/1;}
\DoxyCodeLine{334   Char c = *it;}
\DoxyCodeLine{335   \textcolor{keywordflow}{if} (c >= \textcolor{charliteral}{'0'} \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{336     \textcolor{comment}{// Parse an argument index (if followed by '\$') or a width possibly}}
\DoxyCodeLine{337     \textcolor{comment}{// preceded with '0' flag(s).}}
\DoxyCodeLine{338     \textcolor{keywordtype}{int} \mbox{\hyperlink{classvalue}{value}} = parse\_nonnegative\_int(it, end, -\/1);}
\DoxyCodeLine{339     \textcolor{keywordflow}{if} (it != end \&\& *it == \textcolor{charliteral}{'\$'}) \{  \textcolor{comment}{// value is an argument index}}
\DoxyCodeLine{340       ++it;}
\DoxyCodeLine{341       arg\_index = \mbox{\hyperlink{classvalue}{value}} != -\/1 ? \mbox{\hyperlink{classvalue}{value}} : max\_value<int>();}
\DoxyCodeLine{342     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{343       \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'0'}) specs.fill[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{344       \textcolor{keywordflow}{if} (\mbox{\hyperlink{classvalue}{value}} != 0) \{}
\DoxyCodeLine{345         \textcolor{comment}{// Nonzero value means that we parsed width and don't need to}}
\DoxyCodeLine{346         \textcolor{comment}{// parse it or flags again, so return now.}}
\DoxyCodeLine{347         \textcolor{keywordflow}{if} (\mbox{\hyperlink{classvalue}{value}} == -\/1) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{348         specs.width = \mbox{\hyperlink{classvalue}{value}};}
\DoxyCodeLine{349         \textcolor{keywordflow}{return} arg\_index;}
\DoxyCodeLine{350       \}}
\DoxyCodeLine{351     \}}
\DoxyCodeLine{352   \}}
\DoxyCodeLine{353   parse\_flags(specs, it, end);}
\DoxyCodeLine{354   \textcolor{comment}{// Parse width.}}
\DoxyCodeLine{355   \textcolor{keywordflow}{if} (it != end) \{}
\DoxyCodeLine{356     \textcolor{keywordflow}{if} (*it >= \textcolor{charliteral}{'0'} \&\& *it <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{357       specs.width = parse\_nonnegative\_int(it, end, -\/1);}
\DoxyCodeLine{358       \textcolor{keywordflow}{if} (specs.width == -\/1) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{359     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'*'}) \{}
\DoxyCodeLine{360       ++it;}
\DoxyCodeLine{361       specs.width = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(visit\_format\_arg(}
\DoxyCodeLine{362           detail::printf\_width\_handler<Char>(specs), get\_arg(-\/1)));}
\DoxyCodeLine{363     \}}
\DoxyCodeLine{364   \}}
\DoxyCodeLine{365   \textcolor{keywordflow}{return} arg\_index;}
\DoxyCodeLine{366 \}}
\DoxyCodeLine{367 }
\DoxyCodeLine{368 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{369 \textcolor{keywordtype}{void} vprintf(\mbox{\hyperlink{classbuffer}{buffer<Char>}}\& buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format,}
\DoxyCodeLine{370              \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} args) \{}
\DoxyCodeLine{371   \textcolor{keyword}{using }OutputIt = buffer\_appender<Char>;}
\DoxyCodeLine{372   \textcolor{keyword}{auto} out = OutputIt(buf);}
\DoxyCodeLine{373   \textcolor{keyword}{auto} context = \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<OutputIt, Char>}}(out, args);}
\DoxyCodeLine{374   \textcolor{keyword}{auto} parse\_ctx = \mbox{\hyperlink{classbasic__printf__parse__context}{basic\_printf\_parse\_context<Char>}}(format);}
\DoxyCodeLine{375 }
\DoxyCodeLine{376   \textcolor{comment}{// Returns the argument with specified index or, if arg\_index is -\/1, the next}}
\DoxyCodeLine{377   \textcolor{comment}{// argument.}}
\DoxyCodeLine{378   \textcolor{keyword}{auto} get\_arg = [\&](\textcolor{keywordtype}{int} arg\_index) \{}
\DoxyCodeLine{379     \textcolor{keywordflow}{if} (arg\_index < 0)}
\DoxyCodeLine{380       arg\_index = parse\_ctx.next\_arg\_id();}
\DoxyCodeLine{381     \textcolor{keywordflow}{else}}
\DoxyCodeLine{382       parse\_ctx.check\_arg\_id(-\/-\/arg\_index);}
\DoxyCodeLine{383     \textcolor{keywordflow}{return} detail::get\_arg(context, arg\_index);}
\DoxyCodeLine{384   \};}
\DoxyCodeLine{385 }
\DoxyCodeLine{386   \textcolor{keyword}{const} Char* start = parse\_ctx.begin();}
\DoxyCodeLine{387   \textcolor{keyword}{const} Char* end = parse\_ctx.end();}
\DoxyCodeLine{388   \textcolor{keyword}{auto} it = start;}
\DoxyCodeLine{389   \textcolor{keywordflow}{while} (it != end) \{}
\DoxyCodeLine{390     \textcolor{keywordflow}{if} (!detail::find<false, Char>(it, end, \textcolor{charliteral}{'\%'}, it)) \{}
\DoxyCodeLine{391       it = end;  \textcolor{comment}{// detail::find leaves it == nullptr if it doesn't find '\%'}}
\DoxyCodeLine{392       \textcolor{keywordflow}{break};}
\DoxyCodeLine{393     \}}
\DoxyCodeLine{394     Char c = *it++;}
\DoxyCodeLine{395     \textcolor{keywordflow}{if} (it != end \&\& *it == c) \{}
\DoxyCodeLine{396       out = detail::write(}
\DoxyCodeLine{397           out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(start, detail::to\_unsigned(it -\/ start)));}
\DoxyCodeLine{398       start = ++it;}
\DoxyCodeLine{399       \textcolor{keywordflow}{continue};}
\DoxyCodeLine{400     \}}
\DoxyCodeLine{401     out = detail::write(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(}
\DoxyCodeLine{402                                  start, detail::to\_unsigned(it -\/ 1 -\/ start)));}
\DoxyCodeLine{403 }
\DoxyCodeLine{404     \mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}} specs;}
\DoxyCodeLine{405     specs.align = align::right;}
\DoxyCodeLine{406 }
\DoxyCodeLine{407     \textcolor{comment}{// Parse argument index, flags and width.}}
\DoxyCodeLine{408     \textcolor{keywordtype}{int} arg\_index = parse\_header(it, end, specs, get\_arg);}
\DoxyCodeLine{409     \textcolor{keywordflow}{if} (arg\_index == 0) parse\_ctx.on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{410 }
\DoxyCodeLine{411     \textcolor{comment}{// Parse precision.}}
\DoxyCodeLine{412     \textcolor{keywordflow}{if} (it != end \&\& *it == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{413       ++it;}
\DoxyCodeLine{414       c = it != end ? *it : 0;}
\DoxyCodeLine{415       \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{416         specs.precision = parse\_nonnegative\_int(it, end, 0);}
\DoxyCodeLine{417       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'*'}) \{}
\DoxyCodeLine{418         ++it;}
\DoxyCodeLine{419         specs.precision = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(}
\DoxyCodeLine{420             visit\_format\_arg(detail::printf\_precision\_handler(), get\_arg(-\/1)));}
\DoxyCodeLine{421       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{422         specs.precision = 0;}
\DoxyCodeLine{423       \}}
\DoxyCodeLine{424     \}}
\DoxyCodeLine{425 }
\DoxyCodeLine{426     \textcolor{keyword}{auto} arg = get\_arg(arg\_index);}
\DoxyCodeLine{427     \textcolor{comment}{// For d, i, o, u, x, and X conversion specifiers, if a precision is}}
\DoxyCodeLine{428     \textcolor{comment}{// specified, the '0' flag is ignored}}
\DoxyCodeLine{429     \textcolor{keywordflow}{if} (specs.precision >= 0 \&\& arg.is\_integral())}
\DoxyCodeLine{430       specs.fill[0] =}
\DoxyCodeLine{431           \textcolor{charliteral}{' '};  \textcolor{comment}{// Ignore '0' flag for non-\/numeric types or if '-\/' present.}}
\DoxyCodeLine{432     \textcolor{keywordflow}{if} (specs.precision >= 0 \&\& arg.type() == detail::type::cstring\_type) \{}
\DoxyCodeLine{433       \textcolor{keyword}{auto} str = visit\_format\_arg(detail::get\_cstring<Char>(), arg);}
\DoxyCodeLine{434       \textcolor{keyword}{auto} str\_end = str + specs.precision;}
\DoxyCodeLine{435       \textcolor{keyword}{auto} nul = std::find(str, str\_end, Char());}
\DoxyCodeLine{436       arg = detail::make\_arg<basic\_printf\_context<OutputIt, Char>>(}
\DoxyCodeLine{437           \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(}
\DoxyCodeLine{438               str, detail::to\_unsigned(nul != str\_end ? nul -\/ str}
\DoxyCodeLine{439                                                       : specs.precision)));}
\DoxyCodeLine{440     \}}
\DoxyCodeLine{441     \textcolor{keywordflow}{if} (specs.alt \&\& visit\_format\_arg(detail::is\_zero\_int(), arg))}
\DoxyCodeLine{442       specs.alt = \textcolor{keyword}{false};}
\DoxyCodeLine{443     if (specs.fill[0] == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{444       \textcolor{keywordflow}{if} (arg.is\_arithmetic() \&\& specs.align != align::left)}
\DoxyCodeLine{445         specs.align = align::numeric;}
\DoxyCodeLine{446       \textcolor{keywordflow}{else}}
\DoxyCodeLine{447         specs.fill[0] = \textcolor{charliteral}{' '};  \textcolor{comment}{// Ignore '0' flag for non-\/numeric types or if '-\/'}}
\DoxyCodeLine{448                               \textcolor{comment}{// flag is also present.}}
\DoxyCodeLine{449     \}}
\DoxyCodeLine{450 }
\DoxyCodeLine{451     \textcolor{comment}{// Parse length and convert the argument to the required type.}}
\DoxyCodeLine{452     c = it != end ? *it++ : 0;}
\DoxyCodeLine{453     Char t = it != end ? *it : 0;}
\DoxyCodeLine{454     \textcolor{keyword}{using }detail::convert\_arg;}
\DoxyCodeLine{455     \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{456     \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:}
\DoxyCodeLine{457       \textcolor{keywordflow}{if} (t == \textcolor{charliteral}{'h'}) \{}
\DoxyCodeLine{458         ++it;}
\DoxyCodeLine{459         t = it != end ? *it : 0;}
\DoxyCodeLine{460         convert\_arg<signed char>(arg, t);}
\DoxyCodeLine{461       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{462         convert\_arg<short>(arg, t);}
\DoxyCodeLine{463       \}}
\DoxyCodeLine{464       \textcolor{keywordflow}{break};}
\DoxyCodeLine{465     \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{466       \textcolor{keywordflow}{if} (t == \textcolor{charliteral}{'l'}) \{}
\DoxyCodeLine{467         ++it;}
\DoxyCodeLine{468         t = it != end ? *it : 0;}
\DoxyCodeLine{469         convert\_arg<long long>(arg, t);}
\DoxyCodeLine{470       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{471         convert\_arg<long>(arg, t);}
\DoxyCodeLine{472       \}}
\DoxyCodeLine{473       \textcolor{keywordflow}{break};}
\DoxyCodeLine{474     \textcolor{keywordflow}{case} \textcolor{charliteral}{'j'}:}
\DoxyCodeLine{475       convert\_arg<intmax\_t>(arg, t);}
\DoxyCodeLine{476       \textcolor{keywordflow}{break};}
\DoxyCodeLine{477     \textcolor{keywordflow}{case} \textcolor{charliteral}{'z'}:}
\DoxyCodeLine{478       convert\_arg<size\_t>(arg, t);}
\DoxyCodeLine{479       \textcolor{keywordflow}{break};}
\DoxyCodeLine{480     \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'}:}
\DoxyCodeLine{481       convert\_arg<std::ptrdiff\_t>(arg, t);}
\DoxyCodeLine{482       \textcolor{keywordflow}{break};}
\DoxyCodeLine{483     \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{484       \textcolor{comment}{// printf produces garbage when 'L' is omitted for long double, no}}
\DoxyCodeLine{485       \textcolor{comment}{// need to do the same.}}
\DoxyCodeLine{486       \textcolor{keywordflow}{break};}
\DoxyCodeLine{487     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{488       -\/-\/it;}
\DoxyCodeLine{489       convert\_arg<void>(arg, c);}
\DoxyCodeLine{490     \}}
\DoxyCodeLine{491 }
\DoxyCodeLine{492     \textcolor{comment}{// Parse type.}}
\DoxyCodeLine{493     \textcolor{keywordflow}{if} (it == end) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format string"{}}));}
\DoxyCodeLine{494     \textcolor{keywordtype}{char} type = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(*it++);}
\DoxyCodeLine{495     \textcolor{keywordflow}{if} (arg.is\_integral()) \{}
\DoxyCodeLine{496       \textcolor{comment}{// Normalize type.}}
\DoxyCodeLine{497       \textcolor{keywordflow}{switch} (type) \{}
\DoxyCodeLine{498       \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{499       \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{500         type = \textcolor{charliteral}{'d'};}
\DoxyCodeLine{501         \textcolor{keywordflow}{break};}
\DoxyCodeLine{502       \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}:}
\DoxyCodeLine{503         visit\_format\_arg(}
\DoxyCodeLine{504             detail::char\_converter<\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<OutputIt, Char>}}>(arg),}
\DoxyCodeLine{505             arg);}
\DoxyCodeLine{506         \textcolor{keywordflow}{break};}
\DoxyCodeLine{507       \}}
\DoxyCodeLine{508     \}}
\DoxyCodeLine{509     specs.type = parse\_presentation\_type(type);}
\DoxyCodeLine{510     \textcolor{keywordflow}{if} (specs.type == presentation\_type::none)}
\DoxyCodeLine{511       parse\_ctx.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{512 }
\DoxyCodeLine{513     start = it;}
\DoxyCodeLine{514 }
\DoxyCodeLine{515     \textcolor{comment}{// Format argument.}}
\DoxyCodeLine{516     out = visit\_format\_arg(}
\DoxyCodeLine{517         detail::printf\_arg\_formatter<OutputIt, Char>(out, specs, context), arg);}
\DoxyCodeLine{518   \}}
\DoxyCodeLine{519   detail::write(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(start, to\_unsigned(it -\/ start)));}
\DoxyCodeLine{520 \}}
\DoxyCodeLine{521 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{522 }
\DoxyCodeLine{523 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{524 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t}} =}
\DoxyCodeLine{525     \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<detail::buffer\_appender<Char>}}, Char>;}
\DoxyCodeLine{526 }
\DoxyCodeLine{527 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__printf__context}{printf\_context}} = \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t<char>}};}
\DoxyCodeLine{528 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__printf__context}{wprintf\_context}} = \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t<wchar\_t>}};}
\DoxyCodeLine{529 }
\DoxyCodeLine{530 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{printf\_args}} = \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<printf\_context>}};}
\DoxyCodeLine{531 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{wprintf\_args}} = \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<wprintf\_context>}};}
\DoxyCodeLine{532 }
\DoxyCodeLine{539 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{540 \textcolor{keyword}{inline} \textcolor{keyword}{auto} make\_printf\_args(\textcolor{keyword}{const} T\&... args)}
\DoxyCodeLine{541     -\/> \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__printf__context}{printf\_context}}, T...> \{}
\DoxyCodeLine{542   \textcolor{keywordflow}{return} \{args...\};}
\DoxyCodeLine{543 \}}
\DoxyCodeLine{544 }
\DoxyCodeLine{551 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{552 \textcolor{keyword}{inline} \textcolor{keyword}{auto} make\_wprintf\_args(\textcolor{keyword}{const} T\&... args)}
\DoxyCodeLine{553     -\/> \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__printf__context}{wprintf\_context}}, T...> \{}
\DoxyCodeLine{554   \textcolor{keywordflow}{return} \{args...\};}
\DoxyCodeLine{555 \}}
\DoxyCodeLine{556 }
\DoxyCodeLine{557 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}\_t<S>>}
\DoxyCodeLine{558 \textcolor{keyword}{inline} \textcolor{keyword}{auto} vsprintf(}
\DoxyCodeLine{559     \textcolor{keyword}{const} S\& fmt,}
\DoxyCodeLine{560     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t}}<type\_identity\_t<Char>>> args)}
\DoxyCodeLine{561     -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{562   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}} \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{563   vprintf(\mbox{\hyperlink{classbuffer}{buffer}}, detail::to\_string\_view(fmt), args);}
\DoxyCodeLine{564   \textcolor{keywordflow}{return} to\_string(\mbox{\hyperlink{classbuffer}{buffer}});}
\DoxyCodeLine{565 \}}
\DoxyCodeLine{566 }
\DoxyCodeLine{576 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{577           \textcolor{keyword}{typename} Char = enable\_if\_t<detail::is\_string<S>::value, char\_t<S>>>}
\DoxyCodeLine{578 \textcolor{keyword}{inline} \textcolor{keyword}{auto} sprintf(\textcolor{keyword}{const} S\& fmt, \textcolor{keyword}{const} T\&... args) -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{579   \textcolor{keyword}{using }context = \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t<Char>}};}
\DoxyCodeLine{580   \textcolor{keywordflow}{return} vsprintf(detail::to\_string\_view(fmt),}
\DoxyCodeLine{581                   fmt::make\_format\_args<context>(args...));}
\DoxyCodeLine{582 \}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}\_t<S>>}
\DoxyCodeLine{585 \textcolor{keyword}{inline} \textcolor{keyword}{auto} vfprintf(}
\DoxyCodeLine{586     std::FILE* f, \textcolor{keyword}{const} S\& fmt,}
\DoxyCodeLine{587     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t}}<type\_identity\_t<Char>>> args)}
\DoxyCodeLine{588     -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{589   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}} \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{590   vprintf(\mbox{\hyperlink{classbuffer}{buffer}}, detail::to\_string\_view(fmt), args);}
\DoxyCodeLine{591   \textcolor{keywordtype}{size\_t} size = \mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{592   \textcolor{keywordflow}{return} std::fwrite(\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \textcolor{keyword}{sizeof}(Char), size, f) < size}
\DoxyCodeLine{593              ? -\/1}
\DoxyCodeLine{594              : \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size);}
\DoxyCodeLine{595 \}}
\DoxyCodeLine{596 }
\DoxyCodeLine{606 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... T, \textcolor{keyword}{typename} Char = char\_t<S>>}
\DoxyCodeLine{607 \textcolor{keyword}{inline} \textcolor{keyword}{auto} fprintf(std::FILE* f, \textcolor{keyword}{const} S\& fmt, \textcolor{keyword}{const} T\&... args) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{608   \textcolor{keyword}{using }context = \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t<Char>}};}
\DoxyCodeLine{609   \textcolor{keywordflow}{return} vfprintf(f, detail::to\_string\_view(fmt),}
\DoxyCodeLine{610                   fmt::make\_format\_args<context>(args...));}
\DoxyCodeLine{611 \}}
\DoxyCodeLine{612 }
\DoxyCodeLine{613 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}\_t<S>>}
\DoxyCodeLine{614 \textcolor{keyword}{inline} \textcolor{keyword}{auto} vprintf(}
\DoxyCodeLine{615     \textcolor{keyword}{const} S\& fmt,}
\DoxyCodeLine{616     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t}}<type\_identity\_t<Char>>> args)}
\DoxyCodeLine{617     -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{618   \textcolor{keywordflow}{return} vfprintf(stdout, detail::to\_string\_view(fmt), args);}
\DoxyCodeLine{619 \}}
\DoxyCodeLine{620 }
\DoxyCodeLine{630 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... T, FMT\_ENABLE\_IF(detail::is\_string<S>::value)>}
\DoxyCodeLine{631 \textcolor{keyword}{inline} \textcolor{keyword}{auto} printf(\textcolor{keyword}{const} S\& fmt, \textcolor{keyword}{const} T\&... args) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{632   \textcolor{keywordflow}{return} vprintf(}
\DoxyCodeLine{633       detail::to\_string\_view(fmt),}
\DoxyCodeLine{634       fmt::make\_format\_args<\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context\_t}}<char\_t<S>>>(args...));}
\DoxyCodeLine{635 \}}
\DoxyCodeLine{636 }
\DoxyCodeLine{637 FMT\_MODULE\_EXPORT\_END}
\DoxyCodeLine{638 FMT\_END\_NAMESPACE}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_PRINTF\_H\_}}

\end{DoxyCode}

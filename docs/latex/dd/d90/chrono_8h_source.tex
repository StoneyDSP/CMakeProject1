\hypertarget{chrono_8h_source}{}\doxysection{chrono.\+h}
\label{chrono_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/chrono.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/chrono.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ chrono support}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_CHRONO\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_CHRONO\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cmath>}    \textcolor{comment}{// std::isfinite}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <cstring>}  \textcolor{comment}{// std::memcpy}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <locale>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{comment}{// Enable tzset.}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#ifndef FMT\_USE\_TZSET}}
\DoxyCodeLine{27 \textcolor{comment}{// UWP doesn't provide \_tzset.}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#  if FMT\_HAS\_INCLUDE("{}winapifamily.h"{}})}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#    include <winapifamily.h>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#  if defined(\_WIN32) \&\& (!defined(WINAPI\_FAMILY) || \(\backslash\)}}
\DoxyCodeLine{32 \textcolor{preprocessor}{                          (WINAPI\_FAMILY == WINAPI\_FAMILY\_DESKTOP\_APP))}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#    define FMT\_USE\_TZSET 1}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#    define FMT\_USE\_TZSET 0}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{comment}{// Enable safe chrono durations, unless explicitly disabled.}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#ifndef FMT\_SAFE\_DURATION\_CAST}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#  define FMT\_SAFE\_DURATION\_CAST 1}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#if FMT\_SAFE\_DURATION\_CAST}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{comment}{// For conversion between std::chrono::durations without undefined}}
\DoxyCodeLine{46 \textcolor{comment}{// behaviour or erroneous results.}}
\DoxyCodeLine{47 \textcolor{comment}{// This is a stripped down version of duration\_cast, for inclusion in fmt.}}
\DoxyCodeLine{48 \textcolor{comment}{// See https://github.com/pauldreik/safe\_duration\_cast}}
\DoxyCodeLine{49 \textcolor{comment}{//}}
\DoxyCodeLine{50 \textcolor{comment}{// Copyright Paul Dreik 2019}}
\DoxyCodeLine{51 \textcolor{keyword}{namespace }safe\_duration\_cast \{}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From,}
\DoxyCodeLine{54           FMT\_ENABLE\_IF(!std::is\_same<From, To>::value \&\&}
\DoxyCodeLine{55                         std::numeric\_limits<From>::is\_signed ==}
\DoxyCodeLine{56                             std::numeric\_limits<To>::is\_signed)>}
\DoxyCodeLine{57 FMT\_CONSTEXPR To lossless\_integral\_conversion(\textcolor{keyword}{const} From from, \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{58   ec = 0;}
\DoxyCodeLine{59   \textcolor{keyword}{using }F = std::numeric\_limits<From>;}
\DoxyCodeLine{60   \textcolor{keyword}{using }T = std::numeric\_limits<To>;}
\DoxyCodeLine{61   \textcolor{keyword}{static\_assert}(F::is\_integer, \textcolor{stringliteral}{"{}From must be integral"{}});}
\DoxyCodeLine{62   \textcolor{keyword}{static\_assert}(T::is\_integer, \textcolor{stringliteral}{"{}To must be integral"{}});}
\DoxyCodeLine{63 }
\DoxyCodeLine{64   \textcolor{comment}{// A and B are both signed, or both unsigned.}}
\DoxyCodeLine{65   \textcolor{keywordflow}{if} (detail::const\_check(F::digits <= T::digits)) \{}
\DoxyCodeLine{66     \textcolor{comment}{// From fits in To without any problem.}}
\DoxyCodeLine{67   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{68     \textcolor{comment}{// From does not always fit in To, resort to a dynamic check.}}
\DoxyCodeLine{69     \textcolor{keywordflow}{if} (from < (T::min)() || from > (T::max)()) \{}
\DoxyCodeLine{70       \textcolor{comment}{// outside range.}}
\DoxyCodeLine{71       ec = 1;}
\DoxyCodeLine{72       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{73     \}}
\DoxyCodeLine{74   \}}
\DoxyCodeLine{75   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}To\textcolor{keyword}{>}(from);}
\DoxyCodeLine{76 \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{82 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From,}
\DoxyCodeLine{83           FMT\_ENABLE\_IF(!std::is\_same<From, To>::value \&\&}
\DoxyCodeLine{84                         std::numeric\_limits<From>::is\_signed !=}
\DoxyCodeLine{85                             std::numeric\_limits<To>::is\_signed)>}
\DoxyCodeLine{86 FMT\_CONSTEXPR To lossless\_integral\_conversion(\textcolor{keyword}{const} From from, \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{87   ec = 0;}
\DoxyCodeLine{88   \textcolor{keyword}{using }F = std::numeric\_limits<From>;}
\DoxyCodeLine{89   \textcolor{keyword}{using }T = std::numeric\_limits<To>;}
\DoxyCodeLine{90   \textcolor{keyword}{static\_assert}(F::is\_integer, \textcolor{stringliteral}{"{}From must be integral"{}});}
\DoxyCodeLine{91   \textcolor{keyword}{static\_assert}(T::is\_integer, \textcolor{stringliteral}{"{}To must be integral"{}});}
\DoxyCodeLine{92 }
\DoxyCodeLine{93   \textcolor{keywordflow}{if} (detail::const\_check(F::is\_signed \&\& !T::is\_signed)) \{}
\DoxyCodeLine{94     \textcolor{comment}{// From may be negative, not allowed!}}
\DoxyCodeLine{95     \textcolor{keywordflow}{if} (fmt::detail::is\_negative(from)) \{}
\DoxyCodeLine{96       ec = 1;}
\DoxyCodeLine{97       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{98     \}}
\DoxyCodeLine{99     \textcolor{comment}{// From is positive. Can it always fit in To?}}
\DoxyCodeLine{100     \textcolor{keywordflow}{if} (detail::const\_check(F::digits > T::digits) \&\&}
\DoxyCodeLine{101         from > \textcolor{keyword}{static\_cast<}From\textcolor{keyword}{>}(detail::max\_value<To>())) \{}
\DoxyCodeLine{102       ec = 1;}
\DoxyCodeLine{103       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{104     \}}
\DoxyCodeLine{105   \}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107   \textcolor{keywordflow}{if} (detail::const\_check(!F::is\_signed \&\& T::is\_signed \&\&}
\DoxyCodeLine{108                           F::digits >= T::digits) \&\&}
\DoxyCodeLine{109       from > \textcolor{keyword}{static\_cast<}From\textcolor{keyword}{>}(detail::max\_value<To>())) \{}
\DoxyCodeLine{110     ec = 1;}
\DoxyCodeLine{111     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{112   \}}
\DoxyCodeLine{113   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}To\textcolor{keyword}{>}(from);  \textcolor{comment}{// Lossless conversion.}}
\DoxyCodeLine{114 \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From,}
\DoxyCodeLine{117           FMT\_ENABLE\_IF(std::is\_same<From, To>::value)>}
\DoxyCodeLine{118 FMT\_CONSTEXPR To lossless\_integral\_conversion(\textcolor{keyword}{const} From from, \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{119   ec = 0;}
\DoxyCodeLine{120   \textcolor{keywordflow}{return} from;}
\DoxyCodeLine{121 \}  \textcolor{comment}{// function}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{comment}{// clang-\/format off}}
\DoxyCodeLine{136 \textcolor{comment}{}\textcolor{comment}{// clang-\/format on}}
\DoxyCodeLine{137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From,}
\DoxyCodeLine{138           FMT\_ENABLE\_IF(!std::is\_same<From, To>::value)>}
\DoxyCodeLine{139 FMT\_CONSTEXPR To safe\_float\_conversion(\textcolor{keyword}{const} From from, \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{140   ec = 0;}
\DoxyCodeLine{141   \textcolor{keyword}{using }T = std::numeric\_limits<To>;}
\DoxyCodeLine{142   \textcolor{keyword}{static\_assert}(std::is\_floating\_point<From>::value, \textcolor{stringliteral}{"{}From must be floating"{}});}
\DoxyCodeLine{143   \textcolor{keyword}{static\_assert}(std::is\_floating\_point<To>::value, \textcolor{stringliteral}{"{}To must be floating"{}});}
\DoxyCodeLine{144 }
\DoxyCodeLine{145   \textcolor{comment}{// catch the only happy case}}
\DoxyCodeLine{146   \textcolor{keywordflow}{if} (std::isfinite(from)) \{}
\DoxyCodeLine{147     \textcolor{keywordflow}{if} (from >= T::lowest() \&\& from <= (T::max)()) \{}
\DoxyCodeLine{148       \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}To\textcolor{keyword}{>}(from);}
\DoxyCodeLine{149     \}}
\DoxyCodeLine{150     \textcolor{comment}{// not within range.}}
\DoxyCodeLine{151     ec = 1;}
\DoxyCodeLine{152     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{153   \}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{comment}{// nan and inf will be preserved}}
\DoxyCodeLine{156   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}To\textcolor{keyword}{>}(from);}
\DoxyCodeLine{157 \}  \textcolor{comment}{// function}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From,}
\DoxyCodeLine{160           FMT\_ENABLE\_IF(std::is\_same<From, To>::value)>}
\DoxyCodeLine{161 FMT\_CONSTEXPR To safe\_float\_conversion(\textcolor{keyword}{const} From from, \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{162   ec = 0;}
\DoxyCodeLine{163   \textcolor{keyword}{static\_assert}(std::is\_floating\_point<From>::value, \textcolor{stringliteral}{"{}From must be floating"{}});}
\DoxyCodeLine{164   \textcolor{keywordflow}{return} from;}
\DoxyCodeLine{165 \}}
\DoxyCodeLine{166 }
\DoxyCodeLine{170 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} FromRep, \textcolor{keyword}{typename} FromPeriod,}
\DoxyCodeLine{171           FMT\_ENABLE\_IF(std::is\_integral<FromRep>::value),}
\DoxyCodeLine{172           FMT\_ENABLE\_IF(std::is\_integral<typename To::rep>::value)>}
\DoxyCodeLine{173 To safe\_duration\_cast(std::chrono::duration<FromRep, FromPeriod> from,}
\DoxyCodeLine{174                       \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{175   \textcolor{keyword}{using }From = std::chrono::duration<FromRep, FromPeriod>;}
\DoxyCodeLine{176   ec = 0;}
\DoxyCodeLine{177   \textcolor{comment}{// the basic idea is that we need to convert from count() in the from type}}
\DoxyCodeLine{178   \textcolor{comment}{// to count() in the To type, by multiplying it with this:}}
\DoxyCodeLine{179   \textcolor{keyword}{struct }Factor}
\DoxyCodeLine{180       : std::ratio\_divide<typename From::period, typename To::period> \{\};}
\DoxyCodeLine{181 }
\DoxyCodeLine{182   \textcolor{keyword}{static\_assert}(Factor::num > 0, \textcolor{stringliteral}{"{}num must be positive"{}});}
\DoxyCodeLine{183   \textcolor{keyword}{static\_assert}(Factor::den > 0, \textcolor{stringliteral}{"{}den must be positive"{}});}
\DoxyCodeLine{184 }
\DoxyCodeLine{185   \textcolor{comment}{// the conversion is like this: multiply from.count() with Factor::num}}
\DoxyCodeLine{186   \textcolor{comment}{// /Factor::den and convert it to To::rep, all this without}}
\DoxyCodeLine{187   \textcolor{comment}{// overflow/underflow. let's start by finding a suitable type that can hold}}
\DoxyCodeLine{188   \textcolor{comment}{// both To, From and Factor::num}}
\DoxyCodeLine{189   \textcolor{keyword}{using }IntermediateRep =}
\DoxyCodeLine{190       \textcolor{keyword}{typename} std::common\_type<\textcolor{keyword}{typename} From::rep, \textcolor{keyword}{typename} To::rep,}
\DoxyCodeLine{191                                 \textcolor{keyword}{decltype}(Factor::num)>::type;}
\DoxyCodeLine{192 }
\DoxyCodeLine{193   \textcolor{comment}{// safe conversion to IntermediateRep}}
\DoxyCodeLine{194   IntermediateRep count =}
\DoxyCodeLine{195       lossless\_integral\_conversion<IntermediateRep>(from.count(), ec);}
\DoxyCodeLine{196   \textcolor{keywordflow}{if} (ec) \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{197   \textcolor{comment}{// multiply with Factor::num without overflow or underflow}}
\DoxyCodeLine{198   \textcolor{keywordflow}{if} (detail::const\_check(Factor::num != 1)) \{}
\DoxyCodeLine{199     \textcolor{keyword}{const} \textcolor{keyword}{auto} max1 = detail::max\_value<IntermediateRep>() / Factor::num;}
\DoxyCodeLine{200     \textcolor{keywordflow}{if} (count > max1) \{}
\DoxyCodeLine{201       ec = 1;}
\DoxyCodeLine{202       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{203     \}}
\DoxyCodeLine{204     \textcolor{keyword}{const} \textcolor{keyword}{auto} min1 =}
\DoxyCodeLine{205         (std::numeric\_limits<IntermediateRep>::min)() / Factor::num;}
\DoxyCodeLine{206     \textcolor{keywordflow}{if} (count < min1) \{}
\DoxyCodeLine{207       ec = 1;}
\DoxyCodeLine{208       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{209     \}}
\DoxyCodeLine{210     count *= Factor::num;}
\DoxyCodeLine{211   \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213   \textcolor{keywordflow}{if} (detail::const\_check(Factor::den != 1)) count /= Factor::den;}
\DoxyCodeLine{214   \textcolor{keyword}{auto} tocount = lossless\_integral\_conversion<typename To::rep>(count, ec);}
\DoxyCodeLine{215   \textcolor{keywordflow}{return} ec ? To() : To(tocount);}
\DoxyCodeLine{216 \}}
\DoxyCodeLine{217 }
\DoxyCodeLine{221 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} FromRep, \textcolor{keyword}{typename} FromPeriod,}
\DoxyCodeLine{222           FMT\_ENABLE\_IF(std::is\_floating\_point<FromRep>::value),}
\DoxyCodeLine{223           FMT\_ENABLE\_IF(std::is\_floating\_point<typename To::rep>::value)>}
\DoxyCodeLine{224 To safe\_duration\_cast(std::chrono::duration<FromRep, FromPeriod> from,}
\DoxyCodeLine{225                       \textcolor{keywordtype}{int}\& ec) \{}
\DoxyCodeLine{226   \textcolor{keyword}{using }From = std::chrono::duration<FromRep, FromPeriod>;}
\DoxyCodeLine{227   ec = 0;}
\DoxyCodeLine{228   \textcolor{keywordflow}{if} (std::isnan(from.count())) \{}
\DoxyCodeLine{229     \textcolor{comment}{// nan in, gives nan out. easy.}}
\DoxyCodeLine{230     \textcolor{keywordflow}{return} To\{std::numeric\_limits<typename To::rep>::quiet\_NaN()\};}
\DoxyCodeLine{231   \}}
\DoxyCodeLine{232   \textcolor{comment}{// maybe we should also check if from is denormal, and decide what to do about}}
\DoxyCodeLine{233   \textcolor{comment}{// it.}}
\DoxyCodeLine{234 }
\DoxyCodeLine{235   \textcolor{comment}{// +-\/inf should be preserved.}}
\DoxyCodeLine{236   \textcolor{keywordflow}{if} (std::isinf(from.count())) \{}
\DoxyCodeLine{237     \textcolor{keywordflow}{return} To\{from.count()\};}
\DoxyCodeLine{238   \}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240   \textcolor{comment}{// the basic idea is that we need to convert from count() in the from type}}
\DoxyCodeLine{241   \textcolor{comment}{// to count() in the To type, by multiplying it with this:}}
\DoxyCodeLine{242   \textcolor{keyword}{struct }Factor}
\DoxyCodeLine{243       : std::ratio\_divide<typename From::period, typename To::period> \{\};}
\DoxyCodeLine{244 }
\DoxyCodeLine{245   \textcolor{keyword}{static\_assert}(Factor::num > 0, \textcolor{stringliteral}{"{}num must be positive"{}});}
\DoxyCodeLine{246   \textcolor{keyword}{static\_assert}(Factor::den > 0, \textcolor{stringliteral}{"{}den must be positive"{}});}
\DoxyCodeLine{247 }
\DoxyCodeLine{248   \textcolor{comment}{// the conversion is like this: multiply from.count() with Factor::num}}
\DoxyCodeLine{249   \textcolor{comment}{// /Factor::den and convert it to To::rep, all this without}}
\DoxyCodeLine{250   \textcolor{comment}{// overflow/underflow. let's start by finding a suitable type that can hold}}
\DoxyCodeLine{251   \textcolor{comment}{// both To, From and Factor::num}}
\DoxyCodeLine{252   \textcolor{keyword}{using }IntermediateRep =}
\DoxyCodeLine{253       \textcolor{keyword}{typename} std::common\_type<\textcolor{keyword}{typename} From::rep, \textcolor{keyword}{typename} To::rep,}
\DoxyCodeLine{254                                 \textcolor{keyword}{decltype}(Factor::num)>::type;}
\DoxyCodeLine{255 }
\DoxyCodeLine{256   \textcolor{comment}{// force conversion of From::rep -\/> IntermediateRep to be safe,}}
\DoxyCodeLine{257   \textcolor{comment}{// even if it will never happen be narrowing in this context.}}
\DoxyCodeLine{258   IntermediateRep count =}
\DoxyCodeLine{259       safe\_float\_conversion<IntermediateRep>(from.count(), ec);}
\DoxyCodeLine{260   \textcolor{keywordflow}{if} (ec) \{}
\DoxyCodeLine{261     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{262   \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264   \textcolor{comment}{// multiply with Factor::num without overflow or underflow}}
\DoxyCodeLine{265   \textcolor{keywordflow}{if} (detail::const\_check(Factor::num != 1)) \{}
\DoxyCodeLine{266     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} max1 = detail::max\_value<IntermediateRep>() /}
\DoxyCodeLine{267                           \textcolor{keyword}{static\_cast<}IntermediateRep\textcolor{keyword}{>}(Factor::num);}
\DoxyCodeLine{268     \textcolor{keywordflow}{if} (count > max1) \{}
\DoxyCodeLine{269       ec = 1;}
\DoxyCodeLine{270       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{271     \}}
\DoxyCodeLine{272     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} min1 = std::numeric\_limits<IntermediateRep>::lowest() /}
\DoxyCodeLine{273                           \textcolor{keyword}{static\_cast<}IntermediateRep\textcolor{keyword}{>}(Factor::num);}
\DoxyCodeLine{274     \textcolor{keywordflow}{if} (count < min1) \{}
\DoxyCodeLine{275       ec = 1;}
\DoxyCodeLine{276       \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278     count *= \textcolor{keyword}{static\_cast<}IntermediateRep\textcolor{keyword}{>}(Factor::num);}
\DoxyCodeLine{279   \}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281   \textcolor{comment}{// this can't go wrong, right? den>0 is checked earlier.}}
\DoxyCodeLine{282   \textcolor{keywordflow}{if} (detail::const\_check(Factor::den != 1)) \{}
\DoxyCodeLine{283     \textcolor{keyword}{using }common\_t = \textcolor{keyword}{typename} std::common\_type<IntermediateRep, intmax\_t>::type;}
\DoxyCodeLine{284     count /= \textcolor{keyword}{static\_cast<}common\_t\textcolor{keyword}{>}(Factor::den);}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287   \textcolor{comment}{// convert to the to type, safely}}
\DoxyCodeLine{288   \textcolor{keyword}{using }ToRep = \textcolor{keyword}{typename} To::rep;}
\DoxyCodeLine{289 }
\DoxyCodeLine{290   \textcolor{keyword}{const} ToRep tocount = safe\_float\_conversion<ToRep>(count, ec);}
\DoxyCodeLine{291   \textcolor{keywordflow}{if} (ec) \{}
\DoxyCodeLine{292     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{293   \}}
\DoxyCodeLine{294   \textcolor{keywordflow}{return} To\{tocount\};}
\DoxyCodeLine{295 \}}
\DoxyCodeLine{296 \}  \textcolor{comment}{// namespace safe\_duration\_cast}}
\DoxyCodeLine{297 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{298 }
\DoxyCodeLine{299 \textcolor{comment}{// Prevents expansion of a preceding token as a function-\/style macro.}}
\DoxyCodeLine{300 \textcolor{comment}{// Usage: f FMT\_NOMACRO()}}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#define FMT\_NOMACRO}}
\DoxyCodeLine{302 }
\DoxyCodeLine{303 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{304 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1null}{null}} \{\};}
\DoxyCodeLine{305 \textcolor{keyword}{inline} \mbox{\hyperlink{structdetail_1_1null}{null<>}} localtime\_r FMT\_NOMACRO(...) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{structdetail_1_1null}{null<>}}(); \}}
\DoxyCodeLine{306 \textcolor{keyword}{inline} null<> localtime\_s(...) \{ \textcolor{keywordflow}{return} null<>(); \}}
\DoxyCodeLine{307 \textcolor{keyword}{inline} null<> gmtime\_r(...) \{ \textcolor{keywordflow}{return} null<>(); \}}
\DoxyCodeLine{308 \textcolor{keyword}{inline} null<> gmtime\_s(...) \{ \textcolor{keywordflow}{return} null<>(); \}}
\DoxyCodeLine{309 }
\DoxyCodeLine{310 \textcolor{keyword}{inline} \textcolor{keyword}{const} std::locale\& get\_classic\_locale() \{}
\DoxyCodeLine{311   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{auto}\& locale = std::locale::classic();}
\DoxyCodeLine{312   \textcolor{keywordflow}{return} locale;}
\DoxyCodeLine{313 \}}
\DoxyCodeLine{314 }
\DoxyCodeLine{315 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CodeUnit> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1codecvt__result}{codecvt\_result}} \{}
\DoxyCodeLine{316   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_size = 32;}
\DoxyCodeLine{317   CodeUnit buf[max\_size];}
\DoxyCodeLine{318   CodeUnit* end;}
\DoxyCodeLine{319 \};}
\DoxyCodeLine{320 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CodeUnit>}
\DoxyCodeLine{321 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{structdetail_1_1codecvt__result}{codecvt\_result<CodeUnit>::max\_size}};}
\DoxyCodeLine{322 }
\DoxyCodeLine{323 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CodeUnit>}
\DoxyCodeLine{324 \textcolor{keywordtype}{void} write\_codecvt(\mbox{\hyperlink{structdetail_1_1codecvt__result}{codecvt\_result<CodeUnit>}}\& out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} in\_buf,}
\DoxyCodeLine{325                    \textcolor{keyword}{const} std::locale\& loc) \{}
\DoxyCodeLine{326 \textcolor{preprocessor}{\#if FMT\_CLANG\_VERSION}}
\DoxyCodeLine{327 \textcolor{preprocessor}{\#  pragma clang diagnostic push}}
\DoxyCodeLine{328 \textcolor{preprocessor}{\#  pragma clang diagnostic ignored "{}-\/Wdeprecated"{}}}
\DoxyCodeLine{329   \textcolor{keyword}{auto}\& f = std::use\_facet<std::codecvt<CodeUnit, char, std::mbstate\_t>>(loc);}
\DoxyCodeLine{330 \textcolor{preprocessor}{\#  pragma clang diagnostic pop}}
\DoxyCodeLine{331 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{332   \textcolor{keyword}{auto}\& f = std::use\_facet<std::codecvt<CodeUnit, char, std::mbstate\_t>>(loc);}
\DoxyCodeLine{333 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{334   \textcolor{keyword}{auto} mb = std::mbstate\_t();}
\DoxyCodeLine{335   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* from\_next = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{336   \textcolor{keyword}{auto} result = f.in(mb, in\_buf.begin(), in\_buf.end(), from\_next,}
\DoxyCodeLine{337                      std::begin(out.buf), std::end(out.buf), out.end);}
\DoxyCodeLine{338   \textcolor{keywordflow}{if} (result != std::codecvt\_base::ok)}
\DoxyCodeLine{339     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}failed to format time"{}}));}
\DoxyCodeLine{340 \}}
\DoxyCodeLine{341 }
\DoxyCodeLine{342 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{343 \textcolor{keyword}{auto} write\_encoded\_tm\_str(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} in, \textcolor{keyword}{const} std::locale\& loc)}
\DoxyCodeLine{344     -\/> OutputIt \{}
\DoxyCodeLine{345   \textcolor{keywordflow}{if} (detail::is\_utf8() \&\& loc != get\_classic\_locale()) \{}
\DoxyCodeLine{346     \textcolor{comment}{// char16\_t and char32\_t codecvts are broken in MSVC (linkage errors) and}}
\DoxyCodeLine{347     \textcolor{comment}{// gcc-\/4.}}
\DoxyCodeLine{348 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION != 0 || \(\backslash\)}}
\DoxyCodeLine{349 \textcolor{preprocessor}{    (defined(\_\_GLIBCXX\_\_) \&\& !defined(\_GLIBCXX\_USE\_DUAL\_ABI))}}
\DoxyCodeLine{350     \textcolor{comment}{// The \_GLIBCXX\_USE\_DUAL\_ABI macro is always defined in libstdc++ from gcc-\/5}}
\DoxyCodeLine{351     \textcolor{comment}{// and newer.}}
\DoxyCodeLine{352     \textcolor{keyword}{using }code\_unit = wchar\_t;}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{354     \textcolor{keyword}{using }code\_unit = char32\_t;}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{356 }
\DoxyCodeLine{357     \textcolor{keyword}{using }unit\_t = codecvt\_result<code\_unit>;}
\DoxyCodeLine{358     unit\_t unit;}
\DoxyCodeLine{359     write\_codecvt(unit, in, loc);}
\DoxyCodeLine{360     \textcolor{comment}{// In UTF-\/8 is used one to four one-\/byte code units.}}
\DoxyCodeLine{361     \textcolor{keyword}{auto}\&\& buf = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<char, unit\_t::max\_size * 4>}}();}
\DoxyCodeLine{362     \textcolor{keywordflow}{for} (code\_unit* p = unit.buf; p != unit.end; ++p) \{}
\DoxyCodeLine{363       uint32\_t c = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(*p);}
\DoxyCodeLine{364       \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(code\_unit) == 2 \&\& c >= 0xd800 \&\& c <= 0xdfff) \{}
\DoxyCodeLine{365         \textcolor{comment}{// surrogate pair}}
\DoxyCodeLine{366         ++p;}
\DoxyCodeLine{367         \textcolor{keywordflow}{if} (p == unit.end || (c \& 0xfc00) != 0xd800 ||}
\DoxyCodeLine{368             (*p \& 0xfc00) != 0xdc00) \{}
\DoxyCodeLine{369           FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}failed to format time"{}}));}
\DoxyCodeLine{370         \}}
\DoxyCodeLine{371         c = (c << 10) + static\_cast<uint32\_t>(*p) -\/ 0x35fdc00;}
\DoxyCodeLine{372       \}}
\DoxyCodeLine{373       \textcolor{keywordflow}{if} (c < 0x80) \{}
\DoxyCodeLine{374         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{375       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c < 0x800) \{}
\DoxyCodeLine{376         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xc0 | (c >> 6)));}
\DoxyCodeLine{377         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | (c \& 0x3f)));}
\DoxyCodeLine{378       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((c >= 0x800 \&\& c <= 0xd7ff) || (c >= 0xe000 \&\& c <= 0xffff)) \{}
\DoxyCodeLine{379         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xe0 | (c >> 12)));}
\DoxyCodeLine{380         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | ((c \& 0xfff) >> 6)));}
\DoxyCodeLine{381         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | (c \& 0x3f)));}
\DoxyCodeLine{382       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c >= 0x10000 \&\& c <= 0x10ffff) \{}
\DoxyCodeLine{383         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xf0 | (c >> 18)));}
\DoxyCodeLine{384         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | ((c \& 0x3ffff) >> 12)));}
\DoxyCodeLine{385         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | ((c \& 0xfff) >> 6)));}
\DoxyCodeLine{386         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | (c \& 0x3f)));}
\DoxyCodeLine{387       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{388         FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}failed to format time"{}}));}
\DoxyCodeLine{389       \}}
\DoxyCodeLine{390     \}}
\DoxyCodeLine{391     \textcolor{keywordflow}{return} copy\_str<char>(buf.data(), buf.data() + buf.size(), out);}
\DoxyCodeLine{392   \}}
\DoxyCodeLine{393   \textcolor{keywordflow}{return} copy\_str<char>(in.data(), in.data() + in.size(), out);}
\DoxyCodeLine{394 \}}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{397           FMT\_ENABLE\_IF(!std::is\_same<Char, char>::value)>}
\DoxyCodeLine{398 \textcolor{keyword}{auto} write\_tm\_str(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sv, \textcolor{keyword}{const} std::locale\& loc)}
\DoxyCodeLine{399     -\/> OutputIt \{}
\DoxyCodeLine{400   codecvt\_result<Char> unit;}
\DoxyCodeLine{401   write\_codecvt(unit, sv, loc);}
\DoxyCodeLine{402   \textcolor{keywordflow}{return} copy\_str<Char>(unit.buf, unit.end, out);}
\DoxyCodeLine{403 \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{406           FMT\_ENABLE\_IF(std::is\_same<Char, char>::value)>}
\DoxyCodeLine{407 \textcolor{keyword}{auto} write\_tm\_str(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sv, \textcolor{keyword}{const} std::locale\& loc)}
\DoxyCodeLine{408     -\/> OutputIt \{}
\DoxyCodeLine{409   \textcolor{keywordflow}{return} write\_encoded\_tm\_str(out, sv, loc);}
\DoxyCodeLine{410 \}}
\DoxyCodeLine{411 }
\DoxyCodeLine{412 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{413 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} do\_write(\mbox{\hyperlink{classbuffer}{buffer<Char>}}\& buf, \textcolor{keyword}{const} std::tm\& time,}
\DoxyCodeLine{414                      \textcolor{keyword}{const} std::locale\& loc, \textcolor{keywordtype}{char} format, \textcolor{keywordtype}{char} modifier) \{}
\DoxyCodeLine{415   \textcolor{keyword}{auto}\&\& format\_buf = formatbuf<std::basic\_streambuf<Char>>(buf);}
\DoxyCodeLine{416   \textcolor{keyword}{auto}\&\& os = std::basic\_ostream<Char>(\&format\_buf);}
\DoxyCodeLine{417   os.imbue(loc);}
\DoxyCodeLine{418   \textcolor{keyword}{using }iterator = std::ostreambuf\_iterator<Char>;}
\DoxyCodeLine{419   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& facet = std::use\_facet<std::time\_put<Char, iterator>>(loc);}
\DoxyCodeLine{420   \textcolor{keyword}{auto} end = facet.put(os, os, Char(\textcolor{charliteral}{' '}), \&time, format, modifier);}
\DoxyCodeLine{421   \textcolor{keywordflow}{if} (end.failed()) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}failed to format time"{}}));}
\DoxyCodeLine{422 \}}
\DoxyCodeLine{423 }
\DoxyCodeLine{424 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{425           FMT\_ENABLE\_IF(!std::is\_same<Char, char>::value)>}
\DoxyCodeLine{426 \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} std::tm\& time, \textcolor{keyword}{const} std::locale\& loc,}
\DoxyCodeLine{427            \textcolor{keywordtype}{char} format, \textcolor{keywordtype}{char} modifier = 0) -\/> OutputIt \{}
\DoxyCodeLine{428   \textcolor{keyword}{auto}\&\& buf = get\_buffer<Char>(out);}
\DoxyCodeLine{429   do\_write<Char>(buf, time, loc, format, modifier);}
\DoxyCodeLine{430   \textcolor{keywordflow}{return} buf.out();}
\DoxyCodeLine{431 \}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{434           FMT\_ENABLE\_IF(std::is\_same<Char, char>::value)>}
\DoxyCodeLine{435 \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} std::tm\& time, \textcolor{keyword}{const} std::locale\& loc,}
\DoxyCodeLine{436            \textcolor{keywordtype}{char} format, \textcolor{keywordtype}{char} modifier = 0) -\/> OutputIt \{}
\DoxyCodeLine{437   \textcolor{keyword}{auto}\&\& buf = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{438   do\_write<char>(buf, time, loc, format, modifier);}
\DoxyCodeLine{439   \textcolor{keywordflow}{return} write\_encoded\_tm\_str(out, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()), loc);}
\DoxyCodeLine{440 \}}
\DoxyCodeLine{441 }
\DoxyCodeLine{442 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 FMT\_MODULE\_EXPORT\_BEGIN}
\DoxyCodeLine{445 }
\DoxyCodeLine{451 \textcolor{keyword}{inline} std::tm localtime(std::time\_t time) \{}
\DoxyCodeLine{452   \textcolor{keyword}{struct }dispatcher \{}
\DoxyCodeLine{453     std::time\_t time\_;}
\DoxyCodeLine{454     std::tm tm\_;}
\DoxyCodeLine{455 }
\DoxyCodeLine{456     dispatcher(std::time\_t t) : time\_(t) \{\}}
\DoxyCodeLine{457 }
\DoxyCodeLine{458     \textcolor{keywordtype}{bool} run() \{}
\DoxyCodeLine{459       \textcolor{keyword}{using namespace }fmt::detail;}
\DoxyCodeLine{460       \textcolor{keywordflow}{return} handle(localtime\_r(\&time\_, \&tm\_));}
\DoxyCodeLine{461     \}}
\DoxyCodeLine{462 }
\DoxyCodeLine{463     \textcolor{keywordtype}{bool} handle(std::tm* tm) \{ \textcolor{keywordflow}{return} tm != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{464 }
\DoxyCodeLine{465     \textcolor{keywordtype}{bool} handle(\mbox{\hyperlink{structdetail_1_1null}{detail::null<>}}) \{}
\DoxyCodeLine{466       \textcolor{keyword}{using namespace }fmt::detail;}
\DoxyCodeLine{467       \textcolor{keywordflow}{return} fallback(localtime\_s(\&tm\_, \&time\_));}
\DoxyCodeLine{468     \}}
\DoxyCodeLine{469 }
\DoxyCodeLine{470     \textcolor{keywordtype}{bool} fallback(\textcolor{keywordtype}{int} res) \{ \textcolor{keywordflow}{return} res == 0; \}}
\DoxyCodeLine{471 }
\DoxyCodeLine{472 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION}}
\DoxyCodeLine{473     \textcolor{keywordtype}{bool} fallback(\mbox{\hyperlink{structdetail_1_1null}{detail::null<>}}) \{}
\DoxyCodeLine{474       \textcolor{keyword}{using namespace }fmt::detail;}
\DoxyCodeLine{475       std::tm* tm = std::localtime(\&time\_);}
\DoxyCodeLine{476       \textcolor{keywordflow}{if} (tm) tm\_ = *tm;}
\DoxyCodeLine{477       \textcolor{keywordflow}{return} tm != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{478     \}}
\DoxyCodeLine{479 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{480   \};}
\DoxyCodeLine{481   dispatcher lt(time);}
\DoxyCodeLine{482   \textcolor{comment}{// Too big time values may be unsupported.}}
\DoxyCodeLine{483   \textcolor{keywordflow}{if} (!lt.run()) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}time\_t value out of range"{}}));}
\DoxyCodeLine{484   \textcolor{keywordflow}{return} lt.tm\_;}
\DoxyCodeLine{485 \}}
\DoxyCodeLine{486 }
\DoxyCodeLine{487 \textcolor{keyword}{inline} std::tm localtime(}
\DoxyCodeLine{488     std::chrono::time\_point<std::chrono::system\_clock> time\_point) \{}
\DoxyCodeLine{489   \textcolor{keywordflow}{return} localtime(std::chrono::system\_clock::to\_time\_t(time\_point));}
\DoxyCodeLine{490 \}}
\DoxyCodeLine{491 }
\DoxyCodeLine{497 \textcolor{keyword}{inline} std::tm gmtime(std::time\_t time) \{}
\DoxyCodeLine{498   \textcolor{keyword}{struct }dispatcher \{}
\DoxyCodeLine{499     std::time\_t time\_;}
\DoxyCodeLine{500     std::tm tm\_;}
\DoxyCodeLine{501 }
\DoxyCodeLine{502     dispatcher(std::time\_t t) : time\_(t) \{\}}
\DoxyCodeLine{503 }
\DoxyCodeLine{504     \textcolor{keywordtype}{bool} run() \{}
\DoxyCodeLine{505       \textcolor{keyword}{using namespace }fmt::detail;}
\DoxyCodeLine{506       \textcolor{keywordflow}{return} handle(gmtime\_r(\&time\_, \&tm\_));}
\DoxyCodeLine{507     \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509     \textcolor{keywordtype}{bool} handle(std::tm* tm) \{ \textcolor{keywordflow}{return} tm != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{510 }
\DoxyCodeLine{511     \textcolor{keywordtype}{bool} handle(\mbox{\hyperlink{structdetail_1_1null}{detail::null<>}}) \{}
\DoxyCodeLine{512       \textcolor{keyword}{using namespace }fmt::detail;}
\DoxyCodeLine{513       \textcolor{keywordflow}{return} fallback(gmtime\_s(\&tm\_, \&time\_));}
\DoxyCodeLine{514     \}}
\DoxyCodeLine{515 }
\DoxyCodeLine{516     \textcolor{keywordtype}{bool} fallback(\textcolor{keywordtype}{int} res) \{ \textcolor{keywordflow}{return} res == 0; \}}
\DoxyCodeLine{517 }
\DoxyCodeLine{518 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION}}
\DoxyCodeLine{519     \textcolor{keywordtype}{bool} fallback(\mbox{\hyperlink{structdetail_1_1null}{detail::null<>}}) \{}
\DoxyCodeLine{520       std::tm* tm = std::gmtime(\&time\_);}
\DoxyCodeLine{521       \textcolor{keywordflow}{if} (tm) tm\_ = *tm;}
\DoxyCodeLine{522       \textcolor{keywordflow}{return} tm != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{523     \}}
\DoxyCodeLine{524 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{525   \};}
\DoxyCodeLine{526   dispatcher gt(time);}
\DoxyCodeLine{527   \textcolor{comment}{// Too big time values may be unsupported.}}
\DoxyCodeLine{528   \textcolor{keywordflow}{if} (!gt.run()) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}time\_t value out of range"{}}));}
\DoxyCodeLine{529   \textcolor{keywordflow}{return} gt.tm\_;}
\DoxyCodeLine{530 \}}
\DoxyCodeLine{531 }
\DoxyCodeLine{532 \textcolor{keyword}{inline} std::tm gmtime(}
\DoxyCodeLine{533     std::chrono::time\_point<std::chrono::system\_clock> time\_point) \{}
\DoxyCodeLine{534   \textcolor{keywordflow}{return} gmtime(std::chrono::system\_clock::to\_time\_t(time\_point));}
\DoxyCodeLine{535 \}}
\DoxyCodeLine{536 }
\DoxyCodeLine{537 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{538 }
\DoxyCodeLine{539 \textcolor{comment}{// Writes two-\/digit numbers a, b and c separated by sep to buf.}}
\DoxyCodeLine{540 \textcolor{comment}{// The method by Pavel Novikov based on}}
\DoxyCodeLine{541 \textcolor{comment}{// https://johnnylee-\/sde.github.io/Fast-\/unsigned-\/integer-\/to-\/time-\/string/.}}
\DoxyCodeLine{542 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} write\_digit2\_separated(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{unsigned} a, \textcolor{keywordtype}{unsigned} b,}
\DoxyCodeLine{543                                    \textcolor{keywordtype}{unsigned} c, \textcolor{keywordtype}{char} sep) \{}
\DoxyCodeLine{544   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} digits =}
\DoxyCodeLine{545       a | (b << 24) | (static\_cast<unsigned long long>(c) << 48);}
\DoxyCodeLine{546   \textcolor{comment}{// Convert each value to BCD.}}
\DoxyCodeLine{547   \textcolor{comment}{// We have x = a * 10 + b and we want to convert it to BCD y = a * 16 + b.}}
\DoxyCodeLine{548   \textcolor{comment}{// The difference is}}
\DoxyCodeLine{549   \textcolor{comment}{//   y -\/ x = a * 6}}
\DoxyCodeLine{550   \textcolor{comment}{// a can be found from x:}}
\DoxyCodeLine{551   \textcolor{comment}{//   a = floor(x / 10)}}
\DoxyCodeLine{552   \textcolor{comment}{// then}}
\DoxyCodeLine{553   \textcolor{comment}{//   y = x + a * 6 = x + floor(x / 10) * 6}}
\DoxyCodeLine{554   \textcolor{comment}{// floor(x / 10) is (x * 205) >> 11 (needs 16 bits).}}
\DoxyCodeLine{555   digits += (((digits * 205) >> 11) \& 0x000f00000f00000f) * 6;}
\DoxyCodeLine{556   \textcolor{comment}{// Put low nibbles to high bytes and high nibbles to low bytes.}}
\DoxyCodeLine{557   digits = ((digits \& 0x00f00000f00000f0) >> 4) |}
\DoxyCodeLine{558            ((digits \& 0x000f00000f00000f) << 8);}
\DoxyCodeLine{559   \textcolor{keyword}{auto} usep = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(sep);}
\DoxyCodeLine{560   \textcolor{comment}{// Add ASCII '0' to each digit byte and insert separators.}}
\DoxyCodeLine{561   digits |= 0x3030003030003030 | (usep << 16) | (usep << 40);}
\DoxyCodeLine{562 }
\DoxyCodeLine{563   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} len = 8;}
\DoxyCodeLine{564   \textcolor{keywordflow}{if} (const\_check(is\_big\_endian())) \{}
\DoxyCodeLine{565     \textcolor{keywordtype}{char} tmp[len];}
\DoxyCodeLine{566     std::memcpy(tmp, \&digits, len);}
\DoxyCodeLine{567     std::reverse\_copy(tmp, tmp + len, buf);}
\DoxyCodeLine{568   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{569     std::memcpy(buf, \&digits, len);}
\DoxyCodeLine{570   \}}
\DoxyCodeLine{571 \}}
\DoxyCodeLine{572 }
\DoxyCodeLine{573 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Period> FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* get\_units() \{}
\DoxyCodeLine{574   \textcolor{keywordflow}{if} (std::is\_same<Period, std::atto>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}as"{}};}
\DoxyCodeLine{575   \textcolor{keywordflow}{if} (std::is\_same<Period, std::femto>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}fs"{}};}
\DoxyCodeLine{576   \textcolor{keywordflow}{if} (std::is\_same<Period, std::pico>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ps"{}};}
\DoxyCodeLine{577   \textcolor{keywordflow}{if} (std::is\_same<Period, std::nano>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ns"{}};}
\DoxyCodeLine{578   \textcolor{keywordflow}{if} (std::is\_same<Period, std::micro>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}µs"{}};}
\DoxyCodeLine{579   \textcolor{keywordflow}{if} (std::is\_same<Period, std::milli>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ms"{}};}
\DoxyCodeLine{580   \textcolor{keywordflow}{if} (std::is\_same<Period, std::centi>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}cs"{}};}
\DoxyCodeLine{581   \textcolor{keywordflow}{if} (std::is\_same<Period, std::deci>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ds"{}};}
\DoxyCodeLine{582   \textcolor{keywordflow}{if} (std::is\_same<Period, std::ratio<1>>\mbox{\hyperlink{classvalue}{::value}}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}s"{}};}
\DoxyCodeLine{583   \textcolor{keywordflow}{if} (std::is\_same<Period, std::deca>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}das"{}};}
\DoxyCodeLine{584   \textcolor{keywordflow}{if} (std::is\_same<Period, std::hecto>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}hs"{}};}
\DoxyCodeLine{585   \textcolor{keywordflow}{if} (std::is\_same<Period, std::kilo>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ks"{}};}
\DoxyCodeLine{586   \textcolor{keywordflow}{if} (std::is\_same<Period, std::mega>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Ms"{}};}
\DoxyCodeLine{587   \textcolor{keywordflow}{if} (std::is\_same<Period, std::giga>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Gs"{}};}
\DoxyCodeLine{588   \textcolor{keywordflow}{if} (std::is\_same<Period, std::tera>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Ts"{}};}
\DoxyCodeLine{589   \textcolor{keywordflow}{if} (std::is\_same<Period, std::peta>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Ps"{}};}
\DoxyCodeLine{590   \textcolor{keywordflow}{if} (std::is\_same<Period, std::exa>::value) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Es"{}};}
\DoxyCodeLine{591   \textcolor{keywordflow}{if} (std::is\_same<Period, std::ratio<60>>\mbox{\hyperlink{classvalue}{::value}}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}};}
\DoxyCodeLine{592   \textcolor{keywordflow}{if} (std::is\_same<Period, std::ratio<3600>>\mbox{\hyperlink{classvalue}{::value}}) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}h"{}};}
\DoxyCodeLine{593   \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{594 \}}
\DoxyCodeLine{595 }
\DoxyCodeLine{596 \textcolor{keyword}{enum class} numeric\_system \{}
\DoxyCodeLine{597   standard,}
\DoxyCodeLine{598   \textcolor{comment}{// Alternative numeric system, e.g. 十二 instead of 12 in ja\_JP locale.}}
\DoxyCodeLine{599   alternative}
\DoxyCodeLine{600 \};}
\DoxyCodeLine{601 }
\DoxyCodeLine{602 \textcolor{comment}{// Parses a put\_time-\/like format string and invokes handler actions.}}
\DoxyCodeLine{603 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{604 FMT\_CONSTEXPR \textcolor{keyword}{const} Char* parse\_chrono\_format(\textcolor{keyword}{const} Char* begin,}
\DoxyCodeLine{605                                               \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{606                                               Handler\&\& handler) \{}
\DoxyCodeLine{607   \textcolor{keyword}{auto} ptr = begin;}
\DoxyCodeLine{608   \textcolor{keywordflow}{while} (ptr != end) \{}
\DoxyCodeLine{609     \textcolor{keyword}{auto} c = *ptr;}
\DoxyCodeLine{610     \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{break};}
\DoxyCodeLine{611     \textcolor{keywordflow}{if} (c != \textcolor{charliteral}{'\%'}) \{}
\DoxyCodeLine{612       ++ptr;}
\DoxyCodeLine{613       \textcolor{keywordflow}{continue};}
\DoxyCodeLine{614     \}}
\DoxyCodeLine{615     \textcolor{keywordflow}{if} (begin != ptr) handler.on\_text(begin, ptr);}
\DoxyCodeLine{616     ++ptr;  \textcolor{comment}{// consume '\%'}}
\DoxyCodeLine{617     \textcolor{keywordflow}{if} (ptr == end) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format"{}}));}
\DoxyCodeLine{618     c = *ptr++;}
\DoxyCodeLine{619     \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{620     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\%'}:}
\DoxyCodeLine{621       handler.on\_text(ptr -\/ 1, ptr);}
\DoxyCodeLine{622       \textcolor{keywordflow}{break};}
\DoxyCodeLine{623     \textcolor{keywordflow}{case} \textcolor{charliteral}{'n'}: \{}
\DoxyCodeLine{624       \textcolor{keyword}{const} Char newline[] = \{\textcolor{charliteral}{'\(\backslash\)n'}\};}
\DoxyCodeLine{625       handler.on\_text(newline, newline + 1);}
\DoxyCodeLine{626       \textcolor{keywordflow}{break};}
\DoxyCodeLine{627     \}}
\DoxyCodeLine{628     \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'}: \{}
\DoxyCodeLine{629       \textcolor{keyword}{const} Char tab[] = \{\textcolor{charliteral}{'\(\backslash\)t'}\};}
\DoxyCodeLine{630       handler.on\_text(tab, tab + 1);}
\DoxyCodeLine{631       \textcolor{keywordflow}{break};}
\DoxyCodeLine{632     \}}
\DoxyCodeLine{633     \textcolor{comment}{// Year:}}
\DoxyCodeLine{634     \textcolor{keywordflow}{case} \textcolor{charliteral}{'Y'}:}
\DoxyCodeLine{635       handler.on\_year(numeric\_system::standard);}
\DoxyCodeLine{636       \textcolor{keywordflow}{break};}
\DoxyCodeLine{637     \textcolor{keywordflow}{case} \textcolor{charliteral}{'y'}:}
\DoxyCodeLine{638       handler.on\_short\_year(numeric\_system::standard);}
\DoxyCodeLine{639       \textcolor{keywordflow}{break};}
\DoxyCodeLine{640     \textcolor{keywordflow}{case} \textcolor{charliteral}{'C'}:}
\DoxyCodeLine{641       handler.on\_century(numeric\_system::standard);}
\DoxyCodeLine{642       \textcolor{keywordflow}{break};}
\DoxyCodeLine{643     \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:}
\DoxyCodeLine{644       handler.on\_iso\_week\_based\_year();}
\DoxyCodeLine{645       \textcolor{keywordflow}{break};}
\DoxyCodeLine{646     \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}:}
\DoxyCodeLine{647       handler.on\_iso\_week\_based\_short\_year();}
\DoxyCodeLine{648       \textcolor{keywordflow}{break};}
\DoxyCodeLine{649     \textcolor{comment}{// Day of the week:}}
\DoxyCodeLine{650     \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}:}
\DoxyCodeLine{651       handler.on\_abbr\_weekday();}
\DoxyCodeLine{652       \textcolor{keywordflow}{break};}
\DoxyCodeLine{653     \textcolor{keywordflow}{case} \textcolor{charliteral}{'A'}:}
\DoxyCodeLine{654       handler.on\_full\_weekday();}
\DoxyCodeLine{655       \textcolor{keywordflow}{break};}
\DoxyCodeLine{656     \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}:}
\DoxyCodeLine{657       handler.on\_dec0\_weekday(numeric\_system::standard);}
\DoxyCodeLine{658       \textcolor{keywordflow}{break};}
\DoxyCodeLine{659     \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{660       handler.on\_dec1\_weekday(numeric\_system::standard);}
\DoxyCodeLine{661       \textcolor{keywordflow}{break};}
\DoxyCodeLine{662     \textcolor{comment}{// Month:}}
\DoxyCodeLine{663     \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'}:}
\DoxyCodeLine{664     \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:}
\DoxyCodeLine{665       handler.on\_abbr\_month();}
\DoxyCodeLine{666       \textcolor{keywordflow}{break};}
\DoxyCodeLine{667     \textcolor{keywordflow}{case} \textcolor{charliteral}{'B'}:}
\DoxyCodeLine{668       handler.on\_full\_month();}
\DoxyCodeLine{669       \textcolor{keywordflow}{break};}
\DoxyCodeLine{670     \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{671       handler.on\_dec\_month(numeric\_system::standard);}
\DoxyCodeLine{672       \textcolor{keywordflow}{break};}
\DoxyCodeLine{673     \textcolor{comment}{// Day of the year/month:}}
\DoxyCodeLine{674     \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{675       handler.on\_dec0\_week\_of\_year(numeric\_system::standard);}
\DoxyCodeLine{676       \textcolor{keywordflow}{break};}
\DoxyCodeLine{677     \textcolor{keywordflow}{case} \textcolor{charliteral}{'W'}:}
\DoxyCodeLine{678       handler.on\_dec1\_week\_of\_year(numeric\_system::standard);}
\DoxyCodeLine{679       \textcolor{keywordflow}{break};}
\DoxyCodeLine{680     \textcolor{keywordflow}{case} \textcolor{charliteral}{'V'}:}
\DoxyCodeLine{681       handler.on\_iso\_week\_of\_year(numeric\_system::standard);}
\DoxyCodeLine{682       \textcolor{keywordflow}{break};}
\DoxyCodeLine{683     \textcolor{keywordflow}{case} \textcolor{charliteral}{'j'}:}
\DoxyCodeLine{684       handler.on\_day\_of\_year();}
\DoxyCodeLine{685       \textcolor{keywordflow}{break};}
\DoxyCodeLine{686     \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{687       handler.on\_day\_of\_month(numeric\_system::standard);}
\DoxyCodeLine{688       \textcolor{keywordflow}{break};}
\DoxyCodeLine{689     \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{690       handler.on\_day\_of\_month\_space(numeric\_system::standard);}
\DoxyCodeLine{691       \textcolor{keywordflow}{break};}
\DoxyCodeLine{692     \textcolor{comment}{// Hour, minute, second:}}
\DoxyCodeLine{693     \textcolor{keywordflow}{case} \textcolor{charliteral}{'H'}:}
\DoxyCodeLine{694       handler.on\_24\_hour(numeric\_system::standard);}
\DoxyCodeLine{695       \textcolor{keywordflow}{break};}
\DoxyCodeLine{696     \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{697       handler.on\_12\_hour(numeric\_system::standard);}
\DoxyCodeLine{698       \textcolor{keywordflow}{break};}
\DoxyCodeLine{699     \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{700       handler.on\_minute(numeric\_system::standard);}
\DoxyCodeLine{701       \textcolor{keywordflow}{break};}
\DoxyCodeLine{702     \textcolor{keywordflow}{case} \textcolor{charliteral}{'S'}:}
\DoxyCodeLine{703       handler.on\_second(numeric\_system::standard);}
\DoxyCodeLine{704       \textcolor{keywordflow}{break};}
\DoxyCodeLine{705     \textcolor{comment}{// Other:}}
\DoxyCodeLine{706     \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}:}
\DoxyCodeLine{707       handler.on\_datetime(numeric\_system::standard);}
\DoxyCodeLine{708       \textcolor{keywordflow}{break};}
\DoxyCodeLine{709     \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}:}
\DoxyCodeLine{710       handler.on\_loc\_date(numeric\_system::standard);}
\DoxyCodeLine{711       \textcolor{keywordflow}{break};}
\DoxyCodeLine{712     \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}:}
\DoxyCodeLine{713       handler.on\_loc\_time(numeric\_system::standard);}
\DoxyCodeLine{714       \textcolor{keywordflow}{break};}
\DoxyCodeLine{715     \textcolor{keywordflow}{case} \textcolor{charliteral}{'D'}:}
\DoxyCodeLine{716       handler.on\_us\_date();}
\DoxyCodeLine{717       \textcolor{keywordflow}{break};}
\DoxyCodeLine{718     \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:}
\DoxyCodeLine{719       handler.on\_iso\_date();}
\DoxyCodeLine{720       \textcolor{keywordflow}{break};}
\DoxyCodeLine{721     \textcolor{keywordflow}{case} \textcolor{charliteral}{'r'}:}
\DoxyCodeLine{722       handler.on\_12\_hour\_time();}
\DoxyCodeLine{723       \textcolor{keywordflow}{break};}
\DoxyCodeLine{724     \textcolor{keywordflow}{case} \textcolor{charliteral}{'R'}:}
\DoxyCodeLine{725       handler.on\_24\_hour\_time();}
\DoxyCodeLine{726       \textcolor{keywordflow}{break};}
\DoxyCodeLine{727     \textcolor{keywordflow}{case} \textcolor{charliteral}{'T'}:}
\DoxyCodeLine{728       handler.on\_iso\_time();}
\DoxyCodeLine{729       \textcolor{keywordflow}{break};}
\DoxyCodeLine{730     \textcolor{keywordflow}{case} \textcolor{charliteral}{'p'}:}
\DoxyCodeLine{731       handler.on\_am\_pm();}
\DoxyCodeLine{732       \textcolor{keywordflow}{break};}
\DoxyCodeLine{733     \textcolor{keywordflow}{case} \textcolor{charliteral}{'Q'}:}
\DoxyCodeLine{734       handler.on\_duration\_value();}
\DoxyCodeLine{735       \textcolor{keywordflow}{break};}
\DoxyCodeLine{736     \textcolor{keywordflow}{case} \textcolor{charliteral}{'q'}:}
\DoxyCodeLine{737       handler.on\_duration\_unit();}
\DoxyCodeLine{738       \textcolor{keywordflow}{break};}
\DoxyCodeLine{739     \textcolor{keywordflow}{case} \textcolor{charliteral}{'z'}:}
\DoxyCodeLine{740       handler.on\_utc\_offset();}
\DoxyCodeLine{741       \textcolor{keywordflow}{break};}
\DoxyCodeLine{742     \textcolor{keywordflow}{case} \textcolor{charliteral}{'Z'}:}
\DoxyCodeLine{743       handler.on\_tz\_name();}
\DoxyCodeLine{744       \textcolor{keywordflow}{break};}
\DoxyCodeLine{745     \textcolor{comment}{// Alternative representation:}}
\DoxyCodeLine{746     \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}: \{}
\DoxyCodeLine{747       \textcolor{keywordflow}{if} (ptr == end) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format"{}}));}
\DoxyCodeLine{748       c = *ptr++;}
\DoxyCodeLine{749       \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{750       \textcolor{keywordflow}{case} \textcolor{charliteral}{'Y'}:}
\DoxyCodeLine{751         handler.on\_year(numeric\_system::alternative);}
\DoxyCodeLine{752         \textcolor{keywordflow}{break};}
\DoxyCodeLine{753       \textcolor{keywordflow}{case} \textcolor{charliteral}{'y'}:}
\DoxyCodeLine{754         handler.on\_offset\_year();}
\DoxyCodeLine{755         \textcolor{keywordflow}{break};}
\DoxyCodeLine{756       \textcolor{keywordflow}{case} \textcolor{charliteral}{'C'}:}
\DoxyCodeLine{757         handler.on\_century(numeric\_system::alternative);}
\DoxyCodeLine{758         \textcolor{keywordflow}{break};}
\DoxyCodeLine{759       \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}:}
\DoxyCodeLine{760         handler.on\_datetime(numeric\_system::alternative);}
\DoxyCodeLine{761         \textcolor{keywordflow}{break};}
\DoxyCodeLine{762       \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}:}
\DoxyCodeLine{763         handler.on\_loc\_date(numeric\_system::alternative);}
\DoxyCodeLine{764         \textcolor{keywordflow}{break};}
\DoxyCodeLine{765       \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}:}
\DoxyCodeLine{766         handler.on\_loc\_time(numeric\_system::alternative);}
\DoxyCodeLine{767         \textcolor{keywordflow}{break};}
\DoxyCodeLine{768       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{769         FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format"{}}));}
\DoxyCodeLine{770       \}}
\DoxyCodeLine{771       \textcolor{keywordflow}{break};}
\DoxyCodeLine{772     \}}
\DoxyCodeLine{773     \textcolor{keywordflow}{case} \textcolor{charliteral}{'O'}:}
\DoxyCodeLine{774       \textcolor{keywordflow}{if} (ptr == end) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format"{}}));}
\DoxyCodeLine{775       c = *ptr++;}
\DoxyCodeLine{776       \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{777       \textcolor{keywordflow}{case} \textcolor{charliteral}{'y'}:}
\DoxyCodeLine{778         handler.on\_short\_year(numeric\_system::alternative);}
\DoxyCodeLine{779         \textcolor{keywordflow}{break};}
\DoxyCodeLine{780       \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{781         handler.on\_dec\_month(numeric\_system::alternative);}
\DoxyCodeLine{782         \textcolor{keywordflow}{break};}
\DoxyCodeLine{783       \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{784         handler.on\_dec0\_week\_of\_year(numeric\_system::alternative);}
\DoxyCodeLine{785         \textcolor{keywordflow}{break};}
\DoxyCodeLine{786       \textcolor{keywordflow}{case} \textcolor{charliteral}{'W'}:}
\DoxyCodeLine{787         handler.on\_dec1\_week\_of\_year(numeric\_system::alternative);}
\DoxyCodeLine{788         \textcolor{keywordflow}{break};}
\DoxyCodeLine{789       \textcolor{keywordflow}{case} \textcolor{charliteral}{'V'}:}
\DoxyCodeLine{790         handler.on\_iso\_week\_of\_year(numeric\_system::alternative);}
\DoxyCodeLine{791         \textcolor{keywordflow}{break};}
\DoxyCodeLine{792       \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{793         handler.on\_day\_of\_month(numeric\_system::alternative);}
\DoxyCodeLine{794         \textcolor{keywordflow}{break};}
\DoxyCodeLine{795       \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{796         handler.on\_day\_of\_month\_space(numeric\_system::alternative);}
\DoxyCodeLine{797         \textcolor{keywordflow}{break};}
\DoxyCodeLine{798       \textcolor{keywordflow}{case} \textcolor{charliteral}{'w'}:}
\DoxyCodeLine{799         handler.on\_dec0\_weekday(numeric\_system::alternative);}
\DoxyCodeLine{800         \textcolor{keywordflow}{break};}
\DoxyCodeLine{801       \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{802         handler.on\_dec1\_weekday(numeric\_system::alternative);}
\DoxyCodeLine{803         \textcolor{keywordflow}{break};}
\DoxyCodeLine{804       \textcolor{keywordflow}{case} \textcolor{charliteral}{'H'}:}
\DoxyCodeLine{805         handler.on\_24\_hour(numeric\_system::alternative);}
\DoxyCodeLine{806         \textcolor{keywordflow}{break};}
\DoxyCodeLine{807       \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{808         handler.on\_12\_hour(numeric\_system::alternative);}
\DoxyCodeLine{809         \textcolor{keywordflow}{break};}
\DoxyCodeLine{810       \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{811         handler.on\_minute(numeric\_system::alternative);}
\DoxyCodeLine{812         \textcolor{keywordflow}{break};}
\DoxyCodeLine{813       \textcolor{keywordflow}{case} \textcolor{charliteral}{'S'}:}
\DoxyCodeLine{814         handler.on\_second(numeric\_system::alternative);}
\DoxyCodeLine{815         \textcolor{keywordflow}{break};}
\DoxyCodeLine{816       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{817         FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format"{}}));}
\DoxyCodeLine{818       \}}
\DoxyCodeLine{819       \textcolor{keywordflow}{break};}
\DoxyCodeLine{820     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{821       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format"{}}));}
\DoxyCodeLine{822     \}}
\DoxyCodeLine{823     begin = ptr;}
\DoxyCodeLine{824   \}}
\DoxyCodeLine{825   \textcolor{keywordflow}{if} (begin != ptr) handler.on\_text(begin, ptr);}
\DoxyCodeLine{826   \textcolor{keywordflow}{return} ptr;}
\DoxyCodeLine{827 \}}
\DoxyCodeLine{828 }
\DoxyCodeLine{829 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived> \textcolor{keyword}{struct }\mbox{\hyperlink{structnull__chrono__spec__handler}{null\_chrono\_spec\_handler}} \{}
\DoxyCodeLine{830   FMT\_CONSTEXPR \textcolor{keywordtype}{void} unsupported() \{}
\DoxyCodeLine{831     \textcolor{keyword}{static\_cast<}Derived*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>unsupported();}
\DoxyCodeLine{832   \}}
\DoxyCodeLine{833   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_year(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{834   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_short\_year(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{835   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_offset\_year() \{ unsupported(); \}}
\DoxyCodeLine{836   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_century(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{837   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_week\_based\_year() \{ unsupported(); \}}
\DoxyCodeLine{838   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_week\_based\_short\_year() \{ unsupported(); \}}
\DoxyCodeLine{839   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_abbr\_weekday() \{ unsupported(); \}}
\DoxyCodeLine{840   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_full\_weekday() \{ unsupported(); \}}
\DoxyCodeLine{841   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec0\_weekday(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{842   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec1\_weekday(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{843   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_abbr\_month() \{ unsupported(); \}}
\DoxyCodeLine{844   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_full\_month() \{ unsupported(); \}}
\DoxyCodeLine{845   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec\_month(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{846   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec0\_week\_of\_year(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{847   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec1\_week\_of\_year(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{848   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_week\_of\_year(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{849   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_day\_of\_year() \{ unsupported(); \}}
\DoxyCodeLine{850   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_day\_of\_month(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{851   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_day\_of\_month\_space(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{852   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_24\_hour(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{853   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_12\_hour(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{854   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_minute(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{855   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_second(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{856   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_datetime(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{857   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_loc\_date(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{858   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_loc\_time(numeric\_system) \{ unsupported(); \}}
\DoxyCodeLine{859   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_us\_date() \{ unsupported(); \}}
\DoxyCodeLine{860   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_date() \{ unsupported(); \}}
\DoxyCodeLine{861   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_12\_hour\_time() \{ unsupported(); \}}
\DoxyCodeLine{862   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_24\_hour\_time() \{ unsupported(); \}}
\DoxyCodeLine{863   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_time() \{ unsupported(); \}}
\DoxyCodeLine{864   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_am\_pm() \{ unsupported(); \}}
\DoxyCodeLine{865   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_duration\_value() \{ unsupported(); \}}
\DoxyCodeLine{866   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_duration\_unit() \{ unsupported(); \}}
\DoxyCodeLine{867   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_utc\_offset() \{ unsupported(); \}}
\DoxyCodeLine{868   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_tz\_name() \{ unsupported(); \}}
\DoxyCodeLine{869 \};}
\DoxyCodeLine{870 }
\DoxyCodeLine{871 \textcolor{keyword}{struct }\mbox{\hyperlink{structtm__format__checker}{tm\_format\_checker}} : \mbox{\hyperlink{structnull__chrono__spec__handler}{null\_chrono\_spec\_handler}}<tm\_format\_checker> \{}
\DoxyCodeLine{872   FMT\_NORETURN \textcolor{keywordtype}{void} unsupported() \{ FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}no format"{}})); \}}
\DoxyCodeLine{873 }
\DoxyCodeLine{874   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{875   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char*, \textcolor{keyword}{const} Char*) \{\}}
\DoxyCodeLine{876   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_year(numeric\_system) \{\}}
\DoxyCodeLine{877   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_short\_year(numeric\_system) \{\}}
\DoxyCodeLine{878   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_offset\_year() \{\}}
\DoxyCodeLine{879   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_century(numeric\_system) \{\}}
\DoxyCodeLine{880   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_week\_based\_year() \{\}}
\DoxyCodeLine{881   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_week\_based\_short\_year() \{\}}
\DoxyCodeLine{882   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_abbr\_weekday() \{\}}
\DoxyCodeLine{883   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_full\_weekday() \{\}}
\DoxyCodeLine{884   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec0\_weekday(numeric\_system) \{\}}
\DoxyCodeLine{885   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec1\_weekday(numeric\_system) \{\}}
\DoxyCodeLine{886   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_abbr\_month() \{\}}
\DoxyCodeLine{887   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_full\_month() \{\}}
\DoxyCodeLine{888   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec\_month(numeric\_system) \{\}}
\DoxyCodeLine{889   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec0\_week\_of\_year(numeric\_system) \{\}}
\DoxyCodeLine{890   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec1\_week\_of\_year(numeric\_system) \{\}}
\DoxyCodeLine{891   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_week\_of\_year(numeric\_system) \{\}}
\DoxyCodeLine{892   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_day\_of\_year() \{\}}
\DoxyCodeLine{893   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_day\_of\_month(numeric\_system) \{\}}
\DoxyCodeLine{894   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_day\_of\_month\_space(numeric\_system) \{\}}
\DoxyCodeLine{895   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_24\_hour(numeric\_system) \{\}}
\DoxyCodeLine{896   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_12\_hour(numeric\_system) \{\}}
\DoxyCodeLine{897   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_minute(numeric\_system) \{\}}
\DoxyCodeLine{898   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_second(numeric\_system) \{\}}
\DoxyCodeLine{899   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_datetime(numeric\_system) \{\}}
\DoxyCodeLine{900   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_loc\_date(numeric\_system) \{\}}
\DoxyCodeLine{901   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_loc\_time(numeric\_system) \{\}}
\DoxyCodeLine{902   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_us\_date() \{\}}
\DoxyCodeLine{903   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_date() \{\}}
\DoxyCodeLine{904   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_12\_hour\_time() \{\}}
\DoxyCodeLine{905   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_24\_hour\_time() \{\}}
\DoxyCodeLine{906   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_time() \{\}}
\DoxyCodeLine{907   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_am\_pm() \{\}}
\DoxyCodeLine{908   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_utc\_offset() \{\}}
\DoxyCodeLine{909   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_tz\_name() \{\}}
\DoxyCodeLine{910 \};}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* tm\_wday\_full\_name(\textcolor{keywordtype}{int} wday) \{}
\DoxyCodeLine{913   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* full\_name\_list[] = \{}
\DoxyCodeLine{914       \textcolor{stringliteral}{"{}Sunday"{}},   \textcolor{stringliteral}{"{}Monday"{}}, \textcolor{stringliteral}{"{}Tuesday"{}}, \textcolor{stringliteral}{"{}Wednesday"{}},}
\DoxyCodeLine{915       \textcolor{stringliteral}{"{}Thursday"{}}, \textcolor{stringliteral}{"{}Friday"{}}, \textcolor{stringliteral}{"{}Saturday"{}}\};}
\DoxyCodeLine{916   \textcolor{keywordflow}{return} wday >= 0 \&\& wday <= 6 ? full\_name\_list[wday] : \textcolor{stringliteral}{"{}?"{}};}
\DoxyCodeLine{917 \}}
\DoxyCodeLine{918 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* tm\_wday\_short\_name(\textcolor{keywordtype}{int} wday) \{}
\DoxyCodeLine{919   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* short\_name\_list[] = \{\textcolor{stringliteral}{"{}Sun"{}}, \textcolor{stringliteral}{"{}Mon"{}}, \textcolor{stringliteral}{"{}Tue"{}}, \textcolor{stringliteral}{"{}Wed"{}},}
\DoxyCodeLine{920                                                     \textcolor{stringliteral}{"{}Thu"{}}, \textcolor{stringliteral}{"{}Fri"{}}, \textcolor{stringliteral}{"{}Sat"{}}\};}
\DoxyCodeLine{921   \textcolor{keywordflow}{return} wday >= 0 \&\& wday <= 6 ? short\_name\_list[wday] : \textcolor{stringliteral}{"{}???"{}};}
\DoxyCodeLine{922 \}}
\DoxyCodeLine{923 }
\DoxyCodeLine{924 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* tm\_mon\_full\_name(\textcolor{keywordtype}{int} mon) \{}
\DoxyCodeLine{925   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* full\_name\_list[] = \{}
\DoxyCodeLine{926       \textcolor{stringliteral}{"{}January"{}}, \textcolor{stringliteral}{"{}February"{}}, \textcolor{stringliteral}{"{}March"{}},     \textcolor{stringliteral}{"{}April"{}},   \textcolor{stringliteral}{"{}May"{}},      \textcolor{stringliteral}{"{}June"{}},}
\DoxyCodeLine{927       \textcolor{stringliteral}{"{}July"{}},    \textcolor{stringliteral}{"{}August"{}},   \textcolor{stringliteral}{"{}September"{}}, \textcolor{stringliteral}{"{}October"{}}, \textcolor{stringliteral}{"{}November"{}}, \textcolor{stringliteral}{"{}December"{}}\};}
\DoxyCodeLine{928   \textcolor{keywordflow}{return} mon >= 0 \&\& mon <= 11 ? full\_name\_list[mon] : \textcolor{stringliteral}{"{}?"{}};}
\DoxyCodeLine{929 \}}
\DoxyCodeLine{930 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* tm\_mon\_short\_name(\textcolor{keywordtype}{int} mon) \{}
\DoxyCodeLine{931   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* short\_name\_list[] = \{}
\DoxyCodeLine{932       \textcolor{stringliteral}{"{}Jan"{}}, \textcolor{stringliteral}{"{}Feb"{}}, \textcolor{stringliteral}{"{}Mar"{}}, \textcolor{stringliteral}{"{}Apr"{}}, \textcolor{stringliteral}{"{}May"{}}, \textcolor{stringliteral}{"{}Jun"{}},}
\DoxyCodeLine{933       \textcolor{stringliteral}{"{}Jul"{}}, \textcolor{stringliteral}{"{}Aug"{}}, \textcolor{stringliteral}{"{}Sep"{}}, \textcolor{stringliteral}{"{}Oct"{}}, \textcolor{stringliteral}{"{}Nov"{}}, \textcolor{stringliteral}{"{}Dec"{}},}
\DoxyCodeLine{934   \};}
\DoxyCodeLine{935   \textcolor{keywordflow}{return} mon >= 0 \&\& mon <= 11 ? short\_name\_list[mon] : \textcolor{stringliteral}{"{}???"{}};}
\DoxyCodeLine{936 \}}
\DoxyCodeLine{937 }
\DoxyCodeLine{938 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{939 \textcolor{keyword}{struct }\mbox{\hyperlink{structhas__member__data__tm__gmtoff}{has\_member\_data\_tm\_gmtoff}} : std::false\_type \{\};}
\DoxyCodeLine{940 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{941 \textcolor{keyword}{struct }\mbox{\hyperlink{structhas__member__data__tm__gmtoff}{has\_member\_data\_tm\_gmtoff}}<T, void\_t<decltype(T::tm\_gmtoff)>>}
\DoxyCodeLine{942     : std::true\_type \{\};}
\DoxyCodeLine{943 }
\DoxyCodeLine{944 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{945 \textcolor{keyword}{struct }\mbox{\hyperlink{structhas__member__data__tm__zone}{has\_member\_data\_tm\_zone}} : std::false\_type \{\};}
\DoxyCodeLine{946 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{947 \textcolor{keyword}{struct }\mbox{\hyperlink{structhas__member__data__tm__zone}{has\_member\_data\_tm\_zone}}<T, void\_t<decltype(T::tm\_zone)>>}
\DoxyCodeLine{948     : std::true\_type \{\};}
\DoxyCodeLine{949 }
\DoxyCodeLine{950 \textcolor{preprocessor}{\#if FMT\_USE\_TZSET}}
\DoxyCodeLine{951 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} tzset\_once() \{}
\DoxyCodeLine{952   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} init = []() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{953     \_tzset();}
\DoxyCodeLine{954     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{955   \}();}
\DoxyCodeLine{956   ignore\_unused(init);}
\DoxyCodeLine{957 \}}
\DoxyCodeLine{958 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{959 }
\DoxyCodeLine{960 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classtm__writer}{tm\_writer}} \{}
\DoxyCodeLine{961  \textcolor{keyword}{private}:}
\DoxyCodeLine{962   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} days\_per\_week = 7;}
\DoxyCodeLine{963 }
\DoxyCodeLine{964   \textcolor{keyword}{const} std::locale\& loc\_;}
\DoxyCodeLine{965   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_classic\_;}
\DoxyCodeLine{966   OutputIt out\_;}
\DoxyCodeLine{967   \textcolor{keyword}{const} std::tm\& tm\_;}
\DoxyCodeLine{968 }
\DoxyCodeLine{969   \textcolor{keyword}{auto} tm\_sec() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{970     FMT\_ASSERT(tm\_.tm\_sec >= 0 \&\& tm\_.tm\_sec <= 61, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{971     \textcolor{keywordflow}{return} tm\_.tm\_sec;}
\DoxyCodeLine{972   \}}
\DoxyCodeLine{973   \textcolor{keyword}{auto} tm\_min() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{974     FMT\_ASSERT(tm\_.tm\_min >= 0 \&\& tm\_.tm\_min <= 59, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{975     \textcolor{keywordflow}{return} tm\_.tm\_min;}
\DoxyCodeLine{976   \}}
\DoxyCodeLine{977   \textcolor{keyword}{auto} tm\_hour() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{978     FMT\_ASSERT(tm\_.tm\_hour >= 0 \&\& tm\_.tm\_hour <= 23, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{979     \textcolor{keywordflow}{return} tm\_.tm\_hour;}
\DoxyCodeLine{980   \}}
\DoxyCodeLine{981   \textcolor{keyword}{auto} tm\_mday() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{982     FMT\_ASSERT(tm\_.tm\_mday >= 1 \&\& tm\_.tm\_mday <= 31, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{983     \textcolor{keywordflow}{return} tm\_.tm\_mday;}
\DoxyCodeLine{984   \}}
\DoxyCodeLine{985   \textcolor{keyword}{auto} tm\_mon() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{986     FMT\_ASSERT(tm\_.tm\_mon >= 0 \&\& tm\_.tm\_mon <= 11, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{987     \textcolor{keywordflow}{return} tm\_.tm\_mon;}
\DoxyCodeLine{988   \}}
\DoxyCodeLine{989   \textcolor{keyword}{auto} tm\_year() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ \textcolor{keywordflow}{return} 1900ll + tm\_.tm\_year; \}}
\DoxyCodeLine{990   \textcolor{keyword}{auto} tm\_wday() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{991     FMT\_ASSERT(tm\_.tm\_wday >= 0 \&\& tm\_.tm\_wday <= 6, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{992     \textcolor{keywordflow}{return} tm\_.tm\_wday;}
\DoxyCodeLine{993   \}}
\DoxyCodeLine{994   \textcolor{keyword}{auto} tm\_yday() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{995     FMT\_ASSERT(tm\_.tm\_yday >= 0 \&\& tm\_.tm\_yday <= 365, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{996     \textcolor{keywordflow}{return} tm\_.tm\_yday;}
\DoxyCodeLine{997   \}}
\DoxyCodeLine{998 }
\DoxyCodeLine{999   \textcolor{keyword}{auto} tm\_hour12() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1000     \textcolor{keyword}{const} \textcolor{keyword}{auto} h = tm\_hour();}
\DoxyCodeLine{1001     \textcolor{keyword}{const} \textcolor{keyword}{auto} z = h < 12 ? h : h -\/ 12;}
\DoxyCodeLine{1002     \textcolor{keywordflow}{return} z == 0 ? 12 : z;}
\DoxyCodeLine{1003   \}}
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005   \textcolor{comment}{// POSIX and the C Standard are unclear or inconsistent about what \%C and \%y}}
\DoxyCodeLine{1006   \textcolor{comment}{// do if the year is negative or exceeds 9999. Use the convention that \%C}}
\DoxyCodeLine{1007   \textcolor{comment}{// concatenated with \%y yields the same output as \%Y, and that \%Y contains at}}
\DoxyCodeLine{1008   \textcolor{comment}{// least 4 characters, with more only if necessary.}}
\DoxyCodeLine{1009   \textcolor{keyword}{auto} split\_year\_lower(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} year) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1010     \textcolor{keyword}{auto} l = year \% 100;}
\DoxyCodeLine{1011     \textcolor{keywordflow}{if} (l < 0) l = -\/l;  \textcolor{comment}{// l in [0, 99]}}
\DoxyCodeLine{1012     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(l);}
\DoxyCodeLine{1013   \}}
\DoxyCodeLine{1014 }
\DoxyCodeLine{1015   \textcolor{comment}{// Algorithm:}}
\DoxyCodeLine{1016   \textcolor{comment}{// https://en.wikipedia.org/wiki/ISO\_week\_date\#Calculating\_the\_week\_number\_from\_a\_month\_and\_day\_of\_the\_month\_or\_ordinal\_date}}
\DoxyCodeLine{1017   \textcolor{keyword}{auto} iso\_year\_weeks(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} curr\_year) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1018     \textcolor{keyword}{const} \textcolor{keyword}{auto} prev\_year = curr\_year -\/ 1;}
\DoxyCodeLine{1019     \textcolor{keyword}{const} \textcolor{keyword}{auto} curr\_p =}
\DoxyCodeLine{1020         (curr\_year + curr\_year / 4 -\/ curr\_year / 100 + curr\_year / 400) \%}
\DoxyCodeLine{1021         days\_per\_week;}
\DoxyCodeLine{1022     \textcolor{keyword}{const} \textcolor{keyword}{auto} prev\_p =}
\DoxyCodeLine{1023         (prev\_year + prev\_year / 4 -\/ prev\_year / 100 + prev\_year / 400) \%}
\DoxyCodeLine{1024         days\_per\_week;}
\DoxyCodeLine{1025     \textcolor{keywordflow}{return} 52 + ((curr\_p == 4 || prev\_p == 3) ? 1 : 0);}
\DoxyCodeLine{1026   \}}
\DoxyCodeLine{1027   \textcolor{keyword}{auto} iso\_week\_num(\textcolor{keywordtype}{int} tm\_yday, \textcolor{keywordtype}{int} tm\_wday) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1028     \textcolor{keywordflow}{return} (tm\_yday + 11 -\/ (tm\_wday == 0 ? days\_per\_week : tm\_wday)) /}
\DoxyCodeLine{1029            days\_per\_week;}
\DoxyCodeLine{1030   \}}
\DoxyCodeLine{1031   \textcolor{keyword}{auto} tm\_iso\_week\_year() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1032     \textcolor{keyword}{const} \textcolor{keyword}{auto} year = tm\_year();}
\DoxyCodeLine{1033     \textcolor{keyword}{const} \textcolor{keyword}{auto} w = iso\_week\_num(tm\_yday(), tm\_wday());}
\DoxyCodeLine{1034     \textcolor{keywordflow}{if} (w < 1) \textcolor{keywordflow}{return} year -\/ 1;}
\DoxyCodeLine{1035     \textcolor{keywordflow}{if} (w > iso\_year\_weeks(year)) \textcolor{keywordflow}{return} year + 1;}
\DoxyCodeLine{1036     \textcolor{keywordflow}{return} year;}
\DoxyCodeLine{1037   \}}
\DoxyCodeLine{1038   \textcolor{keyword}{auto} tm\_iso\_week\_of\_year() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1039     \textcolor{keyword}{const} \textcolor{keyword}{auto} year = tm\_year();}
\DoxyCodeLine{1040     \textcolor{keyword}{const} \textcolor{keyword}{auto} w = iso\_week\_num(tm\_yday(), tm\_wday());}
\DoxyCodeLine{1041     \textcolor{keywordflow}{if} (w < 1) \textcolor{keywordflow}{return} iso\_year\_weeks(year -\/ 1);}
\DoxyCodeLine{1042     \textcolor{keywordflow}{if} (w > iso\_year\_weeks(year)) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{1043     \textcolor{keywordflow}{return} w;}
\DoxyCodeLine{1044   \}}
\DoxyCodeLine{1045 }
\DoxyCodeLine{1046   \textcolor{keywordtype}{void} write1(\textcolor{keywordtype}{int} \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{1047     *out\_++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + to\_unsigned(\mbox{\hyperlink{classvalue}{value}}) \% 10);}
\DoxyCodeLine{1048   \}}
\DoxyCodeLine{1049   \textcolor{keywordtype}{void} write2(\textcolor{keywordtype}{int} \mbox{\hyperlink{classvalue}{value}}) \{}
\DoxyCodeLine{1050     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* d = digits2(to\_unsigned(\mbox{\hyperlink{classvalue}{value}}) \% 100);}
\DoxyCodeLine{1051     *out\_++ = *d++;}
\DoxyCodeLine{1052     *out\_++ = *d;}
\DoxyCodeLine{1053   \}}
\DoxyCodeLine{1054 }
\DoxyCodeLine{1055   \textcolor{keywordtype}{void} write\_year\_extended(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} year) \{}
\DoxyCodeLine{1056     \textcolor{comment}{// At least 4 characters.}}
\DoxyCodeLine{1057     \textcolor{keywordtype}{int} width = 4;}
\DoxyCodeLine{1058     \textcolor{keywordflow}{if} (year < 0) \{}
\DoxyCodeLine{1059       *out\_++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{1060       year = 0 -\/ year;}
\DoxyCodeLine{1061       -\/-\/width;}
\DoxyCodeLine{1062     \}}
\DoxyCodeLine{1063     uint32\_or\_64\_or\_128\_t<long long> n = to\_unsigned(year);}
\DoxyCodeLine{1064     \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_digits = count\_digits(n);}
\DoxyCodeLine{1065     \textcolor{keywordflow}{if} (width > num\_digits) out\_ = std::fill\_n(out\_, width -\/ num\_digits, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{1066     out\_ = format\_decimal<Char>(out\_, n, num\_digits).end;}
\DoxyCodeLine{1067   \}}
\DoxyCodeLine{1068   \textcolor{keywordtype}{void} write\_year(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} year) \{}
\DoxyCodeLine{1069     \textcolor{keywordflow}{if} (year >= 0 \&\& year < 10000) \{}
\DoxyCodeLine{1070       write2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(year / 100));}
\DoxyCodeLine{1071       write2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(year \% 100));}
\DoxyCodeLine{1072     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1073       write\_year\_extended(year);}
\DoxyCodeLine{1074     \}}
\DoxyCodeLine{1075   \}}
\DoxyCodeLine{1076 }
\DoxyCodeLine{1077   \textcolor{keywordtype}{void} write\_utc\_offset(\textcolor{keywordtype}{long} offset) \{}
\DoxyCodeLine{1078     \textcolor{keywordflow}{if} (offset < 0) \{}
\DoxyCodeLine{1079       *out\_++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{1080       offset = -\/offset;}
\DoxyCodeLine{1081     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1082       *out\_++ = \textcolor{charliteral}{'+'};}
\DoxyCodeLine{1083     \}}
\DoxyCodeLine{1084     offset /= 60;}
\DoxyCodeLine{1085     write2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(offset / 60));}
\DoxyCodeLine{1086     write2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(offset \% 60));}
\DoxyCodeLine{1087   \}}
\DoxyCodeLine{1088   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(has\_member\_data\_tm\_gmtoff<T>::value)>}
\DoxyCodeLine{1089   \textcolor{keywordtype}{void} format\_utc\_offset\_impl(\textcolor{keyword}{const} T\& tm) \{}
\DoxyCodeLine{1090     write\_utc\_offset(tm.tm\_gmtoff);}
\DoxyCodeLine{1091   \}}
\DoxyCodeLine{1092   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!has\_member\_data\_tm\_gmtoff<T>::value)>}
\DoxyCodeLine{1093   \textcolor{keywordtype}{void} format\_utc\_offset\_impl(\textcolor{keyword}{const} T\& tm) \{}
\DoxyCodeLine{1094 \textcolor{preprocessor}{\#if defined(\_WIN32) \&\& defined(\_UCRT)}}
\DoxyCodeLine{1095 \textcolor{preprocessor}{\#  if FMT\_USE\_TZSET}}
\DoxyCodeLine{1096     tzset\_once();}
\DoxyCodeLine{1097 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{1098     \textcolor{keywordtype}{long} offset = 0;}
\DoxyCodeLine{1099     \_get\_timezone(\&offset);}
\DoxyCodeLine{1100     \textcolor{keywordflow}{if} (tm.tm\_isdst) \{}
\DoxyCodeLine{1101       \textcolor{keywordtype}{long} dstbias = 0;}
\DoxyCodeLine{1102       \_get\_dstbias(\&dstbias);}
\DoxyCodeLine{1103       offset += dstbias;}
\DoxyCodeLine{1104     \}}
\DoxyCodeLine{1105     write\_utc\_offset(-\/offset);}
\DoxyCodeLine{1106 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1107     ignore\_unused(tm);}
\DoxyCodeLine{1108     format\_localized(\textcolor{charliteral}{'z'});}
\DoxyCodeLine{1109 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1110   \}}
\DoxyCodeLine{1111 }
\DoxyCodeLine{1112   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(has\_member\_data\_tm\_zone<T>::value)>}
\DoxyCodeLine{1113   \textcolor{keywordtype}{void} format\_tz\_name\_impl(\textcolor{keyword}{const} T\& tm) \{}
\DoxyCodeLine{1114     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1115       out\_ = write\_tm\_str<Char>(out\_, tm.tm\_zone, loc\_);}
\DoxyCodeLine{1116     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1117       format\_localized(\textcolor{charliteral}{'Z'});}
\DoxyCodeLine{1118   \}}
\DoxyCodeLine{1119   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!has\_member\_data\_tm\_zone<T>::value)>}
\DoxyCodeLine{1120   \textcolor{keywordtype}{void} format\_tz\_name\_impl(\textcolor{keyword}{const} T\&) \{}
\DoxyCodeLine{1121     format\_localized(\textcolor{charliteral}{'Z'});}
\DoxyCodeLine{1122   \}}
\DoxyCodeLine{1123 }
\DoxyCodeLine{1124   \textcolor{keywordtype}{void} format\_localized(\textcolor{keywordtype}{char} format, \textcolor{keywordtype}{char} modifier = 0) \{}
\DoxyCodeLine{1125     out\_ = write<Char>(out\_, tm\_, loc\_, format, modifier);}
\DoxyCodeLine{1126   \}}
\DoxyCodeLine{1127 }
\DoxyCodeLine{1128  \textcolor{keyword}{public}:}
\DoxyCodeLine{1129   \mbox{\hyperlink{classtm__writer}{tm\_writer}}(\textcolor{keyword}{const} std::locale\& loc, OutputIt out, \textcolor{keyword}{const} std::tm\& tm)}
\DoxyCodeLine{1130       : loc\_(loc),}
\DoxyCodeLine{1131         is\_classic\_(loc\_ == get\_classic\_locale()),}
\DoxyCodeLine{1132         out\_(out),}
\DoxyCodeLine{1133         tm\_(tm) \{\}}
\DoxyCodeLine{1134 }
\DoxyCodeLine{1135   OutputIt out()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{1136 }
\DoxyCodeLine{1137   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end) \{}
\DoxyCodeLine{1138     out\_ = copy\_str<Char>(begin, end, out\_);}
\DoxyCodeLine{1139   \}}
\DoxyCodeLine{1140 }
\DoxyCodeLine{1141   \textcolor{keywordtype}{void} on\_abbr\_weekday() \{}
\DoxyCodeLine{1142     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1143       out\_ = write(out\_, tm\_wday\_short\_name(tm\_wday()));}
\DoxyCodeLine{1144     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1145       format\_localized(\textcolor{charliteral}{'a'});}
\DoxyCodeLine{1146   \}}
\DoxyCodeLine{1147   \textcolor{keywordtype}{void} on\_full\_weekday() \{}
\DoxyCodeLine{1148     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1149       out\_ = write(out\_, tm\_wday\_full\_name(tm\_wday()));}
\DoxyCodeLine{1150     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1151       format\_localized(\textcolor{charliteral}{'A'});}
\DoxyCodeLine{1152   \}}
\DoxyCodeLine{1153   \textcolor{keywordtype}{void} on\_dec0\_weekday(numeric\_system ns) \{}
\DoxyCodeLine{1154     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \textcolor{keywordflow}{return} write1(tm\_wday());}
\DoxyCodeLine{1155     format\_localized(\textcolor{charliteral}{'w'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1156   \}}
\DoxyCodeLine{1157   \textcolor{keywordtype}{void} on\_dec1\_weekday(numeric\_system ns) \{}
\DoxyCodeLine{1158     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \{}
\DoxyCodeLine{1159       \textcolor{keyword}{auto} wday = tm\_wday();}
\DoxyCodeLine{1160       write1(wday == 0 ? days\_per\_week : wday);}
\DoxyCodeLine{1161     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1162       format\_localized(\textcolor{charliteral}{'u'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1163     \}}
\DoxyCodeLine{1164   \}}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166   \textcolor{keywordtype}{void} on\_abbr\_month() \{}
\DoxyCodeLine{1167     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1168       out\_ = write(out\_, tm\_mon\_short\_name(tm\_mon()));}
\DoxyCodeLine{1169     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1170       format\_localized(\textcolor{charliteral}{'b'});}
\DoxyCodeLine{1171   \}}
\DoxyCodeLine{1172   \textcolor{keywordtype}{void} on\_full\_month() \{}
\DoxyCodeLine{1173     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1174       out\_ = write(out\_, tm\_mon\_full\_name(tm\_mon()));}
\DoxyCodeLine{1175     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1176       format\_localized(\textcolor{charliteral}{'B'});}
\DoxyCodeLine{1177   \}}
\DoxyCodeLine{1178 }
\DoxyCodeLine{1179   \textcolor{keywordtype}{void} on\_datetime(numeric\_system ns) \{}
\DoxyCodeLine{1180     \textcolor{keywordflow}{if} (is\_classic\_) \{}
\DoxyCodeLine{1181       on\_abbr\_weekday();}
\DoxyCodeLine{1182       *out\_++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{1183       on\_abbr\_month();}
\DoxyCodeLine{1184       *out\_++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{1185       on\_day\_of\_month\_space(numeric\_system::standard);}
\DoxyCodeLine{1186       *out\_++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{1187       on\_iso\_time();}
\DoxyCodeLine{1188       *out\_++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{1189       on\_year(numeric\_system::standard);}
\DoxyCodeLine{1190     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1191       format\_localized(\textcolor{charliteral}{'c'}, ns == numeric\_system::standard ? \textcolor{charliteral}{'\(\backslash\)0'} : \textcolor{charliteral}{'E'});}
\DoxyCodeLine{1192     \}}
\DoxyCodeLine{1193   \}}
\DoxyCodeLine{1194   \textcolor{keywordtype}{void} on\_loc\_date(numeric\_system ns) \{}
\DoxyCodeLine{1195     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1196       on\_us\_date();}
\DoxyCodeLine{1197     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1198       format\_localized(\textcolor{charliteral}{'x'}, ns == numeric\_system::standard ? \textcolor{charliteral}{'\(\backslash\)0'} : \textcolor{charliteral}{'E'});}
\DoxyCodeLine{1199   \}}
\DoxyCodeLine{1200   \textcolor{keywordtype}{void} on\_loc\_time(numeric\_system ns) \{}
\DoxyCodeLine{1201     \textcolor{keywordflow}{if} (is\_classic\_)}
\DoxyCodeLine{1202       on\_iso\_time();}
\DoxyCodeLine{1203     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1204       format\_localized(\textcolor{charliteral}{'X'}, ns == numeric\_system::standard ? \textcolor{charliteral}{'\(\backslash\)0'} : \textcolor{charliteral}{'E'});}
\DoxyCodeLine{1205   \}}
\DoxyCodeLine{1206   \textcolor{keywordtype}{void} on\_us\_date() \{}
\DoxyCodeLine{1207     \textcolor{keywordtype}{char} buf[8];}
\DoxyCodeLine{1208     write\_digit2\_separated(buf, to\_unsigned(tm\_mon() + 1),}
\DoxyCodeLine{1209                            to\_unsigned(tm\_mday()),}
\DoxyCodeLine{1210                            to\_unsigned(split\_year\_lower(tm\_year())), \textcolor{charliteral}{'/'});}
\DoxyCodeLine{1211     out\_ = copy\_str<Char>(std::begin(buf), std::end(buf), out\_);}
\DoxyCodeLine{1212   \}}
\DoxyCodeLine{1213   \textcolor{keywordtype}{void} on\_iso\_date() \{}
\DoxyCodeLine{1214     \textcolor{keyword}{auto} year = tm\_year();}
\DoxyCodeLine{1215     \textcolor{keywordtype}{char} buf[10];}
\DoxyCodeLine{1216     \textcolor{keywordtype}{size\_t} offset = 0;}
\DoxyCodeLine{1217     \textcolor{keywordflow}{if} (year >= 0 \&\& year < 10000) \{}
\DoxyCodeLine{1218       copy2(buf, digits2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(year / 100)));}
\DoxyCodeLine{1219     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1220       offset = 4;}
\DoxyCodeLine{1221       write\_year\_extended(year);}
\DoxyCodeLine{1222       year = 0;}
\DoxyCodeLine{1223     \}}
\DoxyCodeLine{1224     write\_digit2\_separated(buf + 2, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(year \% 100),}
\DoxyCodeLine{1225                            to\_unsigned(tm\_mon() + 1), to\_unsigned(tm\_mday()),}
\DoxyCodeLine{1226                            \textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{1227     out\_ = copy\_str<Char>(std::begin(buf) + offset, std::end(buf), out\_);}
\DoxyCodeLine{1228   \}}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230   \textcolor{keywordtype}{void} on\_utc\_offset() \{ format\_utc\_offset\_impl(tm\_); \}}
\DoxyCodeLine{1231   \textcolor{keywordtype}{void} on\_tz\_name() \{ format\_tz\_name\_impl(tm\_); \}}
\DoxyCodeLine{1232 }
\DoxyCodeLine{1233   \textcolor{keywordtype}{void} on\_year(numeric\_system ns) \{}
\DoxyCodeLine{1234     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard)}
\DoxyCodeLine{1235       \textcolor{keywordflow}{return} write\_year(tm\_year());}
\DoxyCodeLine{1236     format\_localized(\textcolor{charliteral}{'Y'}, \textcolor{charliteral}{'E'});}
\DoxyCodeLine{1237   \}}
\DoxyCodeLine{1238   \textcolor{keywordtype}{void} on\_short\_year(numeric\_system ns) \{}
\DoxyCodeLine{1239     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard)}
\DoxyCodeLine{1240       \textcolor{keywordflow}{return} write2(split\_year\_lower(tm\_year()));}
\DoxyCodeLine{1241     format\_localized(\textcolor{charliteral}{'y'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1242   \}}
\DoxyCodeLine{1243   \textcolor{keywordtype}{void} on\_offset\_year() \{}
\DoxyCodeLine{1244     \textcolor{keywordflow}{if} (is\_classic\_) \textcolor{keywordflow}{return} write2(split\_year\_lower(tm\_year()));}
\DoxyCodeLine{1245     format\_localized(\textcolor{charliteral}{'y'}, \textcolor{charliteral}{'E'});}
\DoxyCodeLine{1246   \}}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248   \textcolor{keywordtype}{void} on\_century(numeric\_system ns) \{}
\DoxyCodeLine{1249     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \{}
\DoxyCodeLine{1250       \textcolor{keyword}{auto} year = tm\_year();}
\DoxyCodeLine{1251       \textcolor{keyword}{auto} upper = year / 100;}
\DoxyCodeLine{1252       \textcolor{keywordflow}{if} (year >= -\/99 \&\& year < 0) \{}
\DoxyCodeLine{1253         \textcolor{comment}{// Zero upper on negative year.}}
\DoxyCodeLine{1254         *out\_++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{1255         *out\_++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1256       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (upper >= 0 \&\& upper < 100) \{}
\DoxyCodeLine{1257         write2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(upper));}
\DoxyCodeLine{1258       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1259         out\_ = write<Char>(out\_, upper);}
\DoxyCodeLine{1260       \}}
\DoxyCodeLine{1261     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1262       format\_localized(\textcolor{charliteral}{'C'}, \textcolor{charliteral}{'E'});}
\DoxyCodeLine{1263     \}}
\DoxyCodeLine{1264   \}}
\DoxyCodeLine{1265 }
\DoxyCodeLine{1266   \textcolor{keywordtype}{void} on\_dec\_month(numeric\_system ns) \{}
\DoxyCodeLine{1267     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard)}
\DoxyCodeLine{1268       \textcolor{keywordflow}{return} write2(tm\_mon() + 1);}
\DoxyCodeLine{1269     format\_localized(\textcolor{charliteral}{'m'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1270   \}}
\DoxyCodeLine{1271 }
\DoxyCodeLine{1272   \textcolor{keywordtype}{void} on\_dec0\_week\_of\_year(numeric\_system ns) \{}
\DoxyCodeLine{1273     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard)}
\DoxyCodeLine{1274       \textcolor{keywordflow}{return} write2((tm\_yday() + days\_per\_week -\/ tm\_wday()) / days\_per\_week);}
\DoxyCodeLine{1275     format\_localized(\textcolor{charliteral}{'U'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1276   \}}
\DoxyCodeLine{1277   \textcolor{keywordtype}{void} on\_dec1\_week\_of\_year(numeric\_system ns) \{}
\DoxyCodeLine{1278     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \{}
\DoxyCodeLine{1279       \textcolor{keyword}{auto} wday = tm\_wday();}
\DoxyCodeLine{1280       write2((tm\_yday() + days\_per\_week -\/}
\DoxyCodeLine{1281               (wday == 0 ? (days\_per\_week -\/ 1) : (wday -\/ 1))) /}
\DoxyCodeLine{1282              days\_per\_week);}
\DoxyCodeLine{1283     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1284       format\_localized(\textcolor{charliteral}{'W'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1285     \}}
\DoxyCodeLine{1286   \}}
\DoxyCodeLine{1287   \textcolor{keywordtype}{void} on\_iso\_week\_of\_year(numeric\_system ns) \{}
\DoxyCodeLine{1288     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard)}
\DoxyCodeLine{1289       \textcolor{keywordflow}{return} write2(tm\_iso\_week\_of\_year());}
\DoxyCodeLine{1290     format\_localized(\textcolor{charliteral}{'V'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1291   \}}
\DoxyCodeLine{1292 }
\DoxyCodeLine{1293   \textcolor{keywordtype}{void} on\_iso\_week\_based\_year() \{ write\_year(tm\_iso\_week\_year()); \}}
\DoxyCodeLine{1294   \textcolor{keywordtype}{void} on\_iso\_week\_based\_short\_year() \{}
\DoxyCodeLine{1295     write2(split\_year\_lower(tm\_iso\_week\_year()));}
\DoxyCodeLine{1296   \}}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298   \textcolor{keywordtype}{void} on\_day\_of\_year() \{}
\DoxyCodeLine{1299     \textcolor{keyword}{auto} yday = tm\_yday() + 1;}
\DoxyCodeLine{1300     write1(yday / 100);}
\DoxyCodeLine{1301     write2(yday \% 100);}
\DoxyCodeLine{1302   \}}
\DoxyCodeLine{1303   \textcolor{keywordtype}{void} on\_day\_of\_month(numeric\_system ns) \{}
\DoxyCodeLine{1304     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \textcolor{keywordflow}{return} write2(tm\_mday());}
\DoxyCodeLine{1305     format\_localized(\textcolor{charliteral}{'d'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1306   \}}
\DoxyCodeLine{1307   \textcolor{keywordtype}{void} on\_day\_of\_month\_space(numeric\_system ns) \{}
\DoxyCodeLine{1308     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \{}
\DoxyCodeLine{1309       \textcolor{keyword}{auto} mday = to\_unsigned(tm\_mday()) \% 100;}
\DoxyCodeLine{1310       \textcolor{keyword}{const} \textcolor{keywordtype}{char}* d2 = digits2(mday);}
\DoxyCodeLine{1311       *out\_++ = mday < 10 ? \textcolor{charliteral}{' '} : d2[0];}
\DoxyCodeLine{1312       *out\_++ = d2[1];}
\DoxyCodeLine{1313     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1314       format\_localized(\textcolor{charliteral}{'e'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1315     \}}
\DoxyCodeLine{1316   \}}
\DoxyCodeLine{1317 }
\DoxyCodeLine{1318   \textcolor{keywordtype}{void} on\_24\_hour(numeric\_system ns) \{}
\DoxyCodeLine{1319     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \textcolor{keywordflow}{return} write2(tm\_hour());}
\DoxyCodeLine{1320     format\_localized(\textcolor{charliteral}{'H'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1321   \}}
\DoxyCodeLine{1322   \textcolor{keywordtype}{void} on\_12\_hour(numeric\_system ns) \{}
\DoxyCodeLine{1323     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard)}
\DoxyCodeLine{1324       \textcolor{keywordflow}{return} write2(tm\_hour12());}
\DoxyCodeLine{1325     format\_localized(\textcolor{charliteral}{'I'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1326   \}}
\DoxyCodeLine{1327   \textcolor{keywordtype}{void} on\_minute(numeric\_system ns) \{}
\DoxyCodeLine{1328     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \textcolor{keywordflow}{return} write2(tm\_min());}
\DoxyCodeLine{1329     format\_localized(\textcolor{charliteral}{'M'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1330   \}}
\DoxyCodeLine{1331   \textcolor{keywordtype}{void} on\_second(numeric\_system ns) \{}
\DoxyCodeLine{1332     \textcolor{keywordflow}{if} (is\_classic\_ || ns == numeric\_system::standard) \textcolor{keywordflow}{return} write2(tm\_sec());}
\DoxyCodeLine{1333     format\_localized(\textcolor{charliteral}{'S'}, \textcolor{charliteral}{'O'});}
\DoxyCodeLine{1334   \}}
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336   \textcolor{keywordtype}{void} on\_12\_hour\_time() \{}
\DoxyCodeLine{1337     \textcolor{keywordflow}{if} (is\_classic\_) \{}
\DoxyCodeLine{1338       \textcolor{keywordtype}{char} buf[8];}
\DoxyCodeLine{1339       write\_digit2\_separated(buf, to\_unsigned(tm\_hour12()),}
\DoxyCodeLine{1340                              to\_unsigned(tm\_min()), to\_unsigned(tm\_sec()), \textcolor{charliteral}{':'});}
\DoxyCodeLine{1341       out\_ = copy\_str<Char>(std::begin(buf), std::end(buf), out\_);}
\DoxyCodeLine{1342       *out\_++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{1343       on\_am\_pm();}
\DoxyCodeLine{1344     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1345       format\_localized(\textcolor{charliteral}{'r'});}
\DoxyCodeLine{1346     \}}
\DoxyCodeLine{1347   \}}
\DoxyCodeLine{1348   \textcolor{keywordtype}{void} on\_24\_hour\_time() \{}
\DoxyCodeLine{1349     write2(tm\_hour());}
\DoxyCodeLine{1350     *out\_++ = \textcolor{charliteral}{':'};}
\DoxyCodeLine{1351     write2(tm\_min());}
\DoxyCodeLine{1352   \}}
\DoxyCodeLine{1353   \textcolor{keywordtype}{void} on\_iso\_time() \{}
\DoxyCodeLine{1354     \textcolor{keywordtype}{char} buf[8];}
\DoxyCodeLine{1355     write\_digit2\_separated(buf, to\_unsigned(tm\_hour()), to\_unsigned(tm\_min()),}
\DoxyCodeLine{1356                            to\_unsigned(tm\_sec()), \textcolor{charliteral}{':'});}
\DoxyCodeLine{1357     out\_ = copy\_str<Char>(std::begin(buf), std::end(buf), out\_);}
\DoxyCodeLine{1358   \}}
\DoxyCodeLine{1359 }
\DoxyCodeLine{1360   \textcolor{keywordtype}{void} on\_am\_pm() \{}
\DoxyCodeLine{1361     \textcolor{keywordflow}{if} (is\_classic\_) \{}
\DoxyCodeLine{1362       *out\_++ = tm\_hour() < 12 ? \textcolor{charliteral}{'A'} : \textcolor{charliteral}{'P'};}
\DoxyCodeLine{1363       *out\_++ = \textcolor{charliteral}{'M'};}
\DoxyCodeLine{1364     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1365       format\_localized(\textcolor{charliteral}{'p'});}
\DoxyCodeLine{1366     \}}
\DoxyCodeLine{1367   \}}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369   \textcolor{comment}{// These apply to chrono durations but not tm.}}
\DoxyCodeLine{1370   \textcolor{keywordtype}{void} on\_duration\_value() \{\}}
\DoxyCodeLine{1371   \textcolor{keywordtype}{void} on\_duration\_unit() \{\}}
\DoxyCodeLine{1372 \};}
\DoxyCodeLine{1373 }
\DoxyCodeLine{1374 \textcolor{keyword}{struct }\mbox{\hyperlink{structchrono__format__checker}{chrono\_format\_checker}} : \mbox{\hyperlink{structnull__chrono__spec__handler}{null\_chrono\_spec\_handler}}<chrono\_format\_checker> \{}
\DoxyCodeLine{1375   FMT\_NORETURN \textcolor{keywordtype}{void} unsupported() \{ FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}no date"{}})); \}}
\DoxyCodeLine{1376 }
\DoxyCodeLine{1377   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1378   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char*, \textcolor{keyword}{const} Char*) \{\}}
\DoxyCodeLine{1379   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_24\_hour(numeric\_system) \{\}}
\DoxyCodeLine{1380   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_12\_hour(numeric\_system) \{\}}
\DoxyCodeLine{1381   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_minute(numeric\_system) \{\}}
\DoxyCodeLine{1382   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_second(numeric\_system) \{\}}
\DoxyCodeLine{1383   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_12\_hour\_time() \{\}}
\DoxyCodeLine{1384   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_24\_hour\_time() \{\}}
\DoxyCodeLine{1385   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_iso\_time() \{\}}
\DoxyCodeLine{1386   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_am\_pm() \{\}}
\DoxyCodeLine{1387   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_duration\_value() \{\}}
\DoxyCodeLine{1388   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_duration\_unit() \{\}}
\DoxyCodeLine{1389 \};}
\DoxyCodeLine{1390 }
\DoxyCodeLine{1391 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{1392 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isfinite(T) \{}
\DoxyCodeLine{1393   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1394 \}}
\DoxyCodeLine{1395 }
\DoxyCodeLine{1396 \textcolor{comment}{// Converts value to Int and checks that it's in the range [0, upper).}}
\DoxyCodeLine{1397 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Int, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{1398 \textcolor{keyword}{inline} Int to\_nonnegative\_int(T \mbox{\hyperlink{classvalue}{value}}, Int upper) \{}
\DoxyCodeLine{1399   FMT\_ASSERT(\mbox{\hyperlink{classvalue}{value}} >= 0 \&\& to\_unsigned(\mbox{\hyperlink{classvalue}{value}}) <= to\_unsigned(upper),}
\DoxyCodeLine{1400              \textcolor{stringliteral}{"{}invalid value"{}});}
\DoxyCodeLine{1401   (void)upper;}
\DoxyCodeLine{1402   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Int\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{1403 \}}
\DoxyCodeLine{1404 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Int, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{1405 \textcolor{keyword}{inline} Int to\_nonnegative\_int(T \mbox{\hyperlink{classvalue}{value}}, Int upper) \{}
\DoxyCodeLine{1406   \textcolor{keywordflow}{if} (\mbox{\hyperlink{classvalue}{value < 0 || value >}} \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(upper))}
\DoxyCodeLine{1407     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid value"{}}));}
\DoxyCodeLine{1408   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Int\textcolor{keyword}{>}(\mbox{\hyperlink{classvalue}{value}});}
\DoxyCodeLine{1409 \}}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{1412 \textcolor{keyword}{inline} T mod(T x, \textcolor{keywordtype}{int} y) \{}
\DoxyCodeLine{1413   \textcolor{keywordflow}{return} x \% \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(y);}
\DoxyCodeLine{1414 \}}
\DoxyCodeLine{1415 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{float}ing\_po\textcolor{keywordtype}{int}<T>::value)>}
\DoxyCodeLine{1416 \textcolor{keyword}{inline} T mod(T x, \textcolor{keywordtype}{int} y) \{}
\DoxyCodeLine{1417   \textcolor{keywordflow}{return} std::fmod(x, \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(y));}
\DoxyCodeLine{1418 \}}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420 \textcolor{comment}{// If T is an integral type, maps T to its unsigned counterpart, otherwise}}
\DoxyCodeLine{1421 \textcolor{comment}{// leaves it unchanged (unlike std::make\_unsigned).}}
\DoxyCodeLine{1422 template <typename T, bool INTEGRAL = std::is\_integral<T>::value>}
\DoxyCodeLine{1423 \textcolor{keyword}{struct }\mbox{\hyperlink{structmake__unsigned__or__unchanged}{make\_unsigned\_or\_unchanged}} \{}
\DoxyCodeLine{1424   \textcolor{keyword}{using }type = T;}
\DoxyCodeLine{1425 \};}
\DoxyCodeLine{1426 }
\DoxyCodeLine{1427 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structmake__unsigned__or__unchanged}{make\_unsigned\_or\_unchanged}}<T, true> \{}
\DoxyCodeLine{1428   \textcolor{keyword}{using }type = \textcolor{keyword}{typename} std::make\_unsigned<T>::type;}
\DoxyCodeLine{1429 \};}
\DoxyCodeLine{1430 }
\DoxyCodeLine{1431 \textcolor{preprocessor}{\#if FMT\_SAFE\_DURATION\_CAST}}
\DoxyCodeLine{1432 \textcolor{comment}{// throwing version of safe\_duration\_cast}}
\DoxyCodeLine{1433 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} FromRep, \textcolor{keyword}{typename} FromPeriod>}
\DoxyCodeLine{1434 To fmt\_safe\_duration\_cast(std::chrono::duration<FromRep, FromPeriod> from) \{}
\DoxyCodeLine{1435   \textcolor{keywordtype}{int} ec;}
\DoxyCodeLine{1436   To to = safe\_duration\_cast::safe\_duration\_cast<To>(from, ec);}
\DoxyCodeLine{1437   \textcolor{keywordflow}{if} (ec) FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}cannot format duration"{}}));}
\DoxyCodeLine{1438   \textcolor{keywordflow}{return} to;}
\DoxyCodeLine{1439 \}}
\DoxyCodeLine{1440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1441 }
\DoxyCodeLine{1442 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rep, \textcolor{keyword}{typename} Period,}
\DoxyCodeLine{1443           FMT\_ENABLE\_IF(std::is\_integral<Rep>::value)>}
\DoxyCodeLine{1444 \textcolor{keyword}{inline} std::chrono::duration<Rep, std::milli> get\_milliseconds(}
\DoxyCodeLine{1445     std::chrono::duration<Rep, Period> d) \{}
\DoxyCodeLine{1446   \textcolor{comment}{// this may overflow and/or the result may not fit in the}}
\DoxyCodeLine{1447   \textcolor{comment}{// target type.}}
\DoxyCodeLine{1448 \textcolor{preprocessor}{\#if FMT\_SAFE\_DURATION\_CAST}}
\DoxyCodeLine{1449   \textcolor{keyword}{using }CommonSecondsType =}
\DoxyCodeLine{1450       \textcolor{keyword}{typename} std::common\_type<\textcolor{keyword}{decltype}(d), std::chrono::seconds>::type;}
\DoxyCodeLine{1451   \textcolor{keyword}{const} \textcolor{keyword}{auto} d\_as\_common = fmt\_safe\_duration\_cast<CommonSecondsType>(d);}
\DoxyCodeLine{1452   \textcolor{keyword}{const} \textcolor{keyword}{auto} d\_as\_whole\_seconds =}
\DoxyCodeLine{1453       fmt\_safe\_duration\_cast<std::chrono::seconds>(d\_as\_common);}
\DoxyCodeLine{1454   \textcolor{comment}{// this conversion should be nonproblematic}}
\DoxyCodeLine{1455   \textcolor{keyword}{const} \textcolor{keyword}{auto} diff = d\_as\_common -\/ d\_as\_whole\_seconds;}
\DoxyCodeLine{1456   \textcolor{keyword}{const} \textcolor{keyword}{auto} ms =}
\DoxyCodeLine{1457       fmt\_safe\_duration\_cast<std::chrono::duration<Rep, std::milli>>(diff);}
\DoxyCodeLine{1458   \textcolor{keywordflow}{return} ms;}
\DoxyCodeLine{1459 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1460   \textcolor{keyword}{auto} s = std::chrono::duration\_cast<std::chrono::seconds>(d);}
\DoxyCodeLine{1461   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::milliseconds>(d -\/ s);}
\DoxyCodeLine{1462 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1463 \}}
\DoxyCodeLine{1464 }
\DoxyCodeLine{1465 \textcolor{comment}{// Counts the number of fractional digits in the range [0, 18] according to the}}
\DoxyCodeLine{1466 \textcolor{comment}{// C++20 spec. If more than 18 fractional digits are required then returns 6 for}}
\DoxyCodeLine{1467 \textcolor{comment}{// microseconds precision.}}
\DoxyCodeLine{1468 \textcolor{keyword}{template} <\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} Num, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} Den, \textcolor{keywordtype}{int} N = 0,}
\DoxyCodeLine{1469           \textcolor{keywordtype}{bool} Enabled = (N < 19) \&\& (Num <= max\_value<long long>() / 10)>}
\DoxyCodeLine{1470 \textcolor{keyword}{struct} \mbox{\hyperlink{structcount__fractional__digits}{count\_fractional\_digits}} \{}
\DoxyCodeLine{1471   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} \mbox{\hyperlink{classvalue}{value}} =}
\DoxyCodeLine{1472       Num \% Den == 0 ? N : \mbox{\hyperlink{structcount__fractional__digits}{count\_fractional\_digits<Num * 10, Den, N + 1>::value}};}
\DoxyCodeLine{1473 \};}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475 \textcolor{comment}{// Base case that doesn't instantiate any more templates}}
\DoxyCodeLine{1476 \textcolor{comment}{// in order to avoid overflow.}}
\DoxyCodeLine{1477 \textcolor{keyword}{template} <\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} Num, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} Den, \textcolor{keywordtype}{int} N>}
\DoxyCodeLine{1478 \textcolor{keyword}{struct }\mbox{\hyperlink{structcount__fractional__digits_3_01_num_00_01_den_00_01_n_00_01false_01_4}{count\_fractional\_digits<Num, Den, N, false>}} \{}
\DoxyCodeLine{1479   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} \mbox{\hyperlink{classvalue}{value}} = (Num \% Den == 0) ? N : 6;}
\DoxyCodeLine{1480 \};}
\DoxyCodeLine{1481 }
\DoxyCodeLine{1482 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} pow10(std::uint32\_t n) \{}
\DoxyCodeLine{1483   \textcolor{keywordflow}{return} n == 0 ? 1 : 10 * pow10(n -\/ 1);}
\DoxyCodeLine{1484 \}}
\DoxyCodeLine{1485 }
\DoxyCodeLine{1486 \textcolor{keyword}{template} <\textcolor{keyword}{class }Rep, \textcolor{keyword}{class }Period,}
\DoxyCodeLine{1487           FMT\_ENABLE\_IF(std::numeric\_limits<Rep>::is\_signed)>}
\DoxyCodeLine{1488 \textcolor{keyword}{constexpr} std::chrono::duration<Rep, Period> abs(}
\DoxyCodeLine{1489     std::chrono::duration<Rep, Period> d) \{}
\DoxyCodeLine{1490   \textcolor{comment}{// We need to compare the duration using the count() method directly}}
\DoxyCodeLine{1491   \textcolor{comment}{// due to a compiler bug in clang-\/11 regarding the spaceship operator,}}
\DoxyCodeLine{1492   \textcolor{comment}{// when -\/Wzero-\/as-\/null-\/pointer-\/constant is enabled.}}
\DoxyCodeLine{1493   \textcolor{comment}{// In clang-\/12 the bug has been fixed. See}}
\DoxyCodeLine{1494   \textcolor{comment}{// https://bugs.llvm.org/show\_bug.cgi?id=46235 and the reproducible example:}}
\DoxyCodeLine{1495   \textcolor{comment}{// https://www.godbolt.org/z/Knbb5joYx.}}
\DoxyCodeLine{1496   \textcolor{keywordflow}{return} d.count() >= d.zero().count() ? d : -\/d;}
\DoxyCodeLine{1497 \}}
\DoxyCodeLine{1498 }
\DoxyCodeLine{1499 \textcolor{keyword}{template} <\textcolor{keyword}{class }Rep, \textcolor{keyword}{class }Period,}
\DoxyCodeLine{1500           FMT\_ENABLE\_IF(!std::numeric\_limits<Rep>::is\_signed)>}
\DoxyCodeLine{1501 \textcolor{keyword}{constexpr} std::chrono::duration<Rep, Period> abs(}
\DoxyCodeLine{1502     std::chrono::duration<Rep, Period> d) \{}
\DoxyCodeLine{1503   \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{1504 \}}
\DoxyCodeLine{1505 }
\DoxyCodeLine{1506 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Rep, \textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{1507           FMT\_ENABLE\_IF(std::is\_integral<Rep>::value)>}
\DoxyCodeLine{1508 OutputIt format\_duration\_value(OutputIt out, Rep val, \textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{1509   \textcolor{keywordflow}{return} write<Char>(out, val);}
\DoxyCodeLine{1510 \}}
\DoxyCodeLine{1511 }
\DoxyCodeLine{1512 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Rep, \textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{1513           FMT\_ENABLE\_IF(std::is\_floating\_point<Rep>::value)>}
\DoxyCodeLine{1514 OutputIt format\_duration\_value(OutputIt out, Rep val, \textcolor{keywordtype}{int} precision) \{}
\DoxyCodeLine{1515   \textcolor{keyword}{auto} specs = \mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}}();}
\DoxyCodeLine{1516   specs.precision = precision;}
\DoxyCodeLine{1517   specs.type = precision >= 0 ? presentation\_type::fixed\_lower}
\DoxyCodeLine{1518                               : presentation\_type::general\_lower;}
\DoxyCodeLine{1519   \textcolor{keywordflow}{return} write<Char>(out, val, specs);}
\DoxyCodeLine{1520 \}}
\DoxyCodeLine{1521 }
\DoxyCodeLine{1522 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1523 OutputIt copy\_unit(\mbox{\hyperlink{classbasic__string__view}{string\_view}} unit, OutputIt out, Char) \{}
\DoxyCodeLine{1524   \textcolor{keywordflow}{return} std::copy(unit.begin(), unit.end(), out);}
\DoxyCodeLine{1525 \}}
\DoxyCodeLine{1526 }
\DoxyCodeLine{1527 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1528 OutputIt copy\_unit(\mbox{\hyperlink{classbasic__string__view}{string\_view}} unit, OutputIt out, \textcolor{keywordtype}{wchar\_t}) \{}
\DoxyCodeLine{1529   \textcolor{comment}{// This works when wchar\_t is UTF-\/32 because units only contain characters}}
\DoxyCodeLine{1530   \textcolor{comment}{// that have the same representation in UTF-\/16 and UTF-\/32.}}
\DoxyCodeLine{1531   \mbox{\hyperlink{classutf8__to__utf16}{utf8\_to\_utf16}} u(unit);}
\DoxyCodeLine{1532   \textcolor{keywordflow}{return} std::copy(u.c\_str(), u.c\_str() + u.size(), out);}
\DoxyCodeLine{1533 \}}
\DoxyCodeLine{1534 }
\DoxyCodeLine{1535 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Period, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1536 OutputIt format\_duration\_unit(OutputIt out) \{}
\DoxyCodeLine{1537   \textcolor{keywordflow}{if} (\textcolor{keyword}{const} \textcolor{keywordtype}{char}* unit = get\_units<Period>())}
\DoxyCodeLine{1538     \textcolor{keywordflow}{return} copy\_unit(\mbox{\hyperlink{classbasic__string__view}{string\_view}}(unit), out, Char());}
\DoxyCodeLine{1539   *out++ = \textcolor{charliteral}{'['};}
\DoxyCodeLine{1540   out = write<Char>(out, Period::num);}
\DoxyCodeLine{1541   \textcolor{keywordflow}{if} (const\_check(Period::den != 1)) \{}
\DoxyCodeLine{1542     *out++ = \textcolor{charliteral}{'/'};}
\DoxyCodeLine{1543     out = write<Char>(out, Period::den);}
\DoxyCodeLine{1544   \}}
\DoxyCodeLine{1545   *out++ = \textcolor{charliteral}{']'};}
\DoxyCodeLine{1546   *out++ = \textcolor{charliteral}{'s'};}
\DoxyCodeLine{1547   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1548 \}}
\DoxyCodeLine{1549 }
\DoxyCodeLine{1550 \textcolor{keyword}{class }\mbox{\hyperlink{classget__locale}{get\_locale}} \{}
\DoxyCodeLine{1551  \textcolor{keyword}{private}:}
\DoxyCodeLine{1552   \textcolor{keyword}{union }\{}
\DoxyCodeLine{1553     std::locale locale\_;}
\DoxyCodeLine{1554   \};}
\DoxyCodeLine{1555   \textcolor{keywordtype}{bool} has\_locale\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{1556 }
\DoxyCodeLine{1557  \textcolor{keyword}{public}:}
\DoxyCodeLine{1558   \mbox{\hyperlink{classget__locale}{get\_locale}}(\textcolor{keywordtype}{bool} localized, \mbox{\hyperlink{classlocale__ref}{locale\_ref}} loc) : has\_locale\_(localized) \{}
\DoxyCodeLine{1559     \textcolor{keywordflow}{if} (localized)}
\DoxyCodeLine{1560       ::new (\&locale\_) std::locale(loc.template get<std::locale>());}
\DoxyCodeLine{1561   \}}
\DoxyCodeLine{1562   \mbox{\hyperlink{classget__locale}{\string~get\_locale}}() \{}
\DoxyCodeLine{1563     \textcolor{keywordflow}{if} (has\_locale\_) locale\_.\string~locale();}
\DoxyCodeLine{1564   \}}
\DoxyCodeLine{1565   \textcolor{keyword}{operator} \textcolor{keyword}{const} std::locale\&() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1566     \textcolor{keywordflow}{return} has\_locale\_ ? locale\_ : get\_classic\_locale();}
\DoxyCodeLine{1567   \}}
\DoxyCodeLine{1568 \};}
\DoxyCodeLine{1569 }
\DoxyCodeLine{1570 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Rep,}
\DoxyCodeLine{1571           \textcolor{keyword}{typename} Period>}
\DoxyCodeLine{1572 \textcolor{keyword}{struct }\mbox{\hyperlink{structchrono__formatter}{chrono\_formatter}} \{}
\DoxyCodeLine{1573   FormatContext\& context;}
\DoxyCodeLine{1574   OutputIt out;}
\DoxyCodeLine{1575   \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1576   \textcolor{keywordtype}{bool} localized = \textcolor{keyword}{false};}
\DoxyCodeLine{1577   \textcolor{comment}{// rep is unsigned to avoid overflow.}}
\DoxyCodeLine{1578   \textcolor{keyword}{using }rep =}
\DoxyCodeLine{1579       conditional\_t<std::is\_integral<Rep>::value \&\& \textcolor{keyword}{sizeof}(Rep) < \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}),}
\DoxyCodeLine{1580                     unsigned, \textcolor{keyword}{typename} make\_unsigned\_or\_unchanged<Rep>::type>;}
\DoxyCodeLine{1581   rep val;}
\DoxyCodeLine{1582   \textcolor{keyword}{using }seconds = std::chrono::duration<rep>;}
\DoxyCodeLine{1583   seconds s;}
\DoxyCodeLine{1584   \textcolor{keyword}{using }milliseconds = std::chrono::duration<rep, std::milli>;}
\DoxyCodeLine{1585   \textcolor{keywordtype}{bool} negative;}
\DoxyCodeLine{1586 }
\DoxyCodeLine{1587   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} FormatContext::char\_type;}
\DoxyCodeLine{1588   \textcolor{keyword}{using }\mbox{\hyperlink{classtm__writer}{tm\_writer\_type}} = \mbox{\hyperlink{classtm__writer}{tm\_writer<OutputIt, char\_type>}};}
\DoxyCodeLine{1589 }
\DoxyCodeLine{1590   \mbox{\hyperlink{structchrono__formatter}{chrono\_formatter}}(FormatContext\& ctx, OutputIt o,}
\DoxyCodeLine{1591                    std::chrono::duration<Rep, Period> d)}
\DoxyCodeLine{1592       : context(ctx),}
\DoxyCodeLine{1593         out(o),}
\DoxyCodeLine{1594         val(\textcolor{keyword}{static\_cast<}rep\textcolor{keyword}{>}(d.count())),}
\DoxyCodeLine{1595         negative(\textcolor{keyword}{false}) \{}
\DoxyCodeLine{1596     \textcolor{keywordflow}{if} (d.count() < 0) \{}
\DoxyCodeLine{1597       val = 0 -\/ val;}
\DoxyCodeLine{1598       negative = \textcolor{keyword}{true};}
\DoxyCodeLine{1599     \}}
\DoxyCodeLine{1600 }
\DoxyCodeLine{1601     \textcolor{comment}{// this may overflow and/or the result may not fit in the}}
\DoxyCodeLine{1602     \textcolor{comment}{// target type.}}
\DoxyCodeLine{1603 \textcolor{preprocessor}{\#if FMT\_SAFE\_DURATION\_CAST}}
\DoxyCodeLine{1604     \textcolor{comment}{// might need checked conversion (rep!=Rep)}}
\DoxyCodeLine{1605     \textcolor{keyword}{auto} tmpval = std::chrono::duration<rep, Period>(val);}
\DoxyCodeLine{1606     s = fmt\_safe\_duration\_cast<seconds>(tmpval);}
\DoxyCodeLine{1607 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1608     s = std::chrono::duration\_cast<seconds>(}
\DoxyCodeLine{1609         std::chrono::duration<rep, Period>(val));}
\DoxyCodeLine{1610 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1611   \}}
\DoxyCodeLine{1612 }
\DoxyCodeLine{1613   \textcolor{comment}{// returns true if nan or inf, writes to out.}}
\DoxyCodeLine{1614   \textcolor{keywordtype}{bool} handle\_nan\_inf() \{}
\DoxyCodeLine{1615     \textcolor{keywordflow}{if} (isfinite(val)) \{}
\DoxyCodeLine{1616       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1617     \}}
\DoxyCodeLine{1618     \textcolor{keywordflow}{if} (isnan(val)) \{}
\DoxyCodeLine{1619       write\_nan();}
\DoxyCodeLine{1620       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1621     \}}
\DoxyCodeLine{1622     \textcolor{comment}{// must be +-\/inf}}
\DoxyCodeLine{1623     \textcolor{keywordflow}{if} (val > 0) \{}
\DoxyCodeLine{1624       write\_pinf();}
\DoxyCodeLine{1625     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1626       write\_ninf();}
\DoxyCodeLine{1627     \}}
\DoxyCodeLine{1628     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1629   \}}
\DoxyCodeLine{1630 }
\DoxyCodeLine{1631   Rep hour()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Rep\textcolor{keyword}{>}(mod((s.count() / 3600), 24)); \}}
\DoxyCodeLine{1632 }
\DoxyCodeLine{1633   Rep hour12()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1634     Rep hour = \textcolor{keyword}{static\_cast<}Rep\textcolor{keyword}{>}(mod((s.count() / 3600), 12));}
\DoxyCodeLine{1635     \textcolor{keywordflow}{return} hour <= 0 ? 12 : hour;}
\DoxyCodeLine{1636   \}}
\DoxyCodeLine{1637 }
\DoxyCodeLine{1638   Rep minute()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Rep\textcolor{keyword}{>}(mod((s.count() / 60), 60)); \}}
\DoxyCodeLine{1639   Rep second()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Rep\textcolor{keyword}{>}(mod(s.count(), 60)); \}}
\DoxyCodeLine{1640 }
\DoxyCodeLine{1641   std::tm time()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1642     \textcolor{keyword}{auto} time = std::tm();}
\DoxyCodeLine{1643     time.tm\_hour = to\_nonnegative\_int(hour(), 24);}
\DoxyCodeLine{1644     time.tm\_min = to\_nonnegative\_int(minute(), 60);}
\DoxyCodeLine{1645     time.tm\_sec = to\_nonnegative\_int(second(), 60);}
\DoxyCodeLine{1646     \textcolor{keywordflow}{return} time;}
\DoxyCodeLine{1647   \}}
\DoxyCodeLine{1648 }
\DoxyCodeLine{1649   \textcolor{keywordtype}{void} write\_sign() \{}
\DoxyCodeLine{1650     \textcolor{keywordflow}{if} (negative) \{}
\DoxyCodeLine{1651       *out++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{1652       negative = \textcolor{keyword}{false};}
\DoxyCodeLine{1653     \}}
\DoxyCodeLine{1654   \}}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656   \textcolor{keywordtype}{void} write(Rep \mbox{\hyperlink{classvalue}{value}}, \textcolor{keywordtype}{int} width) \{}
\DoxyCodeLine{1657     write\_sign();}
\DoxyCodeLine{1658     \textcolor{keywordflow}{if} (isnan(\mbox{\hyperlink{classvalue}{value}})) \textcolor{keywordflow}{return} write\_nan();}
\DoxyCodeLine{1659     uint32\_or\_64\_or\_128\_t<int> n =}
\DoxyCodeLine{1660         to\_unsigned(to\_nonnegative\_int(\mbox{\hyperlink{classvalue}{value}}, max\_value<int>()));}
\DoxyCodeLine{1661     \textcolor{keywordtype}{int} num\_digits = detail::count\_digits(n);}
\DoxyCodeLine{1662     \textcolor{keywordflow}{if} (width > num\_digits) out = std::fill\_n(out, width -\/ num\_digits, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{1663     out = format\_decimal<char\_type>(out, n, num\_digits).end;}
\DoxyCodeLine{1664   \}}
\DoxyCodeLine{1665 }
\DoxyCodeLine{1666   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration> \textcolor{keywordtype}{void} write\_fractional\_seconds(Duration d) \{}
\DoxyCodeLine{1667     FMT\_ASSERT(!std::is\_floating\_point<typename Duration::rep>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1668     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_fractional\_digits =}
\DoxyCodeLine{1669         \mbox{\hyperlink{structcount__fractional__digits}{count\_fractional\_digits}}<Duration::period::num,}
\DoxyCodeLine{1670                                 Duration::period::den>\mbox{\hyperlink{classvalue}{::value}};}
\DoxyCodeLine{1671 }
\DoxyCodeLine{1672     \textcolor{keyword}{using }subsecond\_precision = std::chrono::duration<}
\DoxyCodeLine{1673         \textcolor{keyword}{typename} std::common\_type<\textcolor{keyword}{typename} Duration::rep,}
\DoxyCodeLine{1674                                   std::chrono::seconds::rep>::type,}
\DoxyCodeLine{1675         std::ratio<1, detail::pow10(num\_fractional\_digits)>>;}
\DoxyCodeLine{1676     \textcolor{keywordflow}{if} (std::ratio\_less<\textcolor{keyword}{typename} subsecond\_precision::period,}
\DoxyCodeLine{1677                         std::chrono::seconds::period>\mbox{\hyperlink{classvalue}{::value}}) \{}
\DoxyCodeLine{1678       *out++ = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1679       \textcolor{keyword}{auto} fractional =}
\DoxyCodeLine{1680           detail::abs(d) -\/ std::chrono::duration\_cast<std::chrono::seconds>(d);}
\DoxyCodeLine{1681       \textcolor{keyword}{auto} subseconds =}
\DoxyCodeLine{1682           std::chrono::treat\_as\_floating\_point<}
\DoxyCodeLine{1683               \textcolor{keyword}{typename} subsecond\_precision::rep>\mbox{\hyperlink{classvalue}{::value}}}
\DoxyCodeLine{1684               ? fractional.count()}
\DoxyCodeLine{1685               : std::chrono::duration\_cast<subsecond\_precision>(fractional)}
\DoxyCodeLine{1686                     .count();}
\DoxyCodeLine{1687       uint32\_or\_64\_or\_128\_t<long long> n =}
\DoxyCodeLine{1688           to\_unsigned(to\_nonnegative\_int(subseconds, max\_value<long long>()));}
\DoxyCodeLine{1689       \textcolor{keywordtype}{int} num\_digits = detail::count\_digits(n);}
\DoxyCodeLine{1690       \textcolor{keywordflow}{if} (num\_fractional\_digits > num\_digits)}
\DoxyCodeLine{1691         out = std::fill\_n(out, num\_fractional\_digits -\/ num\_digits, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{1692       out = format\_decimal<char\_type>(out, n, num\_digits).end;}
\DoxyCodeLine{1693     \}}
\DoxyCodeLine{1694   \}}
\DoxyCodeLine{1695 }
\DoxyCodeLine{1696   \textcolor{keywordtype}{void} write\_nan() \{ std::copy\_n(\textcolor{stringliteral}{"{}nan"{}}, 3, out); \}}
\DoxyCodeLine{1697   \textcolor{keywordtype}{void} write\_pinf() \{ std::copy\_n(\textcolor{stringliteral}{"{}inf"{}}, 3, out); \}}
\DoxyCodeLine{1698   \textcolor{keywordtype}{void} write\_ninf() \{ std::copy\_n(\textcolor{stringliteral}{"{}-\/inf"{}}, 4, out); \}}
\DoxyCodeLine{1699 }
\DoxyCodeLine{1700   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callback, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1701   \textcolor{keywordtype}{void} format\_tm(\textcolor{keyword}{const} tm\& time, Callback cb, Args... args) \{}
\DoxyCodeLine{1702     \textcolor{keywordflow}{if} (isnan(val)) \textcolor{keywordflow}{return} write\_nan();}
\DoxyCodeLine{1703     \mbox{\hyperlink{classget__locale}{get\_locale}} loc(localized, context.locale());}
\DoxyCodeLine{1704     \textcolor{keyword}{auto} w = \mbox{\hyperlink{classtm__writer}{tm\_writer\_type}}(loc, out, time);}
\DoxyCodeLine{1705     (w.*cb)(args...);}
\DoxyCodeLine{1706     out = w.out();}
\DoxyCodeLine{1707   \}}
\DoxyCodeLine{1708 }
\DoxyCodeLine{1709   \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} char\_type* begin, \textcolor{keyword}{const} char\_type* end) \{}
\DoxyCodeLine{1710     std::copy(begin, end, out);}
\DoxyCodeLine{1711   \}}
\DoxyCodeLine{1712 }
\DoxyCodeLine{1713   \textcolor{comment}{// These are not implemented because durations don't have date information.}}
\DoxyCodeLine{1714   \textcolor{keywordtype}{void} on\_abbr\_weekday() \{\}}
\DoxyCodeLine{1715   \textcolor{keywordtype}{void} on\_full\_weekday() \{\}}
\DoxyCodeLine{1716   \textcolor{keywordtype}{void} on\_dec0\_weekday(numeric\_system) \{\}}
\DoxyCodeLine{1717   \textcolor{keywordtype}{void} on\_dec1\_weekday(numeric\_system) \{\}}
\DoxyCodeLine{1718   \textcolor{keywordtype}{void} on\_abbr\_month() \{\}}
\DoxyCodeLine{1719   \textcolor{keywordtype}{void} on\_full\_month() \{\}}
\DoxyCodeLine{1720   \textcolor{keywordtype}{void} on\_datetime(numeric\_system) \{\}}
\DoxyCodeLine{1721   \textcolor{keywordtype}{void} on\_loc\_date(numeric\_system) \{\}}
\DoxyCodeLine{1722   \textcolor{keywordtype}{void} on\_loc\_time(numeric\_system) \{\}}
\DoxyCodeLine{1723   \textcolor{keywordtype}{void} on\_us\_date() \{\}}
\DoxyCodeLine{1724   \textcolor{keywordtype}{void} on\_iso\_date() \{\}}
\DoxyCodeLine{1725   \textcolor{keywordtype}{void} on\_utc\_offset() \{\}}
\DoxyCodeLine{1726   \textcolor{keywordtype}{void} on\_tz\_name() \{\}}
\DoxyCodeLine{1727   \textcolor{keywordtype}{void} on\_year(numeric\_system) \{\}}
\DoxyCodeLine{1728   \textcolor{keywordtype}{void} on\_short\_year(numeric\_system) \{\}}
\DoxyCodeLine{1729   \textcolor{keywordtype}{void} on\_offset\_year() \{\}}
\DoxyCodeLine{1730   \textcolor{keywordtype}{void} on\_century(numeric\_system) \{\}}
\DoxyCodeLine{1731   \textcolor{keywordtype}{void} on\_iso\_week\_based\_year() \{\}}
\DoxyCodeLine{1732   \textcolor{keywordtype}{void} on\_iso\_week\_based\_short\_year() \{\}}
\DoxyCodeLine{1733   \textcolor{keywordtype}{void} on\_dec\_month(numeric\_system) \{\}}
\DoxyCodeLine{1734   \textcolor{keywordtype}{void} on\_dec0\_week\_of\_year(numeric\_system) \{\}}
\DoxyCodeLine{1735   \textcolor{keywordtype}{void} on\_dec1\_week\_of\_year(numeric\_system) \{\}}
\DoxyCodeLine{1736   \textcolor{keywordtype}{void} on\_iso\_week\_of\_year(numeric\_system) \{\}}
\DoxyCodeLine{1737   \textcolor{keywordtype}{void} on\_day\_of\_year() \{\}}
\DoxyCodeLine{1738   \textcolor{keywordtype}{void} on\_day\_of\_month(numeric\_system) \{\}}
\DoxyCodeLine{1739   \textcolor{keywordtype}{void} on\_day\_of\_month\_space(numeric\_system) \{\}}
\DoxyCodeLine{1740 }
\DoxyCodeLine{1741   \textcolor{keywordtype}{void} on\_24\_hour(numeric\_system ns) \{}
\DoxyCodeLine{1742     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1743 }
\DoxyCodeLine{1744     \textcolor{keywordflow}{if} (ns == numeric\_system::standard) \textcolor{keywordflow}{return} write(hour(), 2);}
\DoxyCodeLine{1745     \textcolor{keyword}{auto} time = tm();}
\DoxyCodeLine{1746     time.tm\_hour = to\_nonnegative\_int(hour(), 24);}
\DoxyCodeLine{1747     format\_tm(time, \&tm\_writer\_type::on\_24\_hour, ns);}
\DoxyCodeLine{1748   \}}
\DoxyCodeLine{1749 }
\DoxyCodeLine{1750   \textcolor{keywordtype}{void} on\_12\_hour(numeric\_system ns) \{}
\DoxyCodeLine{1751     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1752 }
\DoxyCodeLine{1753     \textcolor{keywordflow}{if} (ns == numeric\_system::standard) \textcolor{keywordflow}{return} write(hour12(), 2);}
\DoxyCodeLine{1754     \textcolor{keyword}{auto} time = tm();}
\DoxyCodeLine{1755     time.tm\_hour = to\_nonnegative\_int(hour12(), 12);}
\DoxyCodeLine{1756     format\_tm(time, \&tm\_writer\_type::on\_12\_hour, ns);}
\DoxyCodeLine{1757   \}}
\DoxyCodeLine{1758 }
\DoxyCodeLine{1759   \textcolor{keywordtype}{void} on\_minute(numeric\_system ns) \{}
\DoxyCodeLine{1760     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1761 }
\DoxyCodeLine{1762     \textcolor{keywordflow}{if} (ns == numeric\_system::standard) \textcolor{keywordflow}{return} write(minute(), 2);}
\DoxyCodeLine{1763     \textcolor{keyword}{auto} time = tm();}
\DoxyCodeLine{1764     time.tm\_min = to\_nonnegative\_int(minute(), 60);}
\DoxyCodeLine{1765     format\_tm(time, \&tm\_writer\_type::on\_minute, ns);}
\DoxyCodeLine{1766   \}}
\DoxyCodeLine{1767 }
\DoxyCodeLine{1768   \textcolor{keywordtype}{void} on\_second(numeric\_system ns) \{}
\DoxyCodeLine{1769     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1770 }
\DoxyCodeLine{1771     \textcolor{keywordflow}{if} (ns == numeric\_system::standard) \{}
\DoxyCodeLine{1772       \textcolor{keywordflow}{if} (std::is\_floating\_point<rep>::value) \{}
\DoxyCodeLine{1773         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_fractional\_digits =}
\DoxyCodeLine{1774             \mbox{\hyperlink{structcount__fractional__digits}{count\_fractional\_digits<Period::num, Period::den>::value}};}
\DoxyCodeLine{1775         \textcolor{keyword}{auto} buf = \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}}();}
\DoxyCodeLine{1776         format\_to(std::back\_inserter(buf), runtime(\textcolor{stringliteral}{"{}\{:.\{\}f\}"{}}),}
\DoxyCodeLine{1777                   std::fmod(val * \textcolor{keyword}{static\_cast<}rep\textcolor{keyword}{>}(Period::num) /}
\DoxyCodeLine{1778                                 \textcolor{keyword}{static\_cast<}rep\textcolor{keyword}{>}(Period::den),}
\DoxyCodeLine{1779                             60),}
\DoxyCodeLine{1780                   num\_fractional\_digits);}
\DoxyCodeLine{1781         \textcolor{keywordflow}{if} (negative) *out++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{1782         \textcolor{keywordflow}{if} (buf.size() < 2 || buf[1] == \textcolor{charliteral}{'.'}) *out++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1783         out = std::copy(buf.begin(), buf.end(), out);}
\DoxyCodeLine{1784       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1785         write(second(), 2);}
\DoxyCodeLine{1786         write\_fractional\_seconds(std::chrono::duration<rep, Period>(val));}
\DoxyCodeLine{1787       \}}
\DoxyCodeLine{1788       \textcolor{keywordflow}{return};}
\DoxyCodeLine{1789     \}}
\DoxyCodeLine{1790     \textcolor{keyword}{auto} time = tm();}
\DoxyCodeLine{1791     time.tm\_sec = to\_nonnegative\_int(second(), 60);}
\DoxyCodeLine{1792     format\_tm(time, \&tm\_writer\_type::on\_second, ns);}
\DoxyCodeLine{1793   \}}
\DoxyCodeLine{1794 }
\DoxyCodeLine{1795   \textcolor{keywordtype}{void} on\_12\_hour\_time() \{}
\DoxyCodeLine{1796     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1797     format\_tm(time(), \&tm\_writer\_type::on\_12\_hour\_time);}
\DoxyCodeLine{1798   \}}
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800   \textcolor{keywordtype}{void} on\_24\_hour\_time() \{}
\DoxyCodeLine{1801     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \{}
\DoxyCodeLine{1802       *out++ = \textcolor{charliteral}{':'};}
\DoxyCodeLine{1803       handle\_nan\_inf();}
\DoxyCodeLine{1804       \textcolor{keywordflow}{return};}
\DoxyCodeLine{1805     \}}
\DoxyCodeLine{1806 }
\DoxyCodeLine{1807     write(hour(), 2);}
\DoxyCodeLine{1808     *out++ = \textcolor{charliteral}{':'};}
\DoxyCodeLine{1809     write(minute(), 2);}
\DoxyCodeLine{1810   \}}
\DoxyCodeLine{1811 }
\DoxyCodeLine{1812   \textcolor{keywordtype}{void} on\_iso\_time() \{}
\DoxyCodeLine{1813     on\_24\_hour\_time();}
\DoxyCodeLine{1814     *out++ = \textcolor{charliteral}{':'};}
\DoxyCodeLine{1815     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1816     on\_second(numeric\_system::standard);}
\DoxyCodeLine{1817   \}}
\DoxyCodeLine{1818 }
\DoxyCodeLine{1819   \textcolor{keywordtype}{void} on\_am\_pm() \{}
\DoxyCodeLine{1820     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1821     format\_tm(time(), \&tm\_writer\_type::on\_am\_pm);}
\DoxyCodeLine{1822   \}}
\DoxyCodeLine{1823 }
\DoxyCodeLine{1824   \textcolor{keywordtype}{void} on\_duration\_value() \{}
\DoxyCodeLine{1825     \textcolor{keywordflow}{if} (handle\_nan\_inf()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1826     write\_sign();}
\DoxyCodeLine{1827     out = format\_duration\_value<char\_type>(out, val, precision);}
\DoxyCodeLine{1828   \}}
\DoxyCodeLine{1829 }
\DoxyCodeLine{1830   \textcolor{keywordtype}{void} on\_duration\_unit() \{}
\DoxyCodeLine{1831     out = format\_duration\_unit<char\_type, Period>(out);}
\DoxyCodeLine{1832   \}}
\DoxyCodeLine{1833 \};}
\DoxyCodeLine{1834 }
\DoxyCodeLine{1835 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{1836 }
\DoxyCodeLine{1837 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_chrono) \&\& \_\_cpp\_lib\_chrono >= 201907}}
\DoxyCodeLine{1838 \textcolor{keyword}{using }\mbox{\hyperlink{classweekday}{weekday}} = std::chrono::weekday;}
\DoxyCodeLine{1839 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1840 \textcolor{comment}{// A fallback version of weekday.}}
\DoxyCodeLine{1841 \textcolor{keyword}{class }\mbox{\hyperlink{classweekday}{weekday}} \{}
\DoxyCodeLine{1842  \textcolor{keyword}{private}:}
\DoxyCodeLine{1843   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \mbox{\hyperlink{classvalue}{value}};}
\DoxyCodeLine{1844 }
\DoxyCodeLine{1845  \textcolor{keyword}{public}:}
\DoxyCodeLine{1846   \mbox{\hyperlink{classweekday}{weekday}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1847   \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{classweekday}{weekday}}(\textcolor{keywordtype}{unsigned} wd) noexcept}
\DoxyCodeLine{1848       : \mbox{\hyperlink{classvalue}{value}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(wd != 7 ? wd : 0)) \{\}}
\DoxyCodeLine{1849   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} c\_encoding() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classvalue}{value}}; \}}
\DoxyCodeLine{1850 \};}
\DoxyCodeLine{1851 }
\DoxyCodeLine{1852 \textcolor{keyword}{class }\mbox{\hyperlink{classyear__month__day}{year\_month\_day}} \{\};}
\DoxyCodeLine{1853 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855 \textcolor{comment}{// A rudimentary weekday formatter.}}
\DoxyCodeLine{1856 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{classweekday}{weekday}}, Char> \{}
\DoxyCodeLine{1857  \textcolor{keyword}{private}:}
\DoxyCodeLine{1858   \textcolor{keywordtype}{bool} localized = \textcolor{keyword}{false};}
\DoxyCodeLine{1859 }
\DoxyCodeLine{1860  \textcolor{keyword}{public}:}
\DoxyCodeLine{1861   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(\mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx)}
\DoxyCodeLine{1862       -\/> \textcolor{keyword}{decltype}(ctx.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}()) \{}
\DoxyCodeLine{1863     \textcolor{keyword}{auto} begin = ctx.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}(), end = ctx.\mbox{\hyperlink{classbasic__format__parse__context_a624461a9a7da10bd63bb596fb988fc0f}{end}}();}
\DoxyCodeLine{1864     \textcolor{keywordflow}{if} (begin != end \&\& *begin == \textcolor{charliteral}{'L'}) \{}
\DoxyCodeLine{1865       ++begin;}
\DoxyCodeLine{1866       localized = \textcolor{keyword}{true};}
\DoxyCodeLine{1867     \}}
\DoxyCodeLine{1868     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{1869   \}}
\DoxyCodeLine{1870 }
\DoxyCodeLine{1871   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{1872   \textcolor{keyword}{auto} format(\mbox{\hyperlink{classweekday}{weekday}} wd, FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{1873     \textcolor{keyword}{auto} time = std::tm();}
\DoxyCodeLine{1874     time.tm\_wday = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(wd.c\_encoding());}
\DoxyCodeLine{1875     detail::get\_locale loc(localized, ctx.locale());}
\DoxyCodeLine{1876     \textcolor{keyword}{auto} w = detail::tm\_writer<\textcolor{keyword}{decltype}(ctx.out()), Char>(loc, ctx.out(), time);}
\DoxyCodeLine{1877     w.on\_abbr\_weekday();}
\DoxyCodeLine{1878     \textcolor{keywordflow}{return} w.out();}
\DoxyCodeLine{1879   \}}
\DoxyCodeLine{1880 \};}
\DoxyCodeLine{1881 }
\DoxyCodeLine{1882 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rep, \textcolor{keyword}{typename} Period, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1883 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<std::chrono::duration<Rep, Period>, Char> \{}
\DoxyCodeLine{1884  \textcolor{keyword}{private}:}
\DoxyCodeLine{1885   \mbox{\hyperlink{structbasic__format__specs}{basic\_format\_specs<Char>}} specs;}
\DoxyCodeLine{1886   \textcolor{keywordtype}{int} precision = -\/1;}
\DoxyCodeLine{1887   \textcolor{keyword}{using }arg\_ref\_type = detail::arg\_ref<Char>;}
\DoxyCodeLine{1888   arg\_ref\_type width\_ref;}
\DoxyCodeLine{1889   arg\_ref\_type precision\_ref;}
\DoxyCodeLine{1890   \textcolor{keywordtype}{bool} localized = \textcolor{keyword}{false};}
\DoxyCodeLine{1891   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str;}
\DoxyCodeLine{1892   \textcolor{keyword}{using }duration = std::chrono::duration<Rep, Period>;}
\DoxyCodeLine{1893 }
\DoxyCodeLine{1894   \textcolor{keyword}{struct }spec\_handler \{}
\DoxyCodeLine{1895     \mbox{\hyperlink{structformatter}{formatter}}\& f;}
\DoxyCodeLine{1896     \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& context;}
\DoxyCodeLine{1897     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str;}
\DoxyCodeLine{1898 }
\DoxyCodeLine{1899     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR arg\_ref\_type make\_arg\_ref(Id arg\_id) \{}
\DoxyCodeLine{1900       context.\mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(arg\_id);}
\DoxyCodeLine{1901       \textcolor{keywordflow}{return} arg\_ref\_type(arg\_id);}
\DoxyCodeLine{1902     \}}
\DoxyCodeLine{1903 }
\DoxyCodeLine{1904     FMT\_CONSTEXPR arg\_ref\_type make\_arg\_ref(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} arg\_id) \{}
\DoxyCodeLine{1905       context.\mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(arg\_id);}
\DoxyCodeLine{1906       \textcolor{keywordflow}{return} arg\_ref\_type(arg\_id);}
\DoxyCodeLine{1907     \}}
\DoxyCodeLine{1908 }
\DoxyCodeLine{1909     FMT\_CONSTEXPR arg\_ref\_type make\_arg\_ref(detail::auto\_id) \{}
\DoxyCodeLine{1910       \textcolor{keywordflow}{return} arg\_ref\_type(context.\mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}}());}
\DoxyCodeLine{1911     \}}
\DoxyCodeLine{1912 }
\DoxyCodeLine{1913     \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg) \{ FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(msg)); \}}
\DoxyCodeLine{1914     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_fill(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fill) \{}
\DoxyCodeLine{1915       f.specs.fill = fill;}
\DoxyCodeLine{1916     \}}
\DoxyCodeLine{1917     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_align(align\_t align) \{ f.specs.align = align; \}}
\DoxyCodeLine{1918     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_width(\textcolor{keywordtype}{int} width) \{ f.specs.width = width; \}}
\DoxyCodeLine{1919     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_precision(\textcolor{keywordtype}{int} \_precision) \{}
\DoxyCodeLine{1920       f.precision = \_precision;}
\DoxyCodeLine{1921     \}}
\DoxyCodeLine{1922     FMT\_CONSTEXPR \textcolor{keywordtype}{void} end\_precision() \{\}}
\DoxyCodeLine{1923 }
\DoxyCodeLine{1924     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_width(Id arg\_id) \{}
\DoxyCodeLine{1925       f.width\_ref = make\_arg\_ref(arg\_id);}
\DoxyCodeLine{1926     \}}
\DoxyCodeLine{1927 }
\DoxyCodeLine{1928     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_precision(Id arg\_id) \{}
\DoxyCodeLine{1929       f.precision\_ref = make\_arg\_ref(arg\_id);}
\DoxyCodeLine{1930     \}}
\DoxyCodeLine{1931   \};}
\DoxyCodeLine{1932 }
\DoxyCodeLine{1933   \textcolor{keyword}{using }iterator = \textcolor{keyword}{typename} basic\_format\_parse\_context<Char>::iterator;}
\DoxyCodeLine{1934   \textcolor{keyword}{struct }parse\_range \{}
\DoxyCodeLine{1935     iterator begin;}
\DoxyCodeLine{1936     iterator end;}
\DoxyCodeLine{1937   \};}
\DoxyCodeLine{1938 }
\DoxyCodeLine{1939   FMT\_CONSTEXPR parse\_range do\_parse(\mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx) \{}
\DoxyCodeLine{1940     \textcolor{keyword}{auto} begin = ctx.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}(), end = ctx.\mbox{\hyperlink{classbasic__format__parse__context_a624461a9a7da10bd63bb596fb988fc0f}{end}}();}
\DoxyCodeLine{1941     \textcolor{keywordflow}{if} (begin == end || *begin == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{return} \{begin, begin\};}
\DoxyCodeLine{1942     spec\_handler handler\{*\textcolor{keyword}{this}, ctx, format\_str\};}
\DoxyCodeLine{1943     begin = detail::parse\_align(begin, end, handler);}
\DoxyCodeLine{1944     \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} \{begin, begin\};}
\DoxyCodeLine{1945     begin = detail::parse\_width(begin, end, handler);}
\DoxyCodeLine{1946     \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} \{begin, begin\};}
\DoxyCodeLine{1947     \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{1948       \textcolor{keywordflow}{if} (std::is\_floating\_point<Rep>::value)}
\DoxyCodeLine{1949         begin = detail::parse\_precision(begin, end, handler);}
\DoxyCodeLine{1950       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1951         handler.on\_error(\textcolor{stringliteral}{"{}precision not allowed for this argument type"{}});}
\DoxyCodeLine{1952     \}}
\DoxyCodeLine{1953     \textcolor{keywordflow}{if} (begin != end \&\& *begin == \textcolor{charliteral}{'L'}) \{}
\DoxyCodeLine{1954       ++begin;}
\DoxyCodeLine{1955       localized = \textcolor{keyword}{true};}
\DoxyCodeLine{1956     \}}
\DoxyCodeLine{1957     end = detail::parse\_chrono\_format(begin, end,}
\DoxyCodeLine{1958                                       detail::chrono\_format\_checker());}
\DoxyCodeLine{1959     \textcolor{keywordflow}{return} \{begin, end\};}
\DoxyCodeLine{1960   \}}
\DoxyCodeLine{1961 }
\DoxyCodeLine{1962  \textcolor{keyword}{public}:}
\DoxyCodeLine{1963   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(\mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx)}
\DoxyCodeLine{1964       -\/> \textcolor{keyword}{decltype}(ctx.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}()) \{}
\DoxyCodeLine{1965     \textcolor{keyword}{auto} range = do\_parse(ctx);}
\DoxyCodeLine{1966     format\_str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(}
\DoxyCodeLine{1967         \&*range.begin, detail::to\_unsigned(range.end -\/ range.begin));}
\DoxyCodeLine{1968     \textcolor{keywordflow}{return} range.end;}
\DoxyCodeLine{1969   \}}
\DoxyCodeLine{1970 }
\DoxyCodeLine{1971   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{1972   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} duration\& d, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{1973       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{1974     \textcolor{keyword}{auto} specs\_copy = specs;}
\DoxyCodeLine{1975     \textcolor{keyword}{auto} precision\_copy = precision;}
\DoxyCodeLine{1976     \textcolor{keyword}{auto} begin = format\_str.begin(), end = format\_str.end();}
\DoxyCodeLine{1977     \textcolor{comment}{// As a possible future optimization, we could avoid extra copying if width}}
\DoxyCodeLine{1978     \textcolor{comment}{// is not specified.}}
\DoxyCodeLine{1979     \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}} buf;}
\DoxyCodeLine{1980     \textcolor{keyword}{auto} out = std::back\_inserter(buf);}
\DoxyCodeLine{1981     detail::handle\_dynamic\_spec<detail::width\_checker>(specs\_copy.width,}
\DoxyCodeLine{1982                                                        width\_ref, ctx);}
\DoxyCodeLine{1983     detail::handle\_dynamic\_spec<detail::precision\_checker>(precision\_copy,}
\DoxyCodeLine{1984                                                            precision\_ref, ctx);}
\DoxyCodeLine{1985     \textcolor{keywordflow}{if} (begin == end || *begin == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{1986       out = detail::format\_duration\_value<Char>(out, d.count(), precision\_copy);}
\DoxyCodeLine{1987       detail::format\_duration\_unit<Char, Period>(out);}
\DoxyCodeLine{1988     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1989       detail::chrono\_formatter<FormatContext, \textcolor{keyword}{decltype}(out), Rep, Period> f(}
\DoxyCodeLine{1990           ctx, out, d);}
\DoxyCodeLine{1991       f.precision = precision\_copy;}
\DoxyCodeLine{1992       f.localized = localized;}
\DoxyCodeLine{1993       detail::parse\_chrono\_format(begin, end, f);}
\DoxyCodeLine{1994     \}}
\DoxyCodeLine{1995     \textcolor{keywordflow}{return} detail::write(}
\DoxyCodeLine{1996         ctx.out(), \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(buf.data(), buf.size()), specs\_copy);}
\DoxyCodeLine{1997   \}}
\DoxyCodeLine{1998 \};}
\DoxyCodeLine{1999 }
\DoxyCodeLine{2000 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2001 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<std::chrono::time\_point<std::chrono::system\_clock, Duration>,}
\DoxyCodeLine{2002                  Char> : \mbox{\hyperlink{structformatter}{formatter}}<std::tm, Char> \{}
\DoxyCodeLine{2003   FMT\_CONSTEXPR \mbox{\hyperlink{structformatter}{formatter}}() \{}
\DoxyCodeLine{2004     this-\/>do\_parse(default\_specs,}
\DoxyCodeLine{2005                    default\_specs + \textcolor{keyword}{sizeof}(default\_specs) / \textcolor{keyword}{sizeof}(Char));}
\DoxyCodeLine{2006   \}}
\DoxyCodeLine{2007 }
\DoxyCodeLine{2008   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2009   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{2010     \textcolor{keywordflow}{return} this-\/>do\_parse(ctx.begin(), ctx.end(), \textcolor{keyword}{true});}
\DoxyCodeLine{2011   \}}
\DoxyCodeLine{2012 }
\DoxyCodeLine{2013   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{2014   \textcolor{keyword}{auto} format(std::chrono::time\_point<std::chrono::system\_clock> val,}
\DoxyCodeLine{2015               FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{2016     \textcolor{keywordflow}{return} \mbox{\hyperlink{structformatter}{formatter<std::tm, Char>::format}}(localtime(val), ctx);}
\DoxyCodeLine{2017   \}}
\DoxyCodeLine{2018 }
\DoxyCodeLine{2019   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} Char default\_specs[] = \{\textcolor{charliteral}{'\%'}, \textcolor{charliteral}{'F'}, \textcolor{charliteral}{' '}, \textcolor{charliteral}{'\%'}, \textcolor{charliteral}{'T'}\};}
\DoxyCodeLine{2020 \};}
\DoxyCodeLine{2021 }
\DoxyCodeLine{2022 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2023 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} Char}
\DoxyCodeLine{2024     \mbox{\hyperlink{structformatter}{formatter<std::chrono::time\_point<std::chrono::system\_clock, Duration>}},}
\DoxyCodeLine{2025               Char>::default\_specs[];}
\DoxyCodeLine{2026 }
\DoxyCodeLine{2027 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<std::tm, Char> \{}
\DoxyCodeLine{2028  \textcolor{keyword}{private}:}
\DoxyCodeLine{2029   \textcolor{keyword}{enum class} spec \{}
\DoxyCodeLine{2030     unknown,}
\DoxyCodeLine{2031     \mbox{\hyperlink{classyear__month__day}{year\_month\_day}},}
\DoxyCodeLine{2032     hh\_mm\_ss,}
\DoxyCodeLine{2033   \};}
\DoxyCodeLine{2034   spec spec\_ = spec::unknown;}
\DoxyCodeLine{2035   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} specs;}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037  \textcolor{keyword}{protected}:}
\DoxyCodeLine{2038   \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2039   FMT\_CONSTEXPR \textcolor{keyword}{auto} do\_parse(It begin, It end, \textcolor{keywordtype}{bool} with\_default = \textcolor{keyword}{false})}
\DoxyCodeLine{2040       -\/> It \{}
\DoxyCodeLine{2041     \textcolor{keywordflow}{if} (begin != end \&\& *begin == \textcolor{charliteral}{':'}) ++begin;}
\DoxyCodeLine{2042     end = detail::parse\_chrono\_format(begin, end, detail::tm\_format\_checker());}
\DoxyCodeLine{2043     \textcolor{keywordflow}{if} (!with\_default || end != begin)}
\DoxyCodeLine{2044       specs = \{begin, detail::to\_unsigned(end -\/ begin)\};}
\DoxyCodeLine{2045     \textcolor{comment}{// basic\_string\_view<>::compare isn't constexpr before C++17.}}
\DoxyCodeLine{2046     \textcolor{keywordflow}{if} (specs.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() == 2 \&\& specs[0] == Char(\textcolor{charliteral}{'\%'})) \{}
\DoxyCodeLine{2047       \textcolor{keywordflow}{if} (specs[1] == Char(\textcolor{charliteral}{'F'}))}
\DoxyCodeLine{2048         spec\_ = spec::year\_month\_day;}
\DoxyCodeLine{2049       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (specs[1] == Char(\textcolor{charliteral}{'T'}))}
\DoxyCodeLine{2050         spec\_ = spec::hh\_mm\_ss;}
\DoxyCodeLine{2051     \}}
\DoxyCodeLine{2052     \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{2053   \}}
\DoxyCodeLine{2054 }
\DoxyCodeLine{2055  \textcolor{keyword}{public}:}
\DoxyCodeLine{2056   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2057   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{2058     \textcolor{keywordflow}{return} this-\/>do\_parse(ctx.begin(), ctx.end());}
\DoxyCodeLine{2059   \}}
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{2062   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} std::tm\& tm, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{2063       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{2064     \textcolor{keyword}{const} \textcolor{keyword}{auto} loc\_ref = ctx.locale();}
\DoxyCodeLine{2065     detail::get\_locale loc(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(loc\_ref), loc\_ref);}
\DoxyCodeLine{2066     \textcolor{keyword}{auto} w = detail::tm\_writer<\textcolor{keyword}{decltype}(ctx.out()), Char>(loc, ctx.out(), tm);}
\DoxyCodeLine{2067     \textcolor{keywordflow}{if} (spec\_ == spec::year\_month\_day)}
\DoxyCodeLine{2068       w.on\_iso\_date();}
\DoxyCodeLine{2069     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spec\_ == spec::hh\_mm\_ss)}
\DoxyCodeLine{2070       w.on\_iso\_time();}
\DoxyCodeLine{2071     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2072       detail::parse\_chrono\_format(specs.begin(), specs.end(), w);}
\DoxyCodeLine{2073     \textcolor{keywordflow}{return} w.out();}
\DoxyCodeLine{2074   \}}
\DoxyCodeLine{2075 \};}
\DoxyCodeLine{2076 }
\DoxyCodeLine{2077 FMT\_MODULE\_EXPORT\_END}
\DoxyCodeLine{2078 FMT\_END\_NAMESPACE}
\DoxyCodeLine{2079 }
\DoxyCodeLine{2080 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_CHRONO\_H\_}}

\end{DoxyCode}

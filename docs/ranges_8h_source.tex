\hypertarget{ranges_8h_source}{}\doxysection{ranges.\+h}
\label{ranges_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/ranges.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/ranges.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ experimental range support}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{// Copyright (c) 2018 -\/ present, Remotion (Igor Schulz)}}
\DoxyCodeLine{9 \textcolor{comment}{// All Rights Reserved}}
\DoxyCodeLine{10 \textcolor{comment}{// \{fmt\} support for ranges, containers and types tuple interface.}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#ifndef FMT\_RANGES\_H\_}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#define FMT\_RANGES\_H\_}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <initializer\_list>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{template} <\textcolor{keyword}{typename} RangeT, \textcolor{keyword}{typename} OutputIterator>}
\DoxyCodeLine{26 OutputIterator copy(\textcolor{keyword}{const} RangeT\& range, OutputIterator out) \{}
\DoxyCodeLine{27   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = range.begin(), end = range.end(); it != end; ++it)}
\DoxyCodeLine{28     *out++ = *it;}
\DoxyCodeLine{29   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{30 \}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIterator>}
\DoxyCodeLine{33 OutputIterator copy(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, OutputIterator out) \{}
\DoxyCodeLine{34   \textcolor{keywordflow}{while} (*str) *out++ = *str++;}
\DoxyCodeLine{35   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{36 \}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIterator>}
\DoxyCodeLine{39 OutputIterator copy(\textcolor{keywordtype}{char} ch, OutputIterator out) \{}
\DoxyCodeLine{40   *out++ = ch;}
\DoxyCodeLine{41   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{42 \}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIterator>}
\DoxyCodeLine{45 OutputIterator copy(\textcolor{keywordtype}{wchar\_t} ch, OutputIterator out) \{}
\DoxyCodeLine{46   *out++ = ch;}
\DoxyCodeLine{47   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{48 \}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{comment}{// Returns true if T has a std::string-\/like interface, like std::string\_view.}}
\DoxyCodeLine{51 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }is\_std\_string\_like \{}
\DoxyCodeLine{52   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{53   \textcolor{keyword}{static} \textcolor{keyword}{auto} check(U* p)}
\DoxyCodeLine{54       -\/> \textcolor{keyword}{decltype}((void)p-\/>find(\textcolor{charliteral}{'a'}), p-\/>length(), (void)p-\/>data(), int());}
\DoxyCodeLine{55   \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{static} \textcolor{keywordtype}{void} check(...);}
\DoxyCodeLine{56 }
\DoxyCodeLine{57  \textcolor{keyword}{public}:}
\DoxyCodeLine{58   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{59       is\_string<T>::value ||}
\DoxyCodeLine{60       std::is\_convertible<T, std\_string\_view<char>>::value ||}
\DoxyCodeLine{61       !std::is\_void<decltype(check<T>(\textcolor{keyword}{nullptr}))>::value;}
\DoxyCodeLine{62 \};}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{65 \textcolor{keyword}{struct }is\_std\_string\_like<fmt::\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}<Char>> : std::true\_type \{\};}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }is\_map \{}
\DoxyCodeLine{68   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U> \textcolor{keyword}{static} \textcolor{keyword}{auto} check(U*) -\/> \textcolor{keyword}{typename} U::mapped\_type;}
\DoxyCodeLine{69   \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{static} \textcolor{keywordtype}{void} check(...);}
\DoxyCodeLine{70 }
\DoxyCodeLine{71  \textcolor{keyword}{public}:}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#ifdef FMT\_FORMAT\_MAP\_AS\_LIST}}
\DoxyCodeLine{73   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{74 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{75   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{76       !std::is\_void<decltype(check<T>(\textcolor{keyword}{nullptr}))>::value;}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{78 \};}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }is\_set \{}
\DoxyCodeLine{81   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U> \textcolor{keyword}{static} \textcolor{keyword}{auto} check(U*) -\/> \textcolor{keyword}{typename} U::key\_type;}
\DoxyCodeLine{82   \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{static} \textcolor{keywordtype}{void} check(...);}
\DoxyCodeLine{83 }
\DoxyCodeLine{84  \textcolor{keyword}{public}:}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#ifdef FMT\_FORMAT\_SET\_AS\_LIST}}
\DoxyCodeLine{86   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{87 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{88   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{89       !std::is\_void<decltype(check<T>(\textcolor{keyword}{nullptr}))>::value \&\& !is\_map<T>::value;}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{91 \};}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts> \textcolor{keyword}{struct }conditional\_helper \{\};}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} \_ = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }is\_range\_ : std::false\_type \{\};}
\DoxyCodeLine{96 }
\DoxyCodeLine{97 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION || FMT\_MSC\_VERSION > 1800}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 \textcolor{preprocessor}{\#  define FMT\_DECLTYPE\_RETURN(val)  \(\backslash\)}}
\DoxyCodeLine{100 \textcolor{preprocessor}{    -\/>decltype(val) \{ return val; \} \(\backslash\)}}
\DoxyCodeLine{101 \textcolor{preprocessor}{    static\_assert(                  \(\backslash\)}}
\DoxyCodeLine{102 \textcolor{preprocessor}{        true, "{}"{}})  \textcolor{comment}{// This makes it so that a semicolon is required after the}}
\DoxyCodeLine{103                    \textcolor{comment}{// macro, which helps clang-\/format handle the formatting.}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{comment}{// C array overload}}
\DoxyCodeLine{106 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{107 \textcolor{keyword}{auto} range\_begin(\textcolor{keyword}{const} T (\&arr)[N]) -\/> \textcolor{keyword}{const} T* \{}
\DoxyCodeLine{108   \textcolor{keywordflow}{return} arr;}
\DoxyCodeLine{109 \}}
\DoxyCodeLine{110 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{111 \textcolor{keyword}{auto} range\_end(\textcolor{keyword}{const} T (\&arr)[N]) -\/> \textcolor{keyword}{const} T* \{}
\DoxyCodeLine{112   \textcolor{keywordflow}{return} arr + N;}
\DoxyCodeLine{113 \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{116 \textcolor{keyword}{struct }has\_member\_fn\_begin\_end\_t : std::false\_type \{\};}
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{119 \textcolor{keyword}{struct }has\_member\_fn\_begin\_end\_t<T, void\_t<decltype(std::declval<T>().begin()),}
\DoxyCodeLine{120                                            decltype(std::declval<T>().end())>>}
\DoxyCodeLine{121     : std::true\_type \{\};}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{comment}{// Member function overload}}
\DoxyCodeLine{124 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{125 \textcolor{keyword}{auto} range\_begin(T\&\& rng) FMT\_DECLTYPE\_RETURN(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(rng).begin());}
\DoxyCodeLine{126 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{127 \textcolor{keyword}{auto} range\_end(T\&\& rng) FMT\_DECLTYPE\_RETURN(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(rng).end());}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 \textcolor{comment}{// ADL overload. Only participates in overload resolution if member functions}}
\DoxyCodeLine{130 \textcolor{comment}{// are not found.}}
\DoxyCodeLine{131 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{132 \textcolor{keyword}{auto} range\_begin(T\&\& rng)}
\DoxyCodeLine{133     -\/> enable\_if\_t<!has\_member\_fn\_begin\_end\_t<T\&\&>::value,}
\DoxyCodeLine{134                    \textcolor{keyword}{decltype}(begin(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(rng)))> \{}
\DoxyCodeLine{135   \textcolor{keywordflow}{return} begin(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(rng));}
\DoxyCodeLine{136 \}}
\DoxyCodeLine{137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{138 \textcolor{keyword}{auto} range\_end(T\&\& rng) -\/> enable\_if\_t<!has\_member\_fn\_begin\_end\_t<T\&\&>::value,}
\DoxyCodeLine{139                                        \textcolor{keyword}{decltype}(end(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(rng)))> \{}
\DoxyCodeLine{140   \textcolor{keywordflow}{return} end(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(rng));}
\DoxyCodeLine{141 \}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{144 \textcolor{keyword}{struct }has\_const\_begin\_end : std::false\_type \{\};}
\DoxyCodeLine{145 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{146 \textcolor{keyword}{struct }has\_mutable\_begin\_end : std::false\_type \{\};}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{149 \textcolor{keyword}{struct }has\_const\_begin\_end<}
\DoxyCodeLine{150     T,}
\DoxyCodeLine{151     void\_t<}
\DoxyCodeLine{152         decltype(detail::range\_begin(std::declval<const remove\_cvref\_t<T>\&>())),}
\DoxyCodeLine{153         decltype(detail::range\_end(std::declval<const remove\_cvref\_t<T>\&>()))>>}
\DoxyCodeLine{154     : std::true\_type \{\};}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{157 \textcolor{keyword}{struct }has\_mutable\_begin\_end<}
\DoxyCodeLine{158     T, void\_t<decltype(detail::range\_begin(std::declval<T>())),}
\DoxyCodeLine{159               decltype(detail::range\_end(std::declval<T>())),}
\DoxyCodeLine{160               enable\_if\_t<std::is\_copy\_constructible<T>::value>>>}
\DoxyCodeLine{161     : std::true\_type \{\};}
\DoxyCodeLine{162 }
\DoxyCodeLine{163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{164 \textcolor{keyword}{struct }is\_range\_<T, void>}
\DoxyCodeLine{165     : std::integral\_constant<bool, (has\_const\_begin\_end<T>::value ||}
\DoxyCodeLine{166                                     has\_mutable\_begin\_end<T>::value)> \{\};}
\DoxyCodeLine{167 \textcolor{preprocessor}{\#  undef FMT\_DECLTYPE\_RETURN}}
\DoxyCodeLine{168 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 \textcolor{comment}{// tuple\_size and tuple\_element check.}}
\DoxyCodeLine{171 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }is\_tuple\_like\_ \{}
\DoxyCodeLine{172   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{173   \textcolor{keyword}{static} \textcolor{keyword}{auto} check(U* p) -\/> \textcolor{keyword}{decltype}(std::tuple\_size<U>::value, int());}
\DoxyCodeLine{174   \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{static} \textcolor{keywordtype}{void} check(...);}
\DoxyCodeLine{175 }
\DoxyCodeLine{176  \textcolor{keyword}{public}:}
\DoxyCodeLine{177   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{178       !std::is\_void<decltype(check<T>(\textcolor{keyword}{nullptr}))>::value;}
\DoxyCodeLine{179 \};}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{comment}{// Check for integer\_sequence}}
\DoxyCodeLine{182 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_integer\_sequence) || FMT\_MSC\_VERSION >= 1900}}
\DoxyCodeLine{183 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T... N>}
\DoxyCodeLine{184 \textcolor{keyword}{using }integer\_sequence = std::integer\_sequence<T, N...>;}
\DoxyCodeLine{185 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... N> \textcolor{keyword}{using }index\_sequence = std::index\_sequence<N...>;}
\DoxyCodeLine{186 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{using }make\_index\_sequence = std::make\_index\_sequence<N>;}
\DoxyCodeLine{187 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T... N> \textcolor{keyword}{struct }integer\_sequence \{}
\DoxyCodeLine{189   \textcolor{keyword}{using }value\_type = T;}
\DoxyCodeLine{190 }
\DoxyCodeLine{191   \textcolor{keyword}{static} FMT\_CONSTEXPR \textcolor{keywordtype}{size\_t} size() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}...(N); \}}
\DoxyCodeLine{192 \};}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... N> \textcolor{keyword}{using }index\_sequence = integer\_sequence<size\_t, N...>;}
\DoxyCodeLine{195 }
\DoxyCodeLine{196 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N, T... Ns>}
\DoxyCodeLine{197 \textcolor{keyword}{struct }make\_integer\_sequence : make\_integer\_sequence<T, N -\/ 1, N -\/ 1, Ns...> \{\};}
\DoxyCodeLine{198 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T... Ns>}
\DoxyCodeLine{199 \textcolor{keyword}{struct }make\_integer\_sequence<T, 0, Ns...> : integer\_sequence<T, Ns...> \{\};}
\DoxyCodeLine{200 }
\DoxyCodeLine{201 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{202 \textcolor{keyword}{using }make\_index\_sequence = make\_integer\_sequence<size\_t, N>;}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{206 \textcolor{keyword}{using }tuple\_index\_sequence = make\_index\_sequence<std::tuple\_size<T>::value>;}
\DoxyCodeLine{207 }
\DoxyCodeLine{208 template <typename T, typename C, bool = is\_tuple\_like\_<T>::value>}
\DoxyCodeLine{209 \textcolor{keyword}{class }is\_tuple\_formattable\_ \{}
\DoxyCodeLine{210  \textcolor{keyword}{public}:}
\DoxyCodeLine{211   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{212 \};}
\DoxyCodeLine{213 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} C> \textcolor{keyword}{class }is\_tuple\_formattable\_<T, C, true> \{}
\DoxyCodeLine{214   \textcolor{keyword}{template} <std::size\_t... I>}
\DoxyCodeLine{215   \textcolor{keyword}{static} std::true\_type check2(index\_sequence<I...>,}
\DoxyCodeLine{216                                integer\_sequence<\textcolor{keywordtype}{bool}, (I == I)...>);}
\DoxyCodeLine{217   \textcolor{keyword}{static} std::false\_type check2(...);}
\DoxyCodeLine{218   \textcolor{keyword}{template} <std::size\_t... I>}
\DoxyCodeLine{219   \textcolor{keyword}{static} \textcolor{keyword}{decltype}(check2(}
\DoxyCodeLine{220       index\_sequence<I...>\{\},}
\DoxyCodeLine{221       integer\_sequence<}
\DoxyCodeLine{222           bool, (is\_formattable<typename std::tuple\_element<I, T>::type,}
\DoxyCodeLine{223                                 C>::value)...>\{\})) check(index\_sequence<I...>);}
\DoxyCodeLine{224 }
\DoxyCodeLine{225  public:}
\DoxyCodeLine{226   static constexpr const \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{227       decltype(check(tuple\_index\_sequence<T>\{\}))::value;}
\DoxyCodeLine{228 \};}
\DoxyCodeLine{229 }
\DoxyCodeLine{230 \textcolor{keyword}{template} <\textcolor{keyword}{class }Tuple, \textcolor{keyword}{class }F, \textcolor{keywordtype}{size\_t}... Is>}
\DoxyCodeLine{231 \textcolor{keywordtype}{void} for\_each(index\_sequence<Is...>, Tuple\&\& tup, F\&\& f) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{232   \textcolor{keyword}{using }std::get;}
\DoxyCodeLine{233   \textcolor{comment}{// using free function get<I>(T) now.}}
\DoxyCodeLine{234   \textcolor{keyword}{const} \textcolor{keywordtype}{int} \_[] = \{0, ((void)f(get<Is>(tup)), 0)...\};}
\DoxyCodeLine{235   (void)\_;  \textcolor{comment}{// blocks warnings}}
\DoxyCodeLine{236 \}}
\DoxyCodeLine{237 }
\DoxyCodeLine{238 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{239 FMT\_CONSTEXPR make\_index\_sequence<std::tuple\_size<T>::value> get\_indexes(}
\DoxyCodeLine{240     T \textcolor{keyword}{const}\&) \{}
\DoxyCodeLine{241   \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{242 \}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244 \textcolor{keyword}{template} <\textcolor{keyword}{class} Tuple, \textcolor{keyword}{class} F> \textcolor{keywordtype}{void} for\_each(Tuple\&\& tup, F\&\& f) \{}
\DoxyCodeLine{245   \textcolor{keyword}{const} \textcolor{keyword}{auto} indexes = get\_indexes(tup);}
\DoxyCodeLine{246   for\_each(indexes, std::forward<Tuple>(tup), std::forward<F>(f));}
\DoxyCodeLine{247 \}}
\DoxyCodeLine{248 }
\DoxyCodeLine{249 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION \&\& FMT\_MSC\_VERSION < 1920}}
\DoxyCodeLine{250 \textcolor{comment}{// Older MSVC doesn't get the reference type correctly for arrays.}}
\DoxyCodeLine{251 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R> \textcolor{keyword}{struct }range\_reference\_type\_impl \{}
\DoxyCodeLine{252   \textcolor{keyword}{using }type = \textcolor{keyword}{decltype}(*detail::range\_begin(std::declval<R\&>()));}
\DoxyCodeLine{253 \};}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }range\_reference\_type\_impl<T[N]> \{}
\DoxyCodeLine{256   \textcolor{keyword}{using }type = T\&;}
\DoxyCodeLine{257 \};}
\DoxyCodeLine{258 }
\DoxyCodeLine{259 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{260 \textcolor{keyword}{using }range\_reference\_type = \textcolor{keyword}{typename} range\_reference\_type\_impl<T>::type;}
\DoxyCodeLine{261 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{262 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{263 \textcolor{keyword}{using }range\_reference\_type =}
\DoxyCodeLine{264     \textcolor{keyword}{decltype}(*detail::range\_begin(std::declval<Range\&>()));}
\DoxyCodeLine{265 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{266 }
\DoxyCodeLine{267 \textcolor{comment}{// We don't use the Range's value\_type for anything, but we do need the Range's}}
\DoxyCodeLine{268 \textcolor{comment}{// reference type, with cv-\/ref stripped.}}
\DoxyCodeLine{269 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{270 \textcolor{keyword}{using }uncvref\_type = remove\_cvref\_t<range\_reference\_type<Range>>;}
\DoxyCodeLine{271 }
\DoxyCodeLine{272 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{273 \textcolor{keyword}{using }uncvref\_first\_type = remove\_cvref\_t<}
\DoxyCodeLine{274     \textcolor{keyword}{decltype}(std::declval<range\_reference\_type<Range>>().first)>;}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{277 \textcolor{keyword}{using }uncvref\_second\_type = remove\_cvref\_t<}
\DoxyCodeLine{278     \textcolor{keyword}{decltype}(std::declval<range\_reference\_type<Range>>().second)>;}
\DoxyCodeLine{279 }
\DoxyCodeLine{280 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt> OutputIt write\_delimiter(OutputIt out) \{}
\DoxyCodeLine{281   *out++ = \textcolor{charliteral}{','};}
\DoxyCodeLine{282   *out++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{283   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{284 \}}
\DoxyCodeLine{285 }
\DoxyCodeLine{286 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{287 \textcolor{keyword}{auto} write\_range\_entry(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str) -\/> OutputIt \{}
\DoxyCodeLine{288   \textcolor{keywordflow}{return} write\_escaped\_string(out, str);}
\DoxyCodeLine{289 \}}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{292           FMT\_ENABLE\_IF(std::is\_convertible<T, std\_string\_view<char>>::value)>}
\DoxyCodeLine{293 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_range\_entry(OutputIt out, \textcolor{keyword}{const} T\& str) -\/> OutputIt \{}
\DoxyCodeLine{294   \textcolor{keyword}{auto} sv = std\_string\_view<Char>(str);}
\DoxyCodeLine{295   \textcolor{keywordflow}{return} write\_range\_entry<Char>(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(sv));}
\DoxyCodeLine{296 \}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Arg,}
\DoxyCodeLine{299           FMT\_ENABLE\_IF(std::is\_same<Arg, Char>::value)>}
\DoxyCodeLine{300 OutputIt write\_range\_entry(OutputIt out, \textcolor{keyword}{const} Arg v) \{}
\DoxyCodeLine{301   \textcolor{keywordflow}{return} write\_escaped\_char(out, v);}
\DoxyCodeLine{302 \}}
\DoxyCodeLine{303 }
\DoxyCodeLine{304 \textcolor{keyword}{template} <}
\DoxyCodeLine{305     \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Arg,}
\DoxyCodeLine{306     FMT\_ENABLE\_IF(!is\_std\_string\_like<\textcolor{keyword}{typename} std::decay<Arg>::type>::value \&\&}
\DoxyCodeLine{307                   !std::is\_same<Arg, Char>::value)>}
\DoxyCodeLine{308 OutputIt write\_range\_entry(OutputIt out, \textcolor{keyword}{const} Arg\& v) \{}
\DoxyCodeLine{309   \textcolor{keywordflow}{return} write<Char>(out, v);}
\DoxyCodeLine{310 \}}
\DoxyCodeLine{311 }
\DoxyCodeLine{312 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{313 }
\DoxyCodeLine{314 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_tuple\_like \{}
\DoxyCodeLine{315   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{316       detail::is\_tuple\_like\_<T>::value \&\& !detail::is\_range\_<T>::value;}
\DoxyCodeLine{317 \};}
\DoxyCodeLine{318 }
\DoxyCodeLine{319 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} C> \textcolor{keyword}{struct }is\_tuple\_formattable \{}
\DoxyCodeLine{320   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{321       detail::is\_tuple\_formattable\_<T, C>::value;}
\DoxyCodeLine{322 \};}
\DoxyCodeLine{323 }
\DoxyCodeLine{324 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleT, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{325 \textcolor{keyword}{struct }formatter<TupleT, Char,}
\DoxyCodeLine{326                  enable\_if\_t<fmt::is\_tuple\_like<TupleT>::value \&\&}
\DoxyCodeLine{327                              fmt::is\_tuple\_formattable<TupleT, Char>::value>> \{}
\DoxyCodeLine{328  \textcolor{keyword}{private}:}
\DoxyCodeLine{329   \textcolor{comment}{// C++11 generic lambda for format().}}
\DoxyCodeLine{330   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext> \textcolor{keyword}{struct }format\_each \{}
\DoxyCodeLine{331     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} T\& v) \{}
\DoxyCodeLine{332       \textcolor{keywordflow}{if} (i > 0) out = detail::write\_delimiter(out);}
\DoxyCodeLine{333       out = detail::write\_range\_entry<Char>(out, v);}
\DoxyCodeLine{334       ++i;}
\DoxyCodeLine{335     \}}
\DoxyCodeLine{336     \textcolor{keywordtype}{int} i;}
\DoxyCodeLine{337     \textcolor{keyword}{typename} FormatContext::iterator\& out;}
\DoxyCodeLine{338   \};}
\DoxyCodeLine{339 }
\DoxyCodeLine{340  \textcolor{keyword}{public}:}
\DoxyCodeLine{341   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{342   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{343     \textcolor{keywordflow}{return} ctx.begin();}
\DoxyCodeLine{344   \}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext = format\_context>}
\DoxyCodeLine{347   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} TupleT\& values, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{348       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{349     \textcolor{keyword}{auto} out = ctx.out();}
\DoxyCodeLine{350     *out++ = \textcolor{charliteral}{'('};}
\DoxyCodeLine{351     detail::for\_each(values, format\_each<FormatContext>\{0, out\});}
\DoxyCodeLine{352     *out++ = \textcolor{charliteral}{')'};}
\DoxyCodeLine{353     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{354   \}}
\DoxyCodeLine{355 \};}
\DoxyCodeLine{356 }
\DoxyCodeLine{357 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }is\_range \{}
\DoxyCodeLine{358   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{359       detail::is\_range\_<T>::value \&\& !detail::is\_std\_string\_like<T>::value \&\&}
\DoxyCodeLine{360       !detail::is\_map<T>::value \&\&}
\DoxyCodeLine{361       !std::is\_convertible<T, std::basic\_string<Char>>::value \&\&}
\DoxyCodeLine{362       !std::is\_constructible<detail::std\_string\_view<Char>, T>::value;}
\DoxyCodeLine{363 \};}
\DoxyCodeLine{364 }
\DoxyCodeLine{365 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{366 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{struct }range\_mapper \{}
\DoxyCodeLine{367   \textcolor{keyword}{using }mapper = arg\_mapper<Context>;}
\DoxyCodeLine{368 }
\DoxyCodeLine{369   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{370             FMT\_ENABLE\_IF(has\_formatter<remove\_cvref\_t<T>, Context>::value)>}
\DoxyCodeLine{371   \textcolor{keyword}{static} \textcolor{keyword}{auto} map(T\&\& value) -\/> T\&\& \{}
\DoxyCodeLine{372     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(value);}
\DoxyCodeLine{373   \}}
\DoxyCodeLine{374   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{375             FMT\_ENABLE\_IF(!has\_formatter<remove\_cvref\_t<T>, Context>::value)>}
\DoxyCodeLine{376   \textcolor{keyword}{static} \textcolor{keyword}{auto} map(T\&\& value)}
\DoxyCodeLine{377       -\/> \textcolor{keyword}{decltype}(mapper().map(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(value))) \{}
\DoxyCodeLine{378     \textcolor{keywordflow}{return} mapper().map(\textcolor{keyword}{static\_cast<}T\&\&\textcolor{keyword}{>}(value));}
\DoxyCodeLine{379   \}}
\DoxyCodeLine{380 \};}
\DoxyCodeLine{381 }
\DoxyCodeLine{382 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Element>}
\DoxyCodeLine{383 \textcolor{keyword}{using }range\_formatter\_type = conditional\_t<}
\DoxyCodeLine{384     is\_formattable<Element, Char>::value,}
\DoxyCodeLine{385     formatter<remove\_cvref\_t<\textcolor{keyword}{decltype}(range\_mapper<buffer\_context<Char>>\{\}.map(}
\DoxyCodeLine{386                   std::declval<Element>()))>,}
\DoxyCodeLine{387               Char>,}
\DoxyCodeLine{388     fallback\_formatter<Element, Char>>;}
\DoxyCodeLine{389 }
\DoxyCodeLine{390 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{391 \textcolor{keyword}{using }maybe\_const\_range =}
\DoxyCodeLine{392     conditional\_t<has\_const\_begin\_end<R>::value, \textcolor{keyword}{const} R, R>;}
\DoxyCodeLine{393 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{396 \textcolor{keyword}{struct }formatter<}
\DoxyCodeLine{397     R, Char,}
\DoxyCodeLine{398     enable\_if\_t<}
\DoxyCodeLine{399         conjunction<fmt::is\_range<R, Char>}
\DoxyCodeLine{400 \textcolor{comment}{// Workaround a bug in MSVC 2017 and earlier.}}
\DoxyCodeLine{401 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION || FMT\_MSC\_VERSION >= 1920}}
\DoxyCodeLine{402         ,}
\DoxyCodeLine{403         disjunction<}
\DoxyCodeLine{404           is\_formattable<detail::uncvref\_type<detail::maybe\_const\_range<R>>,}
\DoxyCodeLine{405                          Char>,}
\DoxyCodeLine{406           detail::has\_fallback\_formatter<}
\DoxyCodeLine{407              detail::uncvref\_type<detail::maybe\_const\_range<R>>, Char>}
\DoxyCodeLine{408         >}
\DoxyCodeLine{409 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{410         >::value}
\DoxyCodeLine{411         >> \{}
\DoxyCodeLine{412 }
\DoxyCodeLine{413   \textcolor{keyword}{using }range\_type = detail::maybe\_const\_range<R>;}
\DoxyCodeLine{414   \textcolor{keyword}{using }formatter\_type =}
\DoxyCodeLine{415       detail::range\_formatter\_type<Char, detail::uncvref\_type<range\_type>>;}
\DoxyCodeLine{416   formatter\_type underlying\_;}
\DoxyCodeLine{417   \textcolor{keywordtype}{bool} custom\_specs\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{418 }
\DoxyCodeLine{419   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{420   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{421     \textcolor{keyword}{auto} it = ctx.begin();}
\DoxyCodeLine{422     \textcolor{keyword}{auto} end = ctx.end();}
\DoxyCodeLine{423     \textcolor{keywordflow}{if} (it == end || *it == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{424 }
\DoxyCodeLine{425     \textcolor{keywordflow}{if} (*it != \textcolor{charliteral}{':'})}
\DoxyCodeLine{426       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}no top-\/level range formatters supported"{}}));}
\DoxyCodeLine{427 }
\DoxyCodeLine{428     custom\_specs\_ = \textcolor{keyword}{true};}
\DoxyCodeLine{429     ++it;}
\DoxyCodeLine{430     ctx.advance\_to(it);}
\DoxyCodeLine{431     \textcolor{keywordflow}{return} underlying\_.parse(ctx);}
\DoxyCodeLine{432   \}}
\DoxyCodeLine{433 }
\DoxyCodeLine{434   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{435   \textcolor{keyword}{auto} format(range\_type\& range, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{436       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{437     Char prefix = detail::is\_set<R>::value ? \textcolor{charliteral}{'\{'} : \textcolor{charliteral}{'['};}
\DoxyCodeLine{438     Char postfix = detail::is\_set<R>::value ? \textcolor{charliteral}{'\}'} : \textcolor{charliteral}{']'};}
\DoxyCodeLine{439     detail::range\_mapper<buffer\_context<Char>> mapper;}
\DoxyCodeLine{440     \textcolor{keyword}{auto} out = ctx.out();}
\DoxyCodeLine{441     *out++ = prefix;}
\DoxyCodeLine{442     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{443     \textcolor{keyword}{auto} it = detail::range\_begin(range);}
\DoxyCodeLine{444     \textcolor{keyword}{auto} end = detail::range\_end(range);}
\DoxyCodeLine{445     \textcolor{keywordflow}{for} (; it != end; ++it) \{}
\DoxyCodeLine{446       \textcolor{keywordflow}{if} (i > 0) out = detail::write\_delimiter(out);}
\DoxyCodeLine{447       \textcolor{keywordflow}{if} (custom\_specs\_) \{}
\DoxyCodeLine{448         ctx.advance\_to(out);}
\DoxyCodeLine{449         out = underlying\_.format(mapper.map(*it), ctx);}
\DoxyCodeLine{450       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{451         out = detail::write\_range\_entry<Char>(out, *it);}
\DoxyCodeLine{452       \}}
\DoxyCodeLine{453       ++i;}
\DoxyCodeLine{454     \}}
\DoxyCodeLine{455     *out++ = postfix;}
\DoxyCodeLine{456     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{457   \}}
\DoxyCodeLine{458 \};}
\DoxyCodeLine{459 }
\DoxyCodeLine{460 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{461 \textcolor{keyword}{struct }formatter<}
\DoxyCodeLine{462     T, Char,}
\DoxyCodeLine{463     enable\_if\_t<conjunction<detail::is\_map<T>}
\DoxyCodeLine{464 \textcolor{comment}{// Workaround a bug in MSVC 2017 and earlier.}}
\DoxyCodeLine{465 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION || FMT\_MSC\_VERSION >= 1920}}
\DoxyCodeLine{466         ,}
\DoxyCodeLine{467         disjunction<}
\DoxyCodeLine{468           is\_formattable<detail::uncvref\_first\_type<T>, Char>,}
\DoxyCodeLine{469           detail::has\_fallback\_formatter<detail::uncvref\_first\_type<T>, Char>}
\DoxyCodeLine{470         >,}
\DoxyCodeLine{471         disjunction<}
\DoxyCodeLine{472           is\_formattable<detail::uncvref\_second\_type<T>, Char>,}
\DoxyCodeLine{473           detail::has\_fallback\_formatter<detail::uncvref\_second\_type<T>, Char>}
\DoxyCodeLine{474         >}
\DoxyCodeLine{475 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{476     >::value}
\DoxyCodeLine{477     >> \{}
\DoxyCodeLine{478   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{479   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{480     \textcolor{keywordflow}{return} ctx.begin();}
\DoxyCodeLine{481   \}}
\DoxyCodeLine{482 }
\DoxyCodeLine{483   \textcolor{keyword}{template} <}
\DoxyCodeLine{484       \textcolor{keyword}{typename} FormatContext, \textcolor{keyword}{typename} U,}
\DoxyCodeLine{485       FMT\_ENABLE\_IF(}
\DoxyCodeLine{486           std::is\_same<U, conditional\_t<detail::has\_const\_begin\_end<T>::value,}
\DoxyCodeLine{487                                         \textcolor{keyword}{const} T, T>>::value)>}
\DoxyCodeLine{488   \textcolor{keyword}{auto} format(U\& map, FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{489     \textcolor{keyword}{auto} out = ctx.out();}
\DoxyCodeLine{490     *out++ = \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{491     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{492     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& item : map) \{}
\DoxyCodeLine{493       \textcolor{keywordflow}{if} (i > 0) out = detail::write\_delimiter(out);}
\DoxyCodeLine{494       out = detail::write\_range\_entry<Char>(out, item.first);}
\DoxyCodeLine{495       *out++ = \textcolor{charliteral}{':'};}
\DoxyCodeLine{496       *out++ = \textcolor{charliteral}{' '};}
\DoxyCodeLine{497       out = detail::write\_range\_entry<Char>(out, item.second);}
\DoxyCodeLine{498       ++i;}
\DoxyCodeLine{499     \}}
\DoxyCodeLine{500     *out++ = \textcolor{charliteral}{'\}'};}
\DoxyCodeLine{501     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{502   \}}
\DoxyCodeLine{503 \};}
\DoxyCodeLine{504 }
\DoxyCodeLine{505 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... T> \textcolor{keyword}{struct }tuple\_join\_view : detail::view \{}
\DoxyCodeLine{506   \textcolor{keyword}{const} std::tuple<T...>\& tuple;}
\DoxyCodeLine{507   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep;}
\DoxyCodeLine{508 }
\DoxyCodeLine{509   tuple\_join\_view(\textcolor{keyword}{const} std::tuple<T...>\& t, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s)}
\DoxyCodeLine{510       : tuple(t), sep\{s\} \{\}}
\DoxyCodeLine{511 \};}
\DoxyCodeLine{512 }
\DoxyCodeLine{513 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... T>}
\DoxyCodeLine{514 \textcolor{keyword}{using }tuple\_arg\_join = tuple\_join\_view<Char, T...>;}
\DoxyCodeLine{515 }
\DoxyCodeLine{516 \textcolor{comment}{// Define FMT\_TUPLE\_JOIN\_SPECIFIERS to enable experimental format specifiers}}
\DoxyCodeLine{517 \textcolor{comment}{// support in tuple\_join. It is disabled by default because of issues with}}
\DoxyCodeLine{518 \textcolor{comment}{// the dynamic width and precision.}}
\DoxyCodeLine{519 \textcolor{preprocessor}{\#ifndef FMT\_TUPLE\_JOIN\_SPECIFIERS}}
\DoxyCodeLine{520 \textcolor{preprocessor}{\#  define FMT\_TUPLE\_JOIN\_SPECIFIERS 0}}
\DoxyCodeLine{521 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{522 }
\DoxyCodeLine{523 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... T>}
\DoxyCodeLine{524 \textcolor{keyword}{struct }formatter<tuple\_join\_view<Char, T...>, Char> \{}
\DoxyCodeLine{525   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{526   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{527     \textcolor{keywordflow}{return} do\_parse(ctx, std::integral\_constant<\textcolor{keywordtype}{size\_t}, \textcolor{keyword}{sizeof}...(T)>());}
\DoxyCodeLine{528   \}}
\DoxyCodeLine{529 }
\DoxyCodeLine{530   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{531   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} tuple\_join\_view<Char, T...>\& value,}
\DoxyCodeLine{532               FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{typename} FormatContext::iterator \{}
\DoxyCodeLine{533     \textcolor{keywordflow}{return} do\_format(value, ctx,}
\DoxyCodeLine{534                      std::integral\_constant<\textcolor{keywordtype}{size\_t}, \textcolor{keyword}{sizeof}...(T)>());}
\DoxyCodeLine{535   \}}
\DoxyCodeLine{536 }
\DoxyCodeLine{537  \textcolor{keyword}{private}:}
\DoxyCodeLine{538   std::tuple<formatter<typename std::decay<T>::type, Char>...> formatters\_;}
\DoxyCodeLine{539 }
\DoxyCodeLine{540   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{541   FMT\_CONSTEXPR \textcolor{keyword}{auto} do\_parse(ParseContext\& ctx,}
\DoxyCodeLine{542                               std::integral\_constant<size\_t, 0>)}
\DoxyCodeLine{543       -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{544     \textcolor{keywordflow}{return} ctx.begin();}
\DoxyCodeLine{545   \}}
\DoxyCodeLine{546 }
\DoxyCodeLine{547   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{548   FMT\_CONSTEXPR \textcolor{keyword}{auto} do\_parse(ParseContext\& ctx,}
\DoxyCodeLine{549                               std::integral\_constant<size\_t, N>)}
\DoxyCodeLine{550       -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{551     \textcolor{keyword}{auto} end = ctx.begin();}
\DoxyCodeLine{552 \textcolor{preprocessor}{\#if FMT\_TUPLE\_JOIN\_SPECIFIERS}}
\DoxyCodeLine{553     end = std::get<\textcolor{keyword}{sizeof}...(T) -\/ N>(formatters\_).parse(ctx);}
\DoxyCodeLine{554     \textcolor{keywordflow}{if} (N > 1) \{}
\DoxyCodeLine{555       \textcolor{keyword}{auto} end1 = do\_parse(ctx, std::integral\_constant<size\_t, N -\/ 1>());}
\DoxyCodeLine{556       \textcolor{keywordflow}{if} (end != end1)}
\DoxyCodeLine{557         FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}incompatible format specs for tuple elements"{}}));}
\DoxyCodeLine{558     \}}
\DoxyCodeLine{559 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{560     \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{561   \}}
\DoxyCodeLine{562 }
\DoxyCodeLine{563   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{564   \textcolor{keyword}{auto} do\_format(\textcolor{keyword}{const} tuple\_join\_view<Char, T...>\&, FormatContext\& ctx,}
\DoxyCodeLine{565                  std::integral\_constant<size\_t, 0>) \textcolor{keyword}{const} -\/>}
\DoxyCodeLine{566       \textcolor{keyword}{typename} FormatContext::iterator \{}
\DoxyCodeLine{567     \textcolor{keywordflow}{return} ctx.out();}
\DoxyCodeLine{568   \}}
\DoxyCodeLine{569 }
\DoxyCodeLine{570   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{571   \textcolor{keyword}{auto} do\_format(\textcolor{keyword}{const} tuple\_join\_view<Char, T...>\& value, FormatContext\& ctx,}
\DoxyCodeLine{572                  std::integral\_constant<size\_t, N>) \textcolor{keyword}{const} -\/>}
\DoxyCodeLine{573       \textcolor{keyword}{typename} FormatContext::iterator \{}
\DoxyCodeLine{574     \textcolor{keyword}{auto} out = std::get<\textcolor{keyword}{sizeof}...(T) -\/ N>(formatters\_)}
\DoxyCodeLine{575                    .format(std::get<\textcolor{keyword}{sizeof}...(T) -\/ N>(value.tuple), ctx);}
\DoxyCodeLine{576     \textcolor{keywordflow}{if} (N > 1) \{}
\DoxyCodeLine{577       out = std::copy(value.sep.begin(), value.sep.end(), out);}
\DoxyCodeLine{578       ctx.advance\_to(out);}
\DoxyCodeLine{579       \textcolor{keywordflow}{return} do\_format(value, ctx, std::integral\_constant<size\_t, N -\/ 1>());}
\DoxyCodeLine{580     \}}
\DoxyCodeLine{581     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{582   \}}
\DoxyCodeLine{583 \};}
\DoxyCodeLine{584 }
\DoxyCodeLine{585 FMT\_MODULE\_EXPORT\_BEGIN}
\DoxyCodeLine{586 }
\DoxyCodeLine{598 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{599 FMT\_CONSTEXPR \textcolor{keyword}{auto} join(\textcolor{keyword}{const} std::tuple<T...>\& tuple, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep)}
\DoxyCodeLine{600     -\/> tuple\_join\_view<char, T...> \{}
\DoxyCodeLine{601   \textcolor{keywordflow}{return} \{tuple, sep\};}
\DoxyCodeLine{602 \}}
\DoxyCodeLine{603 }
\DoxyCodeLine{604 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{605 FMT\_CONSTEXPR \textcolor{keyword}{auto} join(\textcolor{keyword}{const} std::tuple<T...>\& tuple,}
\DoxyCodeLine{606                         \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<wchar\_t>}} sep)}
\DoxyCodeLine{607     -\/> tuple\_join\_view<wchar\_t, T...> \{}
\DoxyCodeLine{608   \textcolor{keywordflow}{return} \{tuple, sep\};}
\DoxyCodeLine{609 \}}
\DoxyCodeLine{610 }
\DoxyCodeLine{622 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{623 \textcolor{keyword}{auto} join(std::initializer\_list<T> list, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep)}
\DoxyCodeLine{624     -\/> join\_view<const T*, const T*> \{}
\DoxyCodeLine{625   \textcolor{keywordflow}{return} join(std::begin(list), std::end(list), sep);}
\DoxyCodeLine{626 \}}
\DoxyCodeLine{627 }
\DoxyCodeLine{628 FMT\_MODULE\_EXPORT\_END}
\DoxyCodeLine{629 FMT\_END\_NAMESPACE}
\DoxyCodeLine{630 }
\DoxyCodeLine{631 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_RANGES\_H\_}}

\end{DoxyCode}

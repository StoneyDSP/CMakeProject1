\hypertarget{compile_8h_source}{}\doxysection{compile.\+h}
\label{compile_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/compile.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/compile.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ experimental format string compilation}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich and fmt contributors}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_COMPILE\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_COMPILE\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{14 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{17 \textcolor{keyword}{inline} counting\_iterator copy\_str(InputIt begin, InputIt end,}
\DoxyCodeLine{18                                   counting\_iterator it) \{}
\DoxyCodeLine{19   \textcolor{keywordflow}{return} it + (end -\/ begin);}
\DoxyCodeLine{20 \}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt> \textcolor{keyword}{class }truncating\_iterator\_base \{}
\DoxyCodeLine{23  \textcolor{keyword}{protected}:}
\DoxyCodeLine{24   OutputIt out\_;}
\DoxyCodeLine{25   \textcolor{keywordtype}{size\_t} limit\_;}
\DoxyCodeLine{26   \textcolor{keywordtype}{size\_t} count\_ = 0;}
\DoxyCodeLine{27 }
\DoxyCodeLine{28   truncating\_iterator\_base() : out\_(), limit\_(0) \{\}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30   truncating\_iterator\_base(OutputIt out, \textcolor{keywordtype}{size\_t} limit)}
\DoxyCodeLine{31       : out\_(out), limit\_(limit) \{\}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33  \textcolor{keyword}{public}:}
\DoxyCodeLine{34   \textcolor{keyword}{using }iterator\_category = std::output\_iterator\_tag;}
\DoxyCodeLine{35   \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} std::iterator\_traits<OutputIt>::value\_type;}
\DoxyCodeLine{36   \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{37   \textcolor{keyword}{using }pointer = void;}
\DoxyCodeLine{38   \textcolor{keyword}{using }reference = void;}
\DoxyCodeLine{39   FMT\_UNCHECKED\_ITERATOR(truncating\_iterator\_base);}
\DoxyCodeLine{40 }
\DoxyCodeLine{41   OutputIt base()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{42   \textcolor{keywordtype}{size\_t} count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{43 \};}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{comment}{// An output iterator that truncates the output and counts the number of objects}}
\DoxyCodeLine{46 \textcolor{comment}{// written to it.}}
\DoxyCodeLine{47 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{48           \textcolor{keyword}{typename} Enable = \textcolor{keyword}{typename} std::is\_void<}
\DoxyCodeLine{49               \textcolor{keyword}{typename} std::iterator\_traits<OutputIt>::value\_type>::type>}
\DoxyCodeLine{50 \textcolor{keyword}{class }truncating\_iterator;}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{53 \textcolor{keyword}{class }truncating\_iterator<OutputIt, std::false\_type>}
\DoxyCodeLine{54     : \textcolor{keyword}{public} truncating\_iterator\_base<OutputIt> \{}
\DoxyCodeLine{55   \textcolor{keyword}{mutable} \textcolor{keyword}{typename} truncating\_iterator\_base<OutputIt>::value\_type blackhole\_;}
\DoxyCodeLine{56 }
\DoxyCodeLine{57  \textcolor{keyword}{public}:}
\DoxyCodeLine{58   \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} truncating\_iterator\_base<OutputIt>::value\_type;}
\DoxyCodeLine{59 }
\DoxyCodeLine{60   truncating\_iterator() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{61 }
\DoxyCodeLine{62   truncating\_iterator(OutputIt out, \textcolor{keywordtype}{size\_t} limit)}
\DoxyCodeLine{63       : truncating\_iterator\_base<OutputIt>(out, limit) \{\}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65   truncating\_iterator\& operator++() \{}
\DoxyCodeLine{66     \textcolor{keywordflow}{if} (this-\/>count\_++ < this-\/>limit\_) ++this-\/>out\_;}
\DoxyCodeLine{67     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{68   \}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70   truncating\_iterator operator++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{71     \textcolor{keyword}{auto} it = *\textcolor{keyword}{this};}
\DoxyCodeLine{72     ++*\textcolor{keyword}{this};}
\DoxyCodeLine{73     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{74   \}}
\DoxyCodeLine{75 }
\DoxyCodeLine{76   value\_type\& operator*()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{77     \textcolor{keywordflow}{return} this-\/>count\_ < this-\/>limit\_ ? *this-\/>out\_ : blackhole\_;}
\DoxyCodeLine{78   \}}
\DoxyCodeLine{79 \};}
\DoxyCodeLine{80 }
\DoxyCodeLine{81 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{82 \textcolor{keyword}{class }truncating\_iterator<OutputIt, std::true\_type>}
\DoxyCodeLine{83     : \textcolor{keyword}{public} truncating\_iterator\_base<OutputIt> \{}
\DoxyCodeLine{84  \textcolor{keyword}{public}:}
\DoxyCodeLine{85   truncating\_iterator() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{86 }
\DoxyCodeLine{87   truncating\_iterator(OutputIt out, \textcolor{keywordtype}{size\_t} limit)}
\DoxyCodeLine{88       : truncating\_iterator\_base<OutputIt>(out, limit) \{\}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> truncating\_iterator\& operator=(T val) \{}
\DoxyCodeLine{91     \textcolor{keywordflow}{if} (this-\/>count\_++ < this-\/>limit\_) *this-\/>out\_++ = val;}
\DoxyCodeLine{92     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{93   \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95   truncating\_iterator\& operator++() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{96   truncating\_iterator\& operator++(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{97   truncating\_iterator\& operator*() \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{98 \};}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{comment}{// A compile-\/time string which is compiled into fast formatting code.}}
\DoxyCodeLine{101 \textcolor{keyword}{class }compiled\_string \{\};}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{104 \textcolor{keyword}{struct }is\_compiled\_string : std::is\_base\_of<compiled\_string, S> \{\};}
\DoxyCodeLine{105 }
\DoxyCodeLine{119 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#  define FMT\_COMPILE(s) \(\backslash\)}}
\DoxyCodeLine{121 \textcolor{preprocessor}{    FMT\_STRING\_IMPL(s, fmt::detail::compiled\_string, explicit)}}
\DoxyCodeLine{122 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#  define FMT\_COMPILE(s) FMT\_STRING(s)}}
\DoxyCodeLine{124 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{127 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{128           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{129 \textcolor{keyword}{struct }udl\_compiled\_string : compiled\_string \{}
\DoxyCodeLine{130   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{131   \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{132     \textcolor{keywordflow}{return} \{Str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}, N -\/ 1\};}
\DoxyCodeLine{133   \}}
\DoxyCodeLine{134 \};}
\DoxyCodeLine{135 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Tail>}
\DoxyCodeLine{138 \textcolor{keyword}{const} T\& first(\textcolor{keyword}{const} T\& value, \textcolor{keyword}{const} Tail\&...) \{}
\DoxyCodeLine{139   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{140 \}}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{143 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args> \textcolor{keyword}{struct }type\_list \{\};}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{comment}{// Returns a reference to the argument at index N from [first, rest...].}}
\DoxyCodeLine{146 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{147 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto}\& get([[maybe\_unused]] \textcolor{keyword}{const} T\& first,}
\DoxyCodeLine{148                           [[maybe\_unused]] \textcolor{keyword}{const} Args\&... rest) \{}
\DoxyCodeLine{149   \textcolor{keyword}{static\_assert}(N < 1 + \textcolor{keyword}{sizeof}...(Args), \textcolor{stringliteral}{"{}index is out of bounds"{}});}
\DoxyCodeLine{150   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (N == 0)}
\DoxyCodeLine{151     \textcolor{keywordflow}{return} first;}
\DoxyCodeLine{152   \textcolor{keywordflow}{else}}
\DoxyCodeLine{153     \textcolor{keywordflow}{return} detail::get<N -\/ 1>(rest...);}
\DoxyCodeLine{154 \}}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{157 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} get\_arg\_index\_by\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name,}
\DoxyCodeLine{158                                     type\_list<Args...>) \{}
\DoxyCodeLine{159   \textcolor{keywordflow}{return} get\_arg\_index\_by\_name<Args...>(name);}
\DoxyCodeLine{160 \}}
\DoxyCodeLine{161 }
\DoxyCodeLine{162 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename}> \textcolor{keyword}{struct }get\_type\_impl;}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename}... Args> \textcolor{keyword}{struct }get\_type\_impl<N, type\_list<Args...>> \{}
\DoxyCodeLine{165   \textcolor{keyword}{using }type =}
\DoxyCodeLine{166       remove\_cvref\_t<decltype(detail::get<N>(std::declval<Args>()...))>;}
\DoxyCodeLine{167 \};}
\DoxyCodeLine{168 }
\DoxyCodeLine{169 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{170 \textcolor{keyword}{using }get\_type = \textcolor{keyword}{typename} get\_type\_impl<N, T>::type;}
\DoxyCodeLine{171 }
\DoxyCodeLine{172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_compiled\_format : std::false\_type \{\};}
\DoxyCodeLine{173 }
\DoxyCodeLine{174 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }text \{}
\DoxyCodeLine{175   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} data;}
\DoxyCodeLine{176   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{177 }
\DoxyCodeLine{178   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{179   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} Args\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{180     \textcolor{keywordflow}{return} write<Char>(out, data);}
\DoxyCodeLine{181   \}}
\DoxyCodeLine{182 \};}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{185 \textcolor{keyword}{struct }is\_compiled\_format<text<Char>> : std::true\_type \{\};}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{188 \textcolor{keyword}{constexpr} text<Char> make\_text(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s, \textcolor{keywordtype}{size\_t} pos,}
\DoxyCodeLine{189                                \textcolor{keywordtype}{size\_t} size) \{}
\DoxyCodeLine{190   \textcolor{keywordflow}{return} \{\{\&s[pos], size\}\};}
\DoxyCodeLine{191 \}}
\DoxyCodeLine{192 }
\DoxyCodeLine{193 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }code\_unit \{}
\DoxyCodeLine{194   Char value;}
\DoxyCodeLine{195   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{196 }
\DoxyCodeLine{197   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{198   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} Args\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{199     \textcolor{keywordflow}{return} write<Char>(out, value);}
\DoxyCodeLine{200   \}}
\DoxyCodeLine{201 \};}
\DoxyCodeLine{202 }
\DoxyCodeLine{203 \textcolor{comment}{// This ensures that the argument type is convertible to `const T\&`.}}
\DoxyCodeLine{204 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{205 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} T\& get\_arg\_checked(\textcolor{keyword}{const} Args\&... args) \{}
\DoxyCodeLine{206   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& arg = detail::get<N>(args...);}
\DoxyCodeLine{207   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::is\_named\_arg<remove\_cvref\_t<\textcolor{keyword}{decltype}(arg)>>()) \{}
\DoxyCodeLine{208     \textcolor{keywordflow}{return} arg.value;}
\DoxyCodeLine{209   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{210     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{211   \}}
\DoxyCodeLine{212 \}}
\DoxyCodeLine{213 }
\DoxyCodeLine{214 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{215 \textcolor{keyword}{struct }is\_compiled\_format<code\_unit<Char>> : std::true\_type \{\};}
\DoxyCodeLine{216 }
\DoxyCodeLine{217 \textcolor{comment}{// A replacement field that refers to argument N.}}
\DoxyCodeLine{218 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N> \textcolor{keyword}{struct }field \{}
\DoxyCodeLine{219   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{220 }
\DoxyCodeLine{221   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{222   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{223     \textcolor{keywordflow}{return} write<Char>(out, get\_arg\_checked<T, N>(args...));}
\DoxyCodeLine{224   \}}
\DoxyCodeLine{225 \};}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N>}
\DoxyCodeLine{228 \textcolor{keyword}{struct }is\_compiled\_format<field<Char, T, N>> : std::true\_type \{\};}
\DoxyCodeLine{229 }
\DoxyCodeLine{230 \textcolor{comment}{// A replacement field that refers to argument with name.}}
\DoxyCodeLine{231 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }runtime\_named\_field \{}
\DoxyCodeLine{232   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{233   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name;}
\DoxyCodeLine{234 }
\DoxyCodeLine{235   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{236   \textcolor{keyword}{constexpr} \textcolor{keyword}{static} \textcolor{keywordtype}{bool} try\_format\_argument(}
\DoxyCodeLine{237       OutputIt\& out,}
\DoxyCodeLine{238       \textcolor{comment}{// [[maybe\_unused]] due to unused-\/but-\/set-\/parameter warning in GCC 7,8,9}}
\DoxyCodeLine{239       [[maybe\_unused]] \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} arg\_name, \textcolor{keyword}{const} T\& arg) \{}
\DoxyCodeLine{240     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_named\_arg<typename std::remove\_cv<T>::type>::value) \{}
\DoxyCodeLine{241       \textcolor{keywordflow}{if} (arg\_name == arg.name) \{}
\DoxyCodeLine{242         out = write<Char>(out, arg.value);}
\DoxyCodeLine{243         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{244       \}}
\DoxyCodeLine{245     \}}
\DoxyCodeLine{246     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{247   \}}
\DoxyCodeLine{248 }
\DoxyCodeLine{249   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{250   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{251     \textcolor{keywordtype}{bool} found = (try\_format\_argument(out, name, args) || ...);}
\DoxyCodeLine{252     \textcolor{keywordflow}{if} (!found) \{}
\DoxyCodeLine{253       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}argument with specified name is not found"{}}));}
\DoxyCodeLine{254     \}}
\DoxyCodeLine{255     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{256   \}}
\DoxyCodeLine{257 \};}
\DoxyCodeLine{258 }
\DoxyCodeLine{259 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{260 \textcolor{keyword}{struct }is\_compiled\_format<runtime\_named\_field<Char>> : std::true\_type \{\};}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{comment}{// A replacement field that refers to argument N and has format specifiers.}}
\DoxyCodeLine{263 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N> \textcolor{keyword}{struct }spec\_field \{}
\DoxyCodeLine{264   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{265   formatter<T, Char> fmt;}
\DoxyCodeLine{266 }
\DoxyCodeLine{267   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{268   \textcolor{keyword}{constexpr} FMT\_INLINE OutputIt format(OutputIt out,}
\DoxyCodeLine{269                                        \textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{270     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs =}
\DoxyCodeLine{271         fmt::make\_format\_args<basic\_format\_context<OutputIt, Char>>(args...);}
\DoxyCodeLine{272     basic\_format\_context<OutputIt, Char> ctx(out, vargs);}
\DoxyCodeLine{273     \textcolor{keywordflow}{return} fmt.format(get\_arg\_checked<T, N>(args...), ctx);}
\DoxyCodeLine{274   \}}
\DoxyCodeLine{275 \};}
\DoxyCodeLine{276 }
\DoxyCodeLine{277 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N>}
\DoxyCodeLine{278 \textcolor{keyword}{struct }is\_compiled\_format<spec\_field<Char, T, N>> : std::true\_type \{\};}
\DoxyCodeLine{279 }
\DoxyCodeLine{280 \textcolor{keyword}{template} <\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} R> \textcolor{keyword}{struct }concat \{}
\DoxyCodeLine{281   L lhs;}
\DoxyCodeLine{282   R rhs;}
\DoxyCodeLine{283   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} L::char\_type;}
\DoxyCodeLine{284 }
\DoxyCodeLine{285   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{286   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} Args\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{287     out = lhs.format(out, args...);}
\DoxyCodeLine{288     \textcolor{keywordflow}{return} rhs.format(out, args...);}
\DoxyCodeLine{289   \}}
\DoxyCodeLine{290 \};}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{template} <\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} R>}
\DoxyCodeLine{293 \textcolor{keyword}{struct }is\_compiled\_format<concat<L, R>> : std::true\_type \{\};}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{keyword}{template} <\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} R>}
\DoxyCodeLine{296 \textcolor{keyword}{constexpr} concat<L, R> make\_concat(L lhs, R rhs) \{}
\DoxyCodeLine{297   \textcolor{keywordflow}{return} \{lhs, rhs\};}
\DoxyCodeLine{298 \}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300 \textcolor{keyword}{struct }unknown\_format \{\};}
\DoxyCodeLine{301 }
\DoxyCodeLine{302 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{303 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} parse\_text(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str, \textcolor{keywordtype}{size\_t} pos) \{}
\DoxyCodeLine{304   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} size = str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}(); pos != size; ++pos) \{}
\DoxyCodeLine{305     \textcolor{keywordflow}{if} (str[pos] == \textcolor{charliteral}{'\{'} || str[pos] == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{break};}
\DoxyCodeLine{306   \}}
\DoxyCodeLine{307   \textcolor{keywordflow}{return} pos;}
\DoxyCodeLine{308 \}}
\DoxyCodeLine{309 }
\DoxyCodeLine{310 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} POS, \textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{311 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_format\_string(S format\_str);}
\DoxyCodeLine{312 }
\DoxyCodeLine{313 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} POS, \textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{314 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} parse\_tail(T head, S format\_str) \{}
\DoxyCodeLine{315   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (POS !=}
\DoxyCodeLine{316                 \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(format\_str).\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()) \{}
\DoxyCodeLine{317     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} tail = compile\_format\_string<Args, POS, ID>(format\_str);}
\DoxyCodeLine{318     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<remove\_cvref\_t<\textcolor{keyword}{decltype}(tail)>,}
\DoxyCodeLine{319                                unknown\_format>())}
\DoxyCodeLine{320       \textcolor{keywordflow}{return} tail;}
\DoxyCodeLine{321     \textcolor{keywordflow}{else}}
\DoxyCodeLine{322       \textcolor{keywordflow}{return} make\_concat(head, tail);}
\DoxyCodeLine{323   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{324     \textcolor{keywordflow}{return} head;}
\DoxyCodeLine{325   \}}
\DoxyCodeLine{326 \}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }parse\_specs\_result \{}
\DoxyCodeLine{329   formatter<T, Char> fmt;}
\DoxyCodeLine{330   \textcolor{keywordtype}{size\_t} end;}
\DoxyCodeLine{331   \textcolor{keywordtype}{int} next\_arg\_id;}
\DoxyCodeLine{332 \};}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} manual\_indexing\_id = -\/1;}
\DoxyCodeLine{335 }
\DoxyCodeLine{336 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{337 \textcolor{keyword}{constexpr} parse\_specs\_result<T, Char> parse\_specs(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str,}
\DoxyCodeLine{338                                                   \textcolor{keywordtype}{size\_t} pos, \textcolor{keywordtype}{int} next\_arg\_id) \{}
\DoxyCodeLine{339   str.remove\_prefix(pos);}
\DoxyCodeLine{340   \textcolor{keyword}{auto} ctx = compile\_parse\_context<Char>(str, max\_value<int>(), \textcolor{keyword}{nullptr}, \{\},}
\DoxyCodeLine{341                                          next\_arg\_id);}
\DoxyCodeLine{342   \textcolor{keyword}{auto} f = formatter<T, Char>();}
\DoxyCodeLine{343   \textcolor{keyword}{auto} end = f.parse(ctx);}
\DoxyCodeLine{344   \textcolor{keywordflow}{return} \{f, pos + fmt::detail::to\_unsigned(end -\/ str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}()) + 1,}
\DoxyCodeLine{345           next\_arg\_id == 0 ? manual\_indexing\_id : ctx.next\_arg\_id()\};}
\DoxyCodeLine{346 \}}
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }arg\_id\_handler \{}
\DoxyCodeLine{349   arg\_ref<Char> arg\_id;}
\DoxyCodeLine{350 }
\DoxyCodeLine{351   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} operator()() \{}
\DoxyCodeLine{352     FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}handler cannot be used with automatic indexing"{}});}
\DoxyCodeLine{353     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{354   \}}
\DoxyCodeLine{355   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} operator()(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{356     arg\_id = arg\_ref<Char>(\textcolor{keywordtype}{id});}
\DoxyCodeLine{357     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{358   \}}
\DoxyCodeLine{359   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{360     arg\_id = arg\_ref<Char>(\textcolor{keywordtype}{id});}
\DoxyCodeLine{361     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{362   \}}
\DoxyCodeLine{363 }
\DoxyCodeLine{364   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{365     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(message));}
\DoxyCodeLine{366   \}}
\DoxyCodeLine{367 \};}
\DoxyCodeLine{368 }
\DoxyCodeLine{369 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }parse\_arg\_id\_result \{}
\DoxyCodeLine{370   arg\_ref<Char> arg\_id;}
\DoxyCodeLine{371   \textcolor{keyword}{const} Char* arg\_id\_end;}
\DoxyCodeLine{372 \};}
\DoxyCodeLine{373 }
\DoxyCodeLine{374 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{375 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} parse\_arg\_id(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end) \{}
\DoxyCodeLine{376   \textcolor{keyword}{auto} handler = arg\_id\_handler<Char>\{arg\_ref<Char>\{\}\};}
\DoxyCodeLine{377   \textcolor{keyword}{auto} arg\_id\_end = parse\_arg\_id(begin, end, handler);}
\DoxyCodeLine{378   \textcolor{keywordflow}{return} parse\_arg\_id\_result<Char>\{handler.arg\_id, arg\_id\_end\};}
\DoxyCodeLine{379 \}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }field\_type \{}
\DoxyCodeLine{382   \textcolor{keyword}{using }type = remove\_cvref\_t<T>;}
\DoxyCodeLine{383 \};}
\DoxyCodeLine{384 }
\DoxyCodeLine{385 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{386 \textcolor{keyword}{struct }field\_type<T, enable\_if\_t<detail::is\_named\_arg<T>::value>> \{}
\DoxyCodeLine{387   \textcolor{keyword}{using }type = remove\_cvref\_t<\textcolor{keyword}{decltype}(T::value)>;}
\DoxyCodeLine{388 \};}
\DoxyCodeLine{389 }
\DoxyCodeLine{390 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} END\_POS, \textcolor{keywordtype}{int} ARG\_INDEX, \textcolor{keywordtype}{int} NEXT\_ID,}
\DoxyCodeLine{391           \textcolor{keyword}{typename} S>}
\DoxyCodeLine{392 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} parse\_replacement\_field\_then\_tail(S format\_str) \{}
\DoxyCodeLine{393   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} S::char\_type;}
\DoxyCodeLine{394   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(format\_str);}
\DoxyCodeLine{395   \textcolor{keyword}{constexpr} char\_type c = END\_POS != str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() ? str[END\_POS] : char\_type();}
\DoxyCodeLine{396   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{397     \textcolor{keywordflow}{return} parse\_tail<Args, END\_POS + 1, NEXT\_ID>(}
\DoxyCodeLine{398         field<char\_type, \textcolor{keyword}{typename} field\_type<T>::type, ARG\_INDEX>(),}
\DoxyCodeLine{399         format\_str);}
\DoxyCodeLine{400   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{401     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} result = parse\_specs<typename field\_type<T>::type>(}
\DoxyCodeLine{402         str, END\_POS + 1, NEXT\_ID == manual\_indexing\_id ? 0 : NEXT\_ID);}
\DoxyCodeLine{403     \textcolor{keywordflow}{return} parse\_tail<Args, result.end, result.next\_arg\_id>(}
\DoxyCodeLine{404         spec\_field<char\_type, typename field\_type<T>::type, ARG\_INDEX>\{}
\DoxyCodeLine{405             result.fmt\},}
\DoxyCodeLine{406         format\_str);}
\DoxyCodeLine{407   \}}
\DoxyCodeLine{408 \}}
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \textcolor{comment}{// Compiles a non-\/empty format string and returns the compiled representation}}
\DoxyCodeLine{411 \textcolor{comment}{// or unknown\_format() on unrecognized input.}}
\DoxyCodeLine{412 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} POS, \textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{413 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_format\_string(S format\_str) \{}
\DoxyCodeLine{414   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} S::char\_type;}
\DoxyCodeLine{415   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(format\_str);}
\DoxyCodeLine{416   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS] == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{417     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (POS + 1 == str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}())}
\DoxyCodeLine{418       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}unmatched '\{' in format string"{}}));}
\DoxyCodeLine{419     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS + 1] == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{420       \textcolor{keywordflow}{return} parse\_tail<Args, POS + 2, ID>(make\_text(str, POS, 1), format\_str);}
\DoxyCodeLine{421     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS + 1] == \textcolor{charliteral}{'\}'} || str[POS + 1] == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{422       \textcolor{keyword}{static\_assert}(ID != manual\_indexing\_id,}
\DoxyCodeLine{423                     \textcolor{stringliteral}{"{}cannot switch from manual to automatic argument indexing"{}});}
\DoxyCodeLine{424       \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} next\_id =}
\DoxyCodeLine{425           ID != manual\_indexing\_id ? ID + 1 : manual\_indexing\_id;}
\DoxyCodeLine{426       \textcolor{keywordflow}{return} parse\_replacement\_field\_then\_tail<get\_type<ID, Args>, Args,}
\DoxyCodeLine{427                                                POS + 1, ID, next\_id>(}
\DoxyCodeLine{428           format\_str);}
\DoxyCodeLine{429     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{430       \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_id\_result =}
\DoxyCodeLine{431           parse\_arg\_id<ID>(str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}() + POS + 1, str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}() + str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}());}
\DoxyCodeLine{432       \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_id\_end\_pos = arg\_id\_result.arg\_id\_end -\/ str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{433       \textcolor{keyword}{constexpr} char\_type c =}
\DoxyCodeLine{434           arg\_id\_end\_pos != str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() ? str[arg\_id\_end\_pos] : char\_type();}
\DoxyCodeLine{435       \textcolor{keyword}{static\_assert}(c == \textcolor{charliteral}{'\}'} || c == \textcolor{charliteral}{':'}, \textcolor{stringliteral}{"{}missing '\}' in format string"{}});}
\DoxyCodeLine{436       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (arg\_id\_result.arg\_id.kind == arg\_id\_kind::index) \{}
\DoxyCodeLine{437         \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{438             ID == manual\_indexing\_id || ID == 0,}
\DoxyCodeLine{439             \textcolor{stringliteral}{"{}cannot switch from automatic to manual argument indexing"{}});}
\DoxyCodeLine{440         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_index = arg\_id\_result.arg\_id.val.index;}
\DoxyCodeLine{441         \textcolor{keywordflow}{return} parse\_replacement\_field\_then\_tail<get\_type<arg\_index, Args>,}
\DoxyCodeLine{442                                                  Args, arg\_id\_end\_pos,}
\DoxyCodeLine{443                                                  arg\_index, manual\_indexing\_id>(}
\DoxyCodeLine{444             format\_str);}
\DoxyCodeLine{445       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (arg\_id\_result.arg\_id.kind == arg\_id\_kind::name) \{}
\DoxyCodeLine{446         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_index =}
\DoxyCodeLine{447             get\_arg\_index\_by\_name(arg\_id\_result.arg\_id.val.name, Args\{\});}
\DoxyCodeLine{448         \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (arg\_index != invalid\_arg\_index) \{}
\DoxyCodeLine{449           \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} next\_id =}
\DoxyCodeLine{450               ID != manual\_indexing\_id ? ID + 1 : manual\_indexing\_id;}
\DoxyCodeLine{451           \textcolor{keywordflow}{return} parse\_replacement\_field\_then\_tail<}
\DoxyCodeLine{452               \textcolor{keyword}{decltype}(get\_type<arg\_index, Args>::value), Args, arg\_id\_end\_pos,}
\DoxyCodeLine{453               arg\_index, next\_id>(format\_str);}
\DoxyCodeLine{454         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{455           \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{456             \textcolor{keywordflow}{return} parse\_tail<Args, arg\_id\_end\_pos + 1, ID>(}
\DoxyCodeLine{457                 runtime\_named\_field<char\_type>\{arg\_id\_result.arg\_id.val.name\},}
\DoxyCodeLine{458                 format\_str);}
\DoxyCodeLine{459           \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{460             \textcolor{keywordflow}{return} unknown\_format();  \textcolor{comment}{// no type info for specs parsing}}
\DoxyCodeLine{461           \}}
\DoxyCodeLine{462         \}}
\DoxyCodeLine{463       \}}
\DoxyCodeLine{464     \}}
\DoxyCodeLine{465   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS] == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{466     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (POS + 1 == str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}())}
\DoxyCodeLine{467       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}}));}
\DoxyCodeLine{468     \textcolor{keywordflow}{return} parse\_tail<Args, POS + 2, ID>(make\_text(str, POS, 1), format\_str);}
\DoxyCodeLine{469   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{470     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} end = parse\_text(str, POS + 1);}
\DoxyCodeLine{471     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (end -\/ POS > 1) \{}
\DoxyCodeLine{472       \textcolor{keywordflow}{return} parse\_tail<Args, end, ID>(make\_text(str, POS, end -\/ POS),}
\DoxyCodeLine{473                                        format\_str);}
\DoxyCodeLine{474     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{475       \textcolor{keywordflow}{return} parse\_tail<Args, end, ID>(code\_unit<char\_type>\{str[POS]\},}
\DoxyCodeLine{476                                        format\_str);}
\DoxyCodeLine{477     \}}
\DoxyCodeLine{478   \}}
\DoxyCodeLine{479 \}}
\DoxyCodeLine{480 }
\DoxyCodeLine{481 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} S,}
\DoxyCodeLine{482           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{483 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile(S format\_str) \{}
\DoxyCodeLine{484   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(format\_str);}
\DoxyCodeLine{485   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() == 0) \{}
\DoxyCodeLine{486     \textcolor{keywordflow}{return} detail::make\_text(str, 0, 0);}
\DoxyCodeLine{487   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{488     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} result =}
\DoxyCodeLine{489         detail::compile\_format\_string<detail::type\_list<Args...>, 0, 0>(}
\DoxyCodeLine{490             format\_str);}
\DoxyCodeLine{491     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{492   \}}
\DoxyCodeLine{493 \}}
\DoxyCodeLine{494 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{495 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{496 }
\DoxyCodeLine{497 FMT\_MODULE\_EXPORT\_BEGIN}
\DoxyCodeLine{498 }
\DoxyCodeLine{499 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{500 }
\DoxyCodeLine{501 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CompiledFormat, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{502           \textcolor{keyword}{typename} Char = \textcolor{keyword}{typename} CompiledFormat::char\_type,}
\DoxyCodeLine{503           FMT\_ENABLE\_IF(detail::is\_compiled\_format<CompiledFormat>::value)>}
\DoxyCodeLine{504 FMT\_INLINE std::basic\_string<Char> format(\textcolor{keyword}{const} CompiledFormat\& cf,}
\DoxyCodeLine{505                                           \textcolor{keyword}{const} Args\&... args) \{}
\DoxyCodeLine{506   \textcolor{keyword}{auto} s = std::basic\_string<Char>();}
\DoxyCodeLine{507   cf.format(std::back\_inserter(s), args...);}
\DoxyCodeLine{508   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{509 \}}
\DoxyCodeLine{510 }
\DoxyCodeLine{511 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} CompiledFormat, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{512           FMT\_ENABLE\_IF(detail::is\_compiled\_format<CompiledFormat>::value)>}
\DoxyCodeLine{513 \textcolor{keyword}{constexpr} FMT\_INLINE OutputIt format\_to(OutputIt out, \textcolor{keyword}{const} CompiledFormat\& cf,}
\DoxyCodeLine{514                                         \textcolor{keyword}{const} Args\&... args) \{}
\DoxyCodeLine{515   \textcolor{keywordflow}{return} cf.format(out, args...);}
\DoxyCodeLine{516 \}}
\DoxyCodeLine{517 }
\DoxyCodeLine{518 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{519           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{520 FMT\_INLINE std::basic\_string<typename S::char\_type> format(\textcolor{keyword}{const} S\&,}
\DoxyCodeLine{521                                                            Args\&\&... args) \{}
\DoxyCodeLine{522   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<typename S::char\_type, char>::value) \{}
\DoxyCodeLine{523     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(S());}
\DoxyCodeLine{524     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() == 2 \&\& str[0] == \textcolor{charliteral}{'\{'} \&\& str[1] == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{525       \textcolor{keyword}{const} \textcolor{keyword}{auto}\& first = detail::first(args...);}
\DoxyCodeLine{526       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::is\_named\_arg<}
\DoxyCodeLine{527                         remove\_cvref\_t<\textcolor{keyword}{decltype}(first)>>::value) \{}
\DoxyCodeLine{528         \textcolor{keywordflow}{return} fmt::to\_string(first.value);}
\DoxyCodeLine{529       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{530         \textcolor{keywordflow}{return} fmt::to\_string(first);}
\DoxyCodeLine{531       \}}
\DoxyCodeLine{532     \}}
\DoxyCodeLine{533   \}}
\DoxyCodeLine{534   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compiled = detail::compile<Args...>(S());}
\DoxyCodeLine{535   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<remove\_cvref\_t<\textcolor{keyword}{decltype}(compiled)>,}
\DoxyCodeLine{536                              detail::unknown\_format>()) \{}
\DoxyCodeLine{537     \textcolor{keywordflow}{return} fmt::format(}
\DoxyCodeLine{538         \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}\textcolor{keyword}{>}(S()),}
\DoxyCodeLine{539         std::forward<Args>(args)...);}
\DoxyCodeLine{540   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{541     \textcolor{keywordflow}{return} fmt::format(compiled, std::forward<Args>(args)...);}
\DoxyCodeLine{542   \}}
\DoxyCodeLine{543 \}}
\DoxyCodeLine{544 }
\DoxyCodeLine{545 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{546           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{547 FMT\_CONSTEXPR OutputIt format\_to(OutputIt out, \textcolor{keyword}{const} S\&, Args\&\&... args) \{}
\DoxyCodeLine{548   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compiled = detail::compile<Args...>(S());}
\DoxyCodeLine{549   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<remove\_cvref\_t<\textcolor{keyword}{decltype}(compiled)>,}
\DoxyCodeLine{550                              detail::unknown\_format>()) \{}
\DoxyCodeLine{551     \textcolor{keywordflow}{return} fmt::format\_to(}
\DoxyCodeLine{552         out, \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}\textcolor{keyword}{>}(S()),}
\DoxyCodeLine{553         std::forward<Args>(args)...);}
\DoxyCodeLine{554   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{555     \textcolor{keywordflow}{return} fmt::format\_to(out, compiled, std::forward<Args>(args)...);}
\DoxyCodeLine{556   \}}
\DoxyCodeLine{557 \}}
\DoxyCodeLine{558 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{559 }
\DoxyCodeLine{560 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{561           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{562 format\_to\_n\_result<OutputIt> format\_to\_n(OutputIt out, \textcolor{keywordtype}{size\_t} n,}
\DoxyCodeLine{563                                          \textcolor{keyword}{const} S\& format\_str, Args\&\&... args) \{}
\DoxyCodeLine{564   \textcolor{keyword}{auto} it = fmt::format\_to(detail::truncating\_iterator<OutputIt>(out, n),}
\DoxyCodeLine{565                            format\_str, std::forward<Args>(args)...);}
\DoxyCodeLine{566   \textcolor{keywordflow}{return} \{it.base(), it.count()\};}
\DoxyCodeLine{567 \}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{570           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{571 \textcolor{keywordtype}{size\_t} formatted\_size(\textcolor{keyword}{const} S\& format\_str, \textcolor{keyword}{const} Args\&... args) \{}
\DoxyCodeLine{572   \textcolor{keywordflow}{return} fmt::format\_to(detail::counting\_iterator(), format\_str, args...)}
\DoxyCodeLine{573       .count();}
\DoxyCodeLine{574 \}}
\DoxyCodeLine{575 }
\DoxyCodeLine{576 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{577           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{578 \textcolor{keywordtype}{void} print(std::FILE* f, \textcolor{keyword}{const} S\& format\_str, \textcolor{keyword}{const} Args\&... args) \{}
\DoxyCodeLine{579   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{580   fmt::format\_to(std::back\_inserter(\mbox{\hyperlink{classbuffer}{buffer}}), format\_str, args...);}
\DoxyCodeLine{581   detail::print(f, \{\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()\});}
\DoxyCodeLine{582 \}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{585           FMT\_ENABLE\_IF(detail::is\_compiled\_string<S>::value)>}
\DoxyCodeLine{586 \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} S\& format\_str, \textcolor{keyword}{const} Args\&... args) \{}
\DoxyCodeLine{587   print(stdout, format\_str, args...);}
\DoxyCodeLine{588 \}}
\DoxyCodeLine{589 }
\DoxyCodeLine{590 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{591 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{592 \textcolor{keyword}{template} <detail\_exported::fixed\_\textcolor{keywordtype}{string} Str> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_cf() \{}
\DoxyCodeLine{593   \textcolor{keyword}{using }char\_t = remove\_cvref\_t<\textcolor{keyword}{decltype}(Str.data[0])>;}
\DoxyCodeLine{594   \textcolor{keywordflow}{return} detail::udl\_compiled\_string<char\_t, \textcolor{keyword}{sizeof}(Str.data) / \textcolor{keyword}{sizeof}(char\_t),}
\DoxyCodeLine{595                                      Str>();}
\DoxyCodeLine{596 \}}
\DoxyCodeLine{597 \}  \textcolor{comment}{// namespace literals}}
\DoxyCodeLine{598 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{599 }
\DoxyCodeLine{600 FMT\_MODULE\_EXPORT\_END}
\DoxyCodeLine{601 FMT\_END\_NAMESPACE}
\DoxyCodeLine{602 }
\DoxyCodeLine{603 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_COMPILE\_H\_}}

\end{DoxyCode}

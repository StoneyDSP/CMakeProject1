\hypertarget{format_8h_source}{}\doxysection{format.\+h}
\label{format_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/format.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/format.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{  Formatting library for C++}}
\DoxyCodeLine{3 \textcolor{comment}{}}
\DoxyCodeLine{4 \textcolor{comment}{  Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{5 \textcolor{comment}{}}
\DoxyCodeLine{6 \textcolor{comment}{  Permission is hereby granted, free of charge, to any person obtaining}}
\DoxyCodeLine{7 \textcolor{comment}{  a copy of this software and associated documentation files (the}}
\DoxyCodeLine{8 \textcolor{comment}{  "{}Software"{}), to deal in the Software without restriction, including}}
\DoxyCodeLine{9 \textcolor{comment}{  without limitation the rights to use, copy, modify, merge, publish,}}
\DoxyCodeLine{10 \textcolor{comment}{  distribute, sublicense, and/or sell copies of the Software, and to}}
\DoxyCodeLine{11 \textcolor{comment}{  permit persons to whom the Software is furnished to do so, subject to}}
\DoxyCodeLine{12 \textcolor{comment}{  the following conditions:}}
\DoxyCodeLine{13 \textcolor{comment}{}}
\DoxyCodeLine{14 \textcolor{comment}{  The above copyright notice and this permission notice shall be}}
\DoxyCodeLine{15 \textcolor{comment}{  included in all copies or substantial portions of the Software.}}
\DoxyCodeLine{16 \textcolor{comment}{}}
\DoxyCodeLine{17 \textcolor{comment}{  THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND,}}
\DoxyCodeLine{18 \textcolor{comment}{  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF}}
\DoxyCodeLine{19 \textcolor{comment}{  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND}}
\DoxyCodeLine{20 \textcolor{comment}{  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE}}
\DoxyCodeLine{21 \textcolor{comment}{  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION}}
\DoxyCodeLine{22 \textcolor{comment}{  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION}}
\DoxyCodeLine{23 \textcolor{comment}{  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{24 \textcolor{comment}{}}
\DoxyCodeLine{25 \textcolor{comment}{  -\/-\/-\/ Optional exception to the license -\/-\/-\/}}
\DoxyCodeLine{26 \textcolor{comment}{}}
\DoxyCodeLine{27 \textcolor{comment}{  As an exception, if, as a result of your compiling your source code, portions}}
\DoxyCodeLine{28 \textcolor{comment}{  of this Software are embedded into a machine-\/executable object form of such}}
\DoxyCodeLine{29 \textcolor{comment}{  source code, you may redistribute such embedded portions in such object form}}
\DoxyCodeLine{30 \textcolor{comment}{  without including the above copyright and permission notices.}}
\DoxyCodeLine{31 \textcolor{comment}{ */}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#ifndef FMT\_FORMAT\_H\_}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#define FMT\_FORMAT\_H\_}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <cmath>}         \textcolor{comment}{// std::signbit}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#include <cstdint>}       \textcolor{comment}{// uint32\_t}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <cstring>}       \textcolor{comment}{// std::memcpy}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <limits>}        \textcolor{comment}{// std::numeric\_limits}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include <memory>}        \textcolor{comment}{// std::uninitialized\_copy}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include <stdexcept>}     \textcolor{comment}{// std::runtime\_error}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include <system\_error>}  \textcolor{comment}{// std::system\_error}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_bit\_cast}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#  include <bit>}  \textcolor{comment}{// std::bitcast}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{preprocessor}{\#include "{}core.h"{}}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#  define FMT\_GCC\_VISIBILITY\_HIDDEN \_\_attribute\_\_((visibility("{}hidden"{}})))}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#  define FMT\_GCC\_VISIBILITY\_HIDDEN}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{55 }
\DoxyCodeLine{56 \textcolor{preprocessor}{\#ifdef \_\_NVCC\_\_}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#  define FMT\_CUDA\_VERSION (\_\_CUDACC\_VER\_MAJOR\_\_ * 100 + \_\_CUDACC\_VER\_MINOR\_\_)}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#  define FMT\_CUDA\_VERSION 0}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 \textcolor{preprocessor}{\#ifdef \_\_has\_builtin}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  define FMT\_HAS\_BUILTIN(x) \_\_has\_builtin(x)}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#  define FMT\_HAS\_BUILTIN(x) 0}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION || FMT\_CLANG\_VERSION}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\#  define FMT\_NOINLINE \_\_attribute\_\_((noinline))}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#  define FMT\_NOINLINE}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#  define FMT\_MSC\_DEFAULT = default}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#  define FMT\_MSC\_DEFAULT}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{preprocessor}{\#ifndef FMT\_THROW}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#  if FMT\_EXCEPTIONS}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#    if FMT\_MSC\_VERSION || defined(\_\_NVCC\_\_)}}
\DoxyCodeLine{83 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{84 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{85 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Exception> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} do\_throw(\textcolor{keyword}{const} \mbox{\hyperlink{class_exception}{Exception}}\& x) \{}
\DoxyCodeLine{86   \textcolor{comment}{// Silence unreachable code warnings in MSVC and NVCC because these}}
\DoxyCodeLine{87   \textcolor{comment}{// are nearly impossible to fix in a generic code.}}
\DoxyCodeLine{88   \textcolor{keyword}{volatile} \textcolor{keywordtype}{bool} b = \textcolor{keyword}{true};}
\DoxyCodeLine{89   \textcolor{keywordflow}{if} (b) \textcolor{keywordflow}{throw} x;}
\DoxyCodeLine{90 \}}
\DoxyCodeLine{91 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{92 FMT\_END\_NAMESPACE}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#      define FMT\_THROW(x) detail::do\_throw(x)}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\#      define FMT\_THROW(x) throw x}}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{97 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#    define FMT\_THROW(x)               \(\backslash\)}}
\DoxyCodeLine{99 \textcolor{preprocessor}{      do \{                             \(\backslash\)}}
\DoxyCodeLine{100 \textcolor{preprocessor}{        FMT\_ASSERT(false, (x).what()); \(\backslash\)}}
\DoxyCodeLine{101 \textcolor{preprocessor}{      \} while (false)}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{103 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{preprocessor}{\#if FMT\_EXCEPTIONS}}
\DoxyCodeLine{106 \textcolor{preprocessor}{\#  define FMT\_TRY try}}
\DoxyCodeLine{107 \textcolor{preprocessor}{\#  define FMT\_CATCH(x) catch (x)}}
\DoxyCodeLine{108 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{109 \textcolor{preprocessor}{\#  define FMT\_TRY if (true)}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#  define FMT\_CATCH(x) if (false)}}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \textcolor{preprocessor}{\#ifndef FMT\_MAYBE\_UNUSED}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#  if FMT\_HAS\_CPP17\_ATTRIBUTE(maybe\_unused)}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#    define FMT\_MAYBE\_UNUSED [[maybe\_unused]]}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{117 \textcolor{preprocessor}{\#    define FMT\_MAYBE\_UNUSED}}
\DoxyCodeLine{118 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{preprocessor}{\#ifndef FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{122 \textcolor{comment}{// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#  if (FMT\_HAS\_FEATURE(cxx\_user\_literals) || FMT\_GCC\_VERSION >= 407 || \(\backslash\)}}
\DoxyCodeLine{124 \textcolor{preprocessor}{       FMT\_MSC\_VERSION >= 1900) \&\&                                     \(\backslash\)}}
\DoxyCodeLine{125 \textcolor{preprocessor}{      (!defined(\_\_EDG\_VERSION\_\_) || \_\_EDG\_VERSION\_\_ >= }\textcolor{comment}{/* UDL feature */}\textcolor{preprocessor}{ 480)}}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#    define FMT\_USE\_USER\_DEFINED\_LITERALS 1}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#    define FMT\_USE\_USER\_DEFINED\_LITERALS 0}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{comment}{// Defining FMT\_REDUCE\_INT\_INSTANTIATIONS to 1, will reduce the number of}}
\DoxyCodeLine{133 \textcolor{comment}{// integer formatter template instantiations to just one by only using the}}
\DoxyCodeLine{134 \textcolor{comment}{// largest integer type. This results in a reduction in binary size but will}}
\DoxyCodeLine{135 \textcolor{comment}{// cause a decrease in integer formatting performance.}}
\DoxyCodeLine{136 \textcolor{preprocessor}{\#if !defined(FMT\_REDUCE\_INT\_INSTANTIATIONS)}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#  define FMT\_REDUCE\_INT\_INSTANTIATIONS 0}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140 \textcolor{comment}{// \_\_builtin\_clz is broken in clang with Microsoft CodeGen:}}
\DoxyCodeLine{141 \textcolor{comment}{// https://github.com/fmtlib/fmt/issues/519.}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION}}
\DoxyCodeLine{143 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_clz) || FMT\_GCC\_VERSION || FMT\_ICC\_VERSION}}
\DoxyCodeLine{144 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CLZ(n) \_\_builtin\_clz(n)}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{146 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_clzll) || FMT\_GCC\_VERSION || FMT\_ICC\_VERSION}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CLZLL(n) \_\_builtin\_clzll(n)}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{comment}{// \_\_builtin\_ctz is broken in Intel Compiler Classic on Windows:}}
\DoxyCodeLine{152 \textcolor{comment}{// https://github.com/fmtlib/fmt/issues/2510.}}
\DoxyCodeLine{153 \textcolor{preprocessor}{\#ifndef \_\_ICL}}
\DoxyCodeLine{154 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_ctz) || FMT\_GCC\_VERSION || FMT\_ICC\_VERSION || \(\backslash\)}}
\DoxyCodeLine{155 \textcolor{preprocessor}{      defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{156 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CTZ(n) \_\_builtin\_ctz(n)}}
\DoxyCodeLine{157 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{158 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_ctzll) || FMT\_GCC\_VERSION || \(\backslash\)}}
\DoxyCodeLine{159 \textcolor{preprocessor}{      FMT\_ICC\_VERSION || defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{160 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CTZLL(n) \_\_builtin\_ctzll(n)}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#  include <intrin.h>}  \textcolor{comment}{// \_BitScanReverse[64], \_BitScanForward[64], \_umul128}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{comment}{// Some compilers masquerade as both MSVC and GCC-\/likes or otherwise support}}
\DoxyCodeLine{169 \textcolor{comment}{// \_\_builtin\_clz and \_\_builtin\_clzll, so only define FMT\_BUILTIN\_CLZ using the}}
\DoxyCodeLine{170 \textcolor{comment}{// MSVC intrinsics if the clz and clzll builtins are not available.}}
\DoxyCodeLine{171 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION \&\& !defined(FMT\_BUILTIN\_CLZLL) \&\& \(\backslash\)}}
\DoxyCodeLine{172 \textcolor{preprocessor}{    !defined(FMT\_BUILTIN\_CTZLL)}}
\DoxyCodeLine{173 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{174 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{175 \textcolor{comment}{// Avoid Clang with Microsoft CodeGen's -\/Wunknown-\/pragmas warning.}}
\DoxyCodeLine{176 \textcolor{preprocessor}{\#  if !defined(\_\_clang\_\_)}}
\DoxyCodeLine{177 \textcolor{preprocessor}{\#    pragma intrinsic(\_BitScanForward)}}
\DoxyCodeLine{178 \textcolor{preprocessor}{\#    pragma intrinsic(\_BitScanReverse)}}
\DoxyCodeLine{179 \textcolor{preprocessor}{\#    if defined(\_WIN64)}}
\DoxyCodeLine{180 \textcolor{preprocessor}{\#      pragma intrinsic(\_BitScanForward64)}}
\DoxyCodeLine{181 \textcolor{preprocessor}{\#      pragma intrinsic(\_BitScanReverse64)}}
\DoxyCodeLine{182 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{keyword}{inline} \textcolor{keyword}{auto} clz(uint32\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{186   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{187   \_BitScanReverse(\&r, x);}
\DoxyCodeLine{188   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{189   \textcolor{comment}{// Static analysis complains about using uninitialized data}}
\DoxyCodeLine{190   \textcolor{comment}{// "{}r"{}, but the only way that can happen is if "{}x"{} is 0,}}
\DoxyCodeLine{191   \textcolor{comment}{// which the callers guarantee to not happen.}}
\DoxyCodeLine{192   FMT\_MSC\_WARNING(suppress : 6102)}
\DoxyCodeLine{193   \textcolor{keywordflow}{return} 31 \string^ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{194 \}}
\DoxyCodeLine{195 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CLZ(n) detail::clz(n)}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 \textcolor{keyword}{inline} \textcolor{keyword}{auto} clzll(uint64\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{198   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#  ifdef \_WIN64}}
\DoxyCodeLine{200   \_BitScanReverse64(\&r, x);}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{202   \textcolor{comment}{// Scan the high 32 bits.}}
\DoxyCodeLine{203   \textcolor{keywordflow}{if} (\_BitScanReverse(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x >> 32))) \textcolor{keywordflow}{return} 63 \string^ (r + 32);}
\DoxyCodeLine{204   \textcolor{comment}{// Scan the low 32 bits.}}
\DoxyCodeLine{205   \_BitScanReverse(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x));}
\DoxyCodeLine{206 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{207   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{208   FMT\_MSC\_WARNING(suppress : 6102)  \textcolor{comment}{// Suppress a bogus static analysis warning.}}
\DoxyCodeLine{209   \textcolor{keywordflow}{return} 63 \string^ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{210 \}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CLZLL(n) detail::clzll(n)}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ctz(uint32\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{214   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{215   \_BitScanForward(\&r, x);}
\DoxyCodeLine{216   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{217   FMT\_MSC\_WARNING(suppress : 6102)  \textcolor{comment}{// Suppress a bogus static analysis warning.}}
\DoxyCodeLine{218   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{219 \}}
\DoxyCodeLine{220 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CTZ(n) detail::ctz(n)}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ctzll(uint64\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{223   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{224   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{225   FMT\_MSC\_WARNING(suppress : 6102)  \textcolor{comment}{// Suppress a bogus static analysis warning.}}
\DoxyCodeLine{226 \textcolor{preprocessor}{\#  ifdef \_WIN64}}
\DoxyCodeLine{227   \_BitScanForward64(\&r, x);}
\DoxyCodeLine{228 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{229   \textcolor{comment}{// Scan the low 32 bits.}}
\DoxyCodeLine{230   \textcolor{keywordflow}{if} (\_BitScanForward(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x))) \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{231   \textcolor{comment}{// Scan the high 32 bits.}}
\DoxyCodeLine{232   \_BitScanForward(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x >> 32));}
\DoxyCodeLine{233   r += 32;}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{235   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{236 \}}
\DoxyCodeLine{237 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CTZLL(n) detail::ctzll(n)}}
\DoxyCodeLine{238 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{239 FMT\_END\_NAMESPACE}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{243 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keywordtype}{void} abort\_fuzzing\_if(\textcolor{keywordtype}{bool} condition) \{}
\DoxyCodeLine{246   ignore\_unused(condition);}
\DoxyCodeLine{247 \textcolor{preprocessor}{\#ifdef FMT\_FUZZ}}
\DoxyCodeLine{248   \textcolor{keywordflow}{if} (condition) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}fuzzing limit reached"{}});}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{250 \}}
\DoxyCodeLine{251 }
\DoxyCodeLine{252 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Streambuf> \textcolor{keyword}{class }formatbuf : \textcolor{keyword}{public} Streambuf \{}
\DoxyCodeLine{253  \textcolor{keyword}{private}:}
\DoxyCodeLine{254   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Streambuf::char\_type;}
\DoxyCodeLine{255   \textcolor{keyword}{using }streamsize = \textcolor{keyword}{decltype}(std::declval<Streambuf>().sputn(\textcolor{keyword}{nullptr}, 0));}
\DoxyCodeLine{256   \textcolor{keyword}{using }int\_type = \textcolor{keyword}{typename} Streambuf::int\_type;}
\DoxyCodeLine{257   \textcolor{keyword}{using }traits\_type = \textcolor{keyword}{typename} Streambuf::traits\_type;}
\DoxyCodeLine{258 }
\DoxyCodeLine{259   \mbox{\hyperlink{classbuffer}{buffer<char\_type>}}\& buffer\_;}
\DoxyCodeLine{260 }
\DoxyCodeLine{261  \textcolor{keyword}{public}:}
\DoxyCodeLine{262   \textcolor{keyword}{explicit} formatbuf(\mbox{\hyperlink{classbuffer}{buffer<char\_type>}}\& buf) : buffer\_(buf) \{\}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264  \textcolor{keyword}{protected}:}
\DoxyCodeLine{265   \textcolor{comment}{// The put area is always empty. This makes the implementation simpler and has}}
\DoxyCodeLine{266   \textcolor{comment}{// the advantage that the streambuf and the buffer are always in sync and}}
\DoxyCodeLine{267   \textcolor{comment}{// sputc never writes into uninitialized memory. A disadvantage is that each}}
\DoxyCodeLine{268   \textcolor{comment}{// call to sputc always results in a (virtual) call to overflow. There is no}}
\DoxyCodeLine{269   \textcolor{comment}{// disadvantage here for sputn since this always results in a call to xsputn.}}
\DoxyCodeLine{270 }
\DoxyCodeLine{271   \textcolor{keyword}{auto} overflow(int\_type ch) -\/> int\_type \textcolor{keyword}{override} \{}
\DoxyCodeLine{272     \textcolor{keywordflow}{if} (!traits\_type::eq\_int\_type(ch, traits\_type::eof()))}
\DoxyCodeLine{273       buffer\_.push\_back(\textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(ch));}
\DoxyCodeLine{274     \textcolor{keywordflow}{return} ch;}
\DoxyCodeLine{275   \}}
\DoxyCodeLine{276 }
\DoxyCodeLine{277   \textcolor{keyword}{auto} xsputn(\textcolor{keyword}{const} char\_type* s, streamsize count) -\/> streamsize \textcolor{keyword}{override} \{}
\DoxyCodeLine{278     buffer\_.\mbox{\hyperlink{classbuffer_a144ad707b324a714fbe334896f90ba28}{append}}(s, s + count);}
\DoxyCodeLine{279     \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{280   \}}
\DoxyCodeLine{281 \};}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 \textcolor{comment}{// Implementation of std::bit\_cast for pre-\/C++20.}}
\DoxyCodeLine{284 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From, FMT\_ENABLE\_IF(sizeof(To) == sizeof(From))>}
\DoxyCodeLine{285 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} bit\_cast(\textcolor{keyword}{const} From\& from) -\/> To \{}
\DoxyCodeLine{286 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_bit\_cast}}
\DoxyCodeLine{287   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordflow}{return} std::bit\_cast<To>(from);}
\DoxyCodeLine{288 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{289   \textcolor{keyword}{auto} to = To();}
\DoxyCodeLine{290   std::memcpy(\&to, \&from, \textcolor{keyword}{sizeof}(to));}
\DoxyCodeLine{291   \textcolor{keywordflow}{return} to;}
\DoxyCodeLine{292 \}}
\DoxyCodeLine{293 }
\DoxyCodeLine{294 \textcolor{keyword}{inline} \textcolor{keyword}{auto} is\_big\_endian() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{295 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{296   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{297 \textcolor{preprocessor}{\#elif defined(\_\_BIG\_ENDIAN\_\_)}}
\DoxyCodeLine{298   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{299 \textcolor{preprocessor}{\#elif defined(\_\_BYTE\_ORDER\_\_) \&\& defined(\_\_ORDER\_BIG\_ENDIAN\_\_)}}
\DoxyCodeLine{300   \textcolor{keywordflow}{return} \_\_BYTE\_ORDER\_\_ == \_\_ORDER\_BIG\_ENDIAN\_\_;}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{302   \textcolor{keyword}{struct }bytes \{}
\DoxyCodeLine{303     \textcolor{keywordtype}{char} data[\textcolor{keyword}{sizeof}(int)];}
\DoxyCodeLine{304   \};}
\DoxyCodeLine{305   \textcolor{keywordflow}{return} bit\_cast<bytes>(1).data[0] == 0;}
\DoxyCodeLine{306 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{307 \}}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{keyword}{class }uint128\_fallback \{}
\DoxyCodeLine{310  \textcolor{keyword}{private}:}
\DoxyCodeLine{311   uint64\_t lo\_, hi\_;}
\DoxyCodeLine{312 }
\DoxyCodeLine{313   \textcolor{keyword}{friend} uint128\_fallback umul128(uint64\_t x, uint64\_t y) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{314 }
\DoxyCodeLine{315  \textcolor{keyword}{public}:}
\DoxyCodeLine{316   \textcolor{keyword}{constexpr} uint128\_fallback(uint64\_t hi, uint64\_t lo) : lo\_(lo), hi\_(hi) \{\}}
\DoxyCodeLine{317   \textcolor{keyword}{constexpr} uint128\_fallback(uint64\_t value = 0) : lo\_(value), hi\_(0) \{\}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319   \textcolor{keyword}{constexpr} uint64\_t high() const noexcept \{ \textcolor{keywordflow}{return} hi\_; \}}
\DoxyCodeLine{320   \textcolor{keyword}{constexpr} uint64\_t low() const noexcept \{ \textcolor{keywordflow}{return} lo\_; \}}
\DoxyCodeLine{321 }
\DoxyCodeLine{322   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{323   \textcolor{keyword}{constexpr} \textcolor{keyword}{explicit} \textcolor{keyword}{operator} T()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{324     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(lo\_);}
\DoxyCodeLine{325   \}}
\DoxyCodeLine{326 }
\DoxyCodeLine{327   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator==(\textcolor{keyword}{const} uint128\_fallback\& lhs,}
\DoxyCodeLine{328                                    \textcolor{keyword}{const} uint128\_fallback\& rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{329     \textcolor{keywordflow}{return} lhs.hi\_ == rhs.hi\_ \&\& lhs.lo\_ == rhs.lo\_;}
\DoxyCodeLine{330   \}}
\DoxyCodeLine{331   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator!=(\textcolor{keyword}{const} uint128\_fallback\& lhs,}
\DoxyCodeLine{332                                    \textcolor{keyword}{const} uint128\_fallback\& rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{333     \textcolor{keywordflow}{return} !(lhs == rhs);}
\DoxyCodeLine{334   \}}
\DoxyCodeLine{335   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator>(\textcolor{keyword}{const} uint128\_fallback\& lhs,}
\DoxyCodeLine{336                                   \textcolor{keyword}{const} uint128\_fallback\& rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{337     \textcolor{keywordflow}{return} lhs.hi\_ != rhs.hi\_ ? lhs.hi\_ > rhs.hi\_ : lhs.lo\_ > rhs.lo\_;}
\DoxyCodeLine{338   \}}
\DoxyCodeLine{339   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator|(\textcolor{keyword}{const} uint128\_fallback\& lhs,}
\DoxyCodeLine{340                                   \textcolor{keyword}{const} uint128\_fallback\& rhs)}
\DoxyCodeLine{341       -\/> uint128\_fallback \{}
\DoxyCodeLine{342     \textcolor{keywordflow}{return} \{lhs.hi\_ | rhs.hi\_, lhs.lo\_ | rhs.lo\_\};}
\DoxyCodeLine{343   \}}
\DoxyCodeLine{344   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator\&(\textcolor{keyword}{const} uint128\_fallback\& lhs,}
\DoxyCodeLine{345                                   \textcolor{keyword}{const} uint128\_fallback\& rhs)}
\DoxyCodeLine{346       -\/> uint128\_fallback \{}
\DoxyCodeLine{347     \textcolor{keywordflow}{return} \{lhs.hi\_ \& rhs.hi\_, lhs.lo\_ \& rhs.lo\_\};}
\DoxyCodeLine{348   \}}
\DoxyCodeLine{349   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator+(\textcolor{keyword}{const} uint128\_fallback\& lhs,}
\DoxyCodeLine{350                         \textcolor{keyword}{const} uint128\_fallback\& rhs) -\/> uint128\_fallback \{}
\DoxyCodeLine{351     \textcolor{keyword}{auto} result = uint128\_fallback(lhs);}
\DoxyCodeLine{352     result += rhs;}
\DoxyCodeLine{353     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{354   \}}
\DoxyCodeLine{355   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator*(\textcolor{keyword}{const} uint128\_fallback\& lhs, uint32\_t rhs)}
\DoxyCodeLine{356       -\/> uint128\_fallback \{}
\DoxyCodeLine{357     FMT\_ASSERT(lhs.hi\_ == 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{358     uint64\_t hi = (lhs.lo\_ >> 32) * rhs;}
\DoxyCodeLine{359     uint64\_t lo = (lhs.lo\_ \& \string~uint32\_t()) * rhs;}
\DoxyCodeLine{360     uint64\_t new\_lo = (hi << 32) + lo;}
\DoxyCodeLine{361     \textcolor{keywordflow}{return} \{(hi >> 32) + (new\_lo < lo ? 1 : 0), new\_lo\};}
\DoxyCodeLine{362   \}}
\DoxyCodeLine{363   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator-\/(\textcolor{keyword}{const} uint128\_fallback\& lhs, uint64\_t rhs)}
\DoxyCodeLine{364       -\/> uint128\_fallback \{}
\DoxyCodeLine{365     \textcolor{keywordflow}{return} \{lhs.hi\_ -\/ (lhs.lo\_ < rhs ? 1 : 0), lhs.lo\_ -\/ rhs\};}
\DoxyCodeLine{366   \}}
\DoxyCodeLine{367   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator>>(\textcolor{keywordtype}{int} shift) \textcolor{keyword}{const} -\/> uint128\_fallback \{}
\DoxyCodeLine{368     \textcolor{keywordflow}{if} (shift == 64) \textcolor{keywordflow}{return} \{0, hi\_\};}
\DoxyCodeLine{369     \textcolor{keywordflow}{return} \{hi\_ >> shift, (hi\_ << (64 -\/ shift)) | (lo\_ >> shift)\};}
\DoxyCodeLine{370   \}}
\DoxyCodeLine{371   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator<<(\textcolor{keywordtype}{int} shift) \textcolor{keyword}{const} -\/> uint128\_fallback \{}
\DoxyCodeLine{372     \textcolor{keywordflow}{if} (shift == 64) \textcolor{keywordflow}{return} \{lo\_, 0\};}
\DoxyCodeLine{373     \textcolor{keywordflow}{return} \{hi\_ << shift | (lo\_ >> (64 -\/ shift)), (lo\_ << shift)\};}
\DoxyCodeLine{374   \}}
\DoxyCodeLine{375   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator>>=(\textcolor{keywordtype}{int} shift) -\/> uint128\_fallback\& \{}
\DoxyCodeLine{376     \textcolor{keywordflow}{return} *\textcolor{keyword}{this} = *\textcolor{keyword}{this} >> shift;}
\DoxyCodeLine{377   \}}
\DoxyCodeLine{378   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator+=(uint128\_fallback n) \{}
\DoxyCodeLine{379     uint64\_t new\_lo = lo\_ + n.lo\_;}
\DoxyCodeLine{380     uint64\_t new\_hi = hi\_ + n.hi\_ + (new\_lo < lo\_ ? 1 : 0);}
\DoxyCodeLine{381     FMT\_ASSERT(new\_hi >= hi\_, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{382     lo\_ = new\_lo;}
\DoxyCodeLine{383     hi\_ = new\_hi;}
\DoxyCodeLine{384   \}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386   FMT\_CONSTEXPR20 uint128\_fallback\& operator+=(uint64\_t n) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{387     \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{388       lo\_ += n;}
\DoxyCodeLine{389       hi\_ += (lo\_ < n ? 1 : 0);}
\DoxyCodeLine{390       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{391     \}}
\DoxyCodeLine{392 \textcolor{preprocessor}{\#if FMT\_HAS\_BUILTIN(\_\_builtin\_addcll)}}
\DoxyCodeLine{393     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} carry;}
\DoxyCodeLine{394     lo\_ = \_\_builtin\_addcll(lo\_, n, 0, \&carry);}
\DoxyCodeLine{395     hi\_ += carry;}
\DoxyCodeLine{396 \textcolor{preprocessor}{\#elif FMT\_HAS\_BUILTIN(\_\_builtin\_ia32\_addcarryx\_u64)}}
\DoxyCodeLine{397     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} result;}
\DoxyCodeLine{398     \textcolor{keyword}{auto} carry = \_\_builtin\_ia32\_addcarryx\_u64(0, lo\_, n, \&result);}
\DoxyCodeLine{399     lo\_ = result;}
\DoxyCodeLine{400     hi\_ += carry;}
\DoxyCodeLine{401 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& defined(\_M\_X64)}}
\DoxyCodeLine{402     \textcolor{keyword}{auto} carry = \_addcarry\_u64(0, lo\_, n, \&lo\_);}
\DoxyCodeLine{403     \_addcarry\_u64(carry, hi\_, 0, \&hi\_);}
\DoxyCodeLine{404 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{405     lo\_ += n;}
\DoxyCodeLine{406     hi\_ += (lo\_ < n ? 1 : 0);}
\DoxyCodeLine{407 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{408     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{409   \}}
\DoxyCodeLine{410 \};}
\DoxyCodeLine{411 }
\DoxyCodeLine{412 \textcolor{keyword}{using }uint128\_t = conditional\_t<FMT\_USE\_INT128, uint128\_opt, uint128\_fallback>;}
\DoxyCodeLine{413 }
\DoxyCodeLine{414 \textcolor{preprocessor}{\#ifdef UINTPTR\_MAX}}
\DoxyCodeLine{415 \textcolor{keyword}{using }uintptr\_t = ::uintptr\_t;}
\DoxyCodeLine{416 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{417 \textcolor{keyword}{using }uintptr\_t = uint128\_t;}
\DoxyCodeLine{418 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{419 }
\DoxyCodeLine{420 \textcolor{comment}{// Returns the largest possible value for type T. Same as}}
\DoxyCodeLine{421 \textcolor{comment}{// std::numeric\_limits<T>::max() but shorter and not affected by the max macro.}}
\DoxyCodeLine{422 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} max\_value() -\/> T \{}
\DoxyCodeLine{423   \textcolor{keywordflow}{return} (std::numeric\_limits<T>::max)();}
\DoxyCodeLine{424 \}}
\DoxyCodeLine{425 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_bits() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{426   \textcolor{keywordflow}{return} std::numeric\_limits<T>::digits;}
\DoxyCodeLine{427 \}}
\DoxyCodeLine{428 \textcolor{comment}{// std::numeric\_limits<T>::digits may return 0 for 128-\/bit ints.}}
\DoxyCodeLine{429 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_bits<int128\_opt>() -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 128; \}}
\DoxyCodeLine{430 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_bits<uint128\_t>() -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 128; \}}
\DoxyCodeLine{431 }
\DoxyCodeLine{432 \textcolor{comment}{// A heterogeneous bit\_cast used for converting 96-\/bit long double to uint128\_t}}
\DoxyCodeLine{433 \textcolor{comment}{// and 128-\/bit pointers to uint128\_fallback.}}
\DoxyCodeLine{434 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From, FMT\_ENABLE\_IF(sizeof(To) > \textcolor{keyword}{sizeof}(From))>}
\DoxyCodeLine{435 \textcolor{keyword}{inline} \textcolor{keyword}{auto} bit\_cast(\textcolor{keyword}{const} From\& from) -\/> To \{}
\DoxyCodeLine{436   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{sizeof}(From) / \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned}));}
\DoxyCodeLine{437   \textcolor{keyword}{struct }data\_t \{}
\DoxyCodeLine{438     \textcolor{keywordtype}{unsigned} value[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(size)];}
\DoxyCodeLine{439   \} data = bit\_cast<data\_t>(from);}
\DoxyCodeLine{440   \textcolor{keyword}{auto} result = To();}
\DoxyCodeLine{441   \textcolor{keywordflow}{if} (const\_check(is\_big\_endian())) \{}
\DoxyCodeLine{442     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; ++i)}
\DoxyCodeLine{443       result = (result << num\_bits<unsigned>()) | data.value[i];}
\DoxyCodeLine{444   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{445     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = size -\/ 1; i >= 0; -\/-\/i)}
\DoxyCodeLine{446       result = (result << num\_bits<unsigned>()) | data.value[i];}
\DoxyCodeLine{447   \}}
\DoxyCodeLine{448   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{449 \}}
\DoxyCodeLine{450 }
\DoxyCodeLine{451 FMT\_INLINE \textcolor{keywordtype}{void} assume(\textcolor{keywordtype}{bool} condition) \{}
\DoxyCodeLine{452   (void)condition;}
\DoxyCodeLine{453 \textcolor{preprocessor}{\#if FMT\_HAS\_BUILTIN(\_\_builtin\_assume) \&\& !FMT\_ICC\_VERSION}}
\DoxyCodeLine{454   \_\_builtin\_assume(condition);}
\DoxyCodeLine{455 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{456 \}}
\DoxyCodeLine{457 }
\DoxyCodeLine{458 \textcolor{comment}{// An approximation of iterator\_t for pre-\/C++20 systems.}}
\DoxyCodeLine{459 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{460 \textcolor{keyword}{using }iterator\_t = \textcolor{keyword}{decltype}(std::begin(std::declval<T\&>()));}
\DoxyCodeLine{461 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }sentinel\_t = \textcolor{keyword}{decltype}(std::end(std::declval<T\&>()));}
\DoxyCodeLine{462 }
\DoxyCodeLine{463 \textcolor{comment}{// A workaround for std::string not having mutable data() until C++17.}}
\DoxyCodeLine{464 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{465 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_data(std::basic\_string<Char>\& s) -\/> Char* \{}
\DoxyCodeLine{466   \textcolor{keywordflow}{return} \&s[0];}
\DoxyCodeLine{467 \}}
\DoxyCodeLine{468 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{469 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_data(Container\& c) -\/> \textcolor{keyword}{typename} Container::value\_type* \{}
\DoxyCodeLine{470   \textcolor{keywordflow}{return} c.data();}
\DoxyCodeLine{471 \}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \textcolor{preprocessor}{\#if defined(\_SECURE\_SCL) \&\& \_SECURE\_SCL}}
\DoxyCodeLine{474 \textcolor{comment}{// Make a checked iterator to avoid MSVC warnings.}}
\DoxyCodeLine{475 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }checked\_ptr = stdext::checked\_array\_iterator<T*>;}
\DoxyCodeLine{476 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{477 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_checked(T* p, \textcolor{keywordtype}{size\_t} size) -\/> checked\_ptr<T> \{}
\DoxyCodeLine{478   \textcolor{keywordflow}{return} \{p, size\};}
\DoxyCodeLine{479 \}}
\DoxyCodeLine{480 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{481 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }checked\_ptr = T*;}
\DoxyCodeLine{482 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_checked(T* p, \textcolor{keywordtype}{size\_t}) -\/> T* \{}
\DoxyCodeLine{483   \textcolor{keywordflow}{return} p;}
\DoxyCodeLine{484 \}}
\DoxyCodeLine{485 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{486 }
\DoxyCodeLine{487 \textcolor{comment}{// Attempts to reserve space for n extra characters in the output range.}}
\DoxyCodeLine{488 \textcolor{comment}{// Returns a pointer to the reserved range or a reference to it.}}
\DoxyCodeLine{489 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container, FMT\_ENABLE\_IF(is\_contiguous<Container>::value)>}
\DoxyCodeLine{490 \textcolor{preprocessor}{\#if FMT\_CLANG\_VERSION >= 307 \&\& !FMT\_ICC\_VERSION}}
\DoxyCodeLine{491 \_\_attribute\_\_((no\_sanitize(\textcolor{stringliteral}{"{}undefined"{}})))}
\DoxyCodeLine{492 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{493 \textcolor{keyword}{inline} \textcolor{keyword}{auto}}
\DoxyCodeLine{494 reserve(std::back\_insert\_iterator<Container> it, \textcolor{keywordtype}{size\_t} n)}
\DoxyCodeLine{495     -\/> checked\_ptr<typename Container::value\_type> \{}
\DoxyCodeLine{496   Container\& c = get\_container(it);}
\DoxyCodeLine{497   \textcolor{keywordtype}{size\_t} size = c.size();}
\DoxyCodeLine{498   c.resize(size + n);}
\DoxyCodeLine{499   \textcolor{keywordflow}{return} make\_checked(get\_data(c) + size, n);}
\DoxyCodeLine{500 \}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{503 \textcolor{keyword}{inline} \textcolor{keyword}{auto} reserve(buffer\_appender<T> it, \textcolor{keywordtype}{size\_t} n) -\/> buffer\_appender<T> \{}
\DoxyCodeLine{504   \mbox{\hyperlink{classbuffer}{buffer<T>}}\& buf = get\_container(it);}
\DoxyCodeLine{505   buf.try\_reserve(buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}() + n);}
\DoxyCodeLine{506   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{507 \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{510 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} reserve(Iterator\& it, \textcolor{keywordtype}{size\_t}) -\/> Iterator\& \{}
\DoxyCodeLine{511   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{512 \}}
\DoxyCodeLine{513 }
\DoxyCodeLine{514 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{515 \textcolor{keyword}{using }reserve\_iterator =}
\DoxyCodeLine{516     remove\_reference\_t<decltype(reserve(std::declval<OutputIt\&>(), 0))>;}
\DoxyCodeLine{517 }
\DoxyCodeLine{518 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{519 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_pointer(OutputIt, \textcolor{keywordtype}{size\_t}) -\/> T* \{}
\DoxyCodeLine{520   \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{521 \}}
\DoxyCodeLine{522 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} to\_pointer(buffer\_appender<T> it, \textcolor{keywordtype}{size\_t} n) -\/> T* \{}
\DoxyCodeLine{523   \mbox{\hyperlink{classbuffer}{buffer<T>}}\& buf = get\_container(it);}
\DoxyCodeLine{524   \textcolor{keyword}{auto} size = buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{525   \textcolor{keywordflow}{if} (buf.\mbox{\hyperlink{classbuffer_a025ed14a3e24705aaacf82f013b7d5c4}{capacity}}() < size + n) \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{526   buf.try\_resize(size + n);}
\DoxyCodeLine{527   \textcolor{keywordflow}{return} buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}() + size;}
\DoxyCodeLine{528 \}}
\DoxyCodeLine{529 }
\DoxyCodeLine{530 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container, FMT\_ENABLE\_IF(is\_contiguous<Container>::value)>}
\DoxyCodeLine{531 \textcolor{keyword}{inline} \textcolor{keyword}{auto} base\_iterator(std::back\_insert\_iterator<Container>\& it,}
\DoxyCodeLine{532                           checked\_ptr<typename Container::value\_type>)}
\DoxyCodeLine{533     -\/> std::back\_insert\_iterator<Container> \{}
\DoxyCodeLine{534   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{535 \}}
\DoxyCodeLine{536 }
\DoxyCodeLine{537 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{538 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} base\_iterator(Iterator, Iterator it) -\/> Iterator \{}
\DoxyCodeLine{539   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{540 \}}
\DoxyCodeLine{541 }
\DoxyCodeLine{542 \textcolor{comment}{// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill\_n}}
\DoxyCodeLine{543 \textcolor{comment}{// instead (\#1998).}}
\DoxyCodeLine{544 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Size, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{545 FMT\_CONSTEXPR \textcolor{keyword}{auto} fill\_n(OutputIt out, Size count, \textcolor{keyword}{const} T\& value)}
\DoxyCodeLine{546     -\/> OutputIt \{}
\DoxyCodeLine{547   \textcolor{keywordflow}{for} (Size i = 0; i < count; ++i) *out++ = value;}
\DoxyCodeLine{548   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{549 \}}
\DoxyCodeLine{550 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Size>}
\DoxyCodeLine{551 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} fill\_n(T* out, Size count, \textcolor{keywordtype}{char} value) -\/> T* \{}
\DoxyCodeLine{552   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{553     \textcolor{keywordflow}{return} fill\_n<T*, Size, T>(out, count, value);}
\DoxyCodeLine{554   \}}
\DoxyCodeLine{555   std::memset(out, value, to\_unsigned(count));}
\DoxyCodeLine{556   \textcolor{keywordflow}{return} out + count;}
\DoxyCodeLine{557 \}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{preprocessor}{\#ifdef \_\_cpp\_char8\_t}}
\DoxyCodeLine{560 \textcolor{keyword}{using }char8\_type = char8\_t;}
\DoxyCodeLine{561 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{562 \textcolor{keyword}{enum} char8\_type : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{\};}
\DoxyCodeLine{563 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{564 }
\DoxyCodeLine{565 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutChar, \textcolor{keyword}{typename} InputIt, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{566 FMT\_CONSTEXPR FMT\_NOINLINE \textcolor{keyword}{auto} copy\_str\_noinline(InputIt begin, InputIt end,}
\DoxyCodeLine{567                                                   OutputIt out) -\/> OutputIt \{}
\DoxyCodeLine{568   \textcolor{keywordflow}{return} copy\_str<OutChar>(begin, end, out);}
\DoxyCodeLine{569 \}}
\DoxyCodeLine{570 }
\DoxyCodeLine{571 \textcolor{comment}{// A public domain branchless UTF-\/8 decoder by Christopher Wellons:}}
\DoxyCodeLine{572 \textcolor{comment}{// https://github.com/skeeto/branchless-\/utf8}}
\DoxyCodeLine{573 \textcolor{comment}{/* Decode the next character, c, from s, reporting errors in e.}}
\DoxyCodeLine{574 \textcolor{comment}{ *}}
\DoxyCodeLine{575 \textcolor{comment}{ * Since this is a branchless decoder, four bytes will be read from the}}
\DoxyCodeLine{576 \textcolor{comment}{ * buffer regardless of the actual length of the next character. This}}
\DoxyCodeLine{577 \textcolor{comment}{ * means the buffer \_must\_ have at least three bytes of zero padding}}
\DoxyCodeLine{578 \textcolor{comment}{ * following the end of the data stream.}}
\DoxyCodeLine{579 \textcolor{comment}{ *}}
\DoxyCodeLine{580 \textcolor{comment}{ * Errors are reported in e, which will be non-\/zero if the parsed}}
\DoxyCodeLine{581 \textcolor{comment}{ * character was somehow invalid: invalid byte sequence, non-\/canonical}}
\DoxyCodeLine{582 \textcolor{comment}{ * encoding, or a surrogate half.}}
\DoxyCodeLine{583 \textcolor{comment}{ *}}
\DoxyCodeLine{584 \textcolor{comment}{ * The function returns a pointer to the next character. When an error}}
\DoxyCodeLine{585 \textcolor{comment}{ * occurs, this pointer will be a guess that depends on the particular}}
\DoxyCodeLine{586 \textcolor{comment}{ * error, but it will always advance at least one byte.}}
\DoxyCodeLine{587 \textcolor{comment}{ */}}
\DoxyCodeLine{588 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} utf8\_decode(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, uint32\_t* c, \textcolor{keywordtype}{int}* e)}
\DoxyCodeLine{589     -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{590   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} masks[] = \{0x00, 0x7f, 0x1f, 0x0f, 0x07\};}
\DoxyCodeLine{591   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} uint32\_t mins[] = \{4194304, 0, 128, 2048, 65536\};}
\DoxyCodeLine{592   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shiftc[] = \{0, 18, 12, 6, 0\};}
\DoxyCodeLine{593   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shifte[] = \{0, 6, 4, 2, 0\};}
\DoxyCodeLine{594 }
\DoxyCodeLine{595   \textcolor{keywordtype}{int} len = code\_point\_length(s);}
\DoxyCodeLine{596   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* next = s + len;}
\DoxyCodeLine{597 }
\DoxyCodeLine{598   \textcolor{comment}{// Assume a four-\/byte character and load four bytes. Unused bits are}}
\DoxyCodeLine{599   \textcolor{comment}{// shifted out.}}
\DoxyCodeLine{600   *c = uint32\_t(s[0] \& masks[len]) << 18;}
\DoxyCodeLine{601   *c |= uint32\_t(s[1] \& 0x3f) << 12;}
\DoxyCodeLine{602   *c |= uint32\_t(s[2] \& 0x3f) << 6;}
\DoxyCodeLine{603   *c |= uint32\_t(s[3] \& 0x3f) << 0;}
\DoxyCodeLine{604   *c >>= shiftc[len];}
\DoxyCodeLine{605 }
\DoxyCodeLine{606   \textcolor{comment}{// Accumulate the various error conditions.}}
\DoxyCodeLine{607   \textcolor{keyword}{using }uchar = \textcolor{keywordtype}{unsigned} char;}
\DoxyCodeLine{608   *e = (*c < mins[len]) << 6;       \textcolor{comment}{// non-\/canonical encoding}}
\DoxyCodeLine{609   *e |= ((*c >> 11) == 0x1b) << 7;  \textcolor{comment}{// surrogate half?}}
\DoxyCodeLine{610   *e |= (*c > 0x10FFFF) << 8;       \textcolor{comment}{// out of range?}}
\DoxyCodeLine{611   *e |= (uchar(s[1]) \& 0xc0) >> 2;}
\DoxyCodeLine{612   *e |= (uchar(s[2]) \& 0xc0) >> 4;}
\DoxyCodeLine{613   *e |= uchar(s[3]) >> 6;}
\DoxyCodeLine{614   *e \string^= 0x2a;  \textcolor{comment}{// top two bits of each tail byte correct?}}
\DoxyCodeLine{615   *e >>= shifte[len];}
\DoxyCodeLine{616 }
\DoxyCodeLine{617   \textcolor{keywordflow}{return} next;}
\DoxyCodeLine{618 \}}
\DoxyCodeLine{619 }
\DoxyCodeLine{620 \textcolor{keyword}{constexpr} uint32\_t invalid\_code\_point = \string~uint32\_t();}
\DoxyCodeLine{621 }
\DoxyCodeLine{622 \textcolor{comment}{// Invokes f(cp, sv) for every code point cp in s with sv being the string view}}
\DoxyCodeLine{623 \textcolor{comment}{// corresponding to the code point. cp is invalid\_code\_point on error.}}
\DoxyCodeLine{624 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{625 FMT\_CONSTEXPR \textcolor{keywordtype}{void} for\_each\_codepoint(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s, F f) \{}
\DoxyCodeLine{626   \textcolor{keyword}{auto} decode = [f](\textcolor{keyword}{const} \textcolor{keywordtype}{char}* buf\_ptr, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ptr) \{}
\DoxyCodeLine{627     \textcolor{keyword}{auto} cp = uint32\_t();}
\DoxyCodeLine{628     \textcolor{keyword}{auto} error = 0;}
\DoxyCodeLine{629     \textcolor{keyword}{auto} end = utf8\_decode(buf\_ptr, \&cp, \&error);}
\DoxyCodeLine{630     \textcolor{keywordtype}{bool} result = f(error ? invalid\_code\_point : cp,}
\DoxyCodeLine{631                     \mbox{\hyperlink{classbasic__string__view}{string\_view}}(ptr, to\_unsigned(end -\/ buf\_ptr)));}
\DoxyCodeLine{632     \textcolor{keywordflow}{return} result ? end : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{633   \};}
\DoxyCodeLine{634   \textcolor{keyword}{auto} p = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{635   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} block\_size = 4;  \textcolor{comment}{// utf8\_decode always reads blocks of 4 chars.}}
\DoxyCodeLine{636   \textcolor{keywordflow}{if} (s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() >= block\_size) \{}
\DoxyCodeLine{637     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} end = p + s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() -\/ block\_size + 1; p < end;) \{}
\DoxyCodeLine{638       p = decode(p, p);}
\DoxyCodeLine{639       \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return};}
\DoxyCodeLine{640     \}}
\DoxyCodeLine{641   \}}
\DoxyCodeLine{642   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} num\_chars\_left = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}() + s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() -\/ p) \{}
\DoxyCodeLine{643     \textcolor{keywordtype}{char} buf[2 * block\_size -\/ 1] = \{\};}
\DoxyCodeLine{644     copy\_str<char>(p, p + num\_chars\_left, buf);}
\DoxyCodeLine{645     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* buf\_ptr = buf;}
\DoxyCodeLine{646     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{647       \textcolor{keyword}{auto} end = decode(buf\_ptr, p);}
\DoxyCodeLine{648       \textcolor{keywordflow}{if} (!end) \textcolor{keywordflow}{return};}
\DoxyCodeLine{649       p += end -\/ buf\_ptr;}
\DoxyCodeLine{650       buf\_ptr = end;}
\DoxyCodeLine{651     \} \textcolor{keywordflow}{while} (buf\_ptr -\/ buf < num\_chars\_left);}
\DoxyCodeLine{652   \}}
\DoxyCodeLine{653 \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{656 \textcolor{keyword}{inline} \textcolor{keyword}{auto} compute\_width(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{657   \textcolor{keywordflow}{return} s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{658 \}}
\DoxyCodeLine{659 }
\DoxyCodeLine{660 \textcolor{comment}{// Computes approximate display width of a UTF-\/8 string.}}
\DoxyCodeLine{661 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keywordtype}{size\_t} compute\_width(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) \{}
\DoxyCodeLine{662   \textcolor{keywordtype}{size\_t} num\_code\_points = 0;}
\DoxyCodeLine{663   \textcolor{comment}{// It is not a lambda for compatibility with C++14.}}
\DoxyCodeLine{664   \textcolor{keyword}{struct }count\_code\_points \{}
\DoxyCodeLine{665     \textcolor{keywordtype}{size\_t}* count;}
\DoxyCodeLine{666     FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(uint32\_t cp, \mbox{\hyperlink{classbasic__string__view}{string\_view}}) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{667       *count += detail::to\_unsigned(}
\DoxyCodeLine{668           1 +}
\DoxyCodeLine{669           (cp >= 0x1100 \&\&}
\DoxyCodeLine{670            (cp <= 0x115f ||  \textcolor{comment}{// Hangul Jamo init. consonants}}
\DoxyCodeLine{671             cp == 0x2329 ||  \textcolor{comment}{// LEFT-\/POINTING ANGLE BRACKET}}
\DoxyCodeLine{672             cp == 0x232a ||  \textcolor{comment}{// RIGHT-\/POINTING ANGLE BRACKET}}
\DoxyCodeLine{673             \textcolor{comment}{// CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:}}
\DoxyCodeLine{674             (cp >= 0x2e80 \&\& cp <= 0xa4cf \&\& cp != 0x303f) ||}
\DoxyCodeLine{675             (cp >= 0xac00 \&\& cp <= 0xd7a3) ||    \textcolor{comment}{// Hangul Syllables}}
\DoxyCodeLine{676             (cp >= 0xf900 \&\& cp <= 0xfaff) ||    \textcolor{comment}{// CJK Compatibility Ideographs}}
\DoxyCodeLine{677             (cp >= 0xfe10 \&\& cp <= 0xfe19) ||    \textcolor{comment}{// Vertical Forms}}
\DoxyCodeLine{678             (cp >= 0xfe30 \&\& cp <= 0xfe6f) ||    \textcolor{comment}{// CJK Compatibility Forms}}
\DoxyCodeLine{679             (cp >= 0xff00 \&\& cp <= 0xff60) ||    \textcolor{comment}{// Fullwidth Forms}}
\DoxyCodeLine{680             (cp >= 0xffe0 \&\& cp <= 0xffe6) ||    \textcolor{comment}{// Fullwidth Forms}}
\DoxyCodeLine{681             (cp >= 0x20000 \&\& cp <= 0x2fffd) ||  \textcolor{comment}{// CJK}}
\DoxyCodeLine{682             (cp >= 0x30000 \&\& cp <= 0x3fffd) ||}
\DoxyCodeLine{683             \textcolor{comment}{// Miscellaneous Symbols and Pictographs + Emoticons:}}
\DoxyCodeLine{684             (cp >= 0x1f300 \&\& cp <= 0x1f64f) ||}
\DoxyCodeLine{685             \textcolor{comment}{// Supplemental Symbols and Pictographs:}}
\DoxyCodeLine{686             (cp >= 0x1f900 \&\& cp <= 0x1f9ff))));}
\DoxyCodeLine{687       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{688     \}}
\DoxyCodeLine{689   \};}
\DoxyCodeLine{690   for\_each\_codepoint(s, count\_code\_points\{\&num\_code\_points\});}
\DoxyCodeLine{691   \textcolor{keywordflow}{return} num\_code\_points;}
\DoxyCodeLine{692 \}}
\DoxyCodeLine{693 }
\DoxyCodeLine{694 \textcolor{keyword}{inline} \textcolor{keyword}{auto} compute\_width(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char8\_type>}} s) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{695   \textcolor{keywordflow}{return} compute\_width(}
\DoxyCodeLine{696       \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}()), s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()));}
\DoxyCodeLine{697 \}}
\DoxyCodeLine{698 }
\DoxyCodeLine{699 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{700 \textcolor{keyword}{inline} \textcolor{keyword}{auto} code\_point\_index(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s, \textcolor{keywordtype}{size\_t} n) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{701   \textcolor{keywordtype}{size\_t} size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{702   \textcolor{keywordflow}{return} n < size ? n : size;}
\DoxyCodeLine{703 \}}
\DoxyCodeLine{704 }
\DoxyCodeLine{705 \textcolor{comment}{// Calculates the index of the nth code point in a UTF-\/8 string.}}
\DoxyCodeLine{706 \textcolor{keyword}{inline} \textcolor{keyword}{auto} code\_point\_index(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s, \textcolor{keywordtype}{size\_t} n) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{707   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* data = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{708   \textcolor{keywordtype}{size\_t} num\_code\_points = 0;}
\DoxyCodeLine{709   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}(); i != size; ++i) \{}
\DoxyCodeLine{710     \textcolor{keywordflow}{if} ((data[i] \& 0xc0) != 0x80 \&\& ++num\_code\_points > n) \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{711   \}}
\DoxyCodeLine{712   \textcolor{keywordflow}{return} s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{713 \}}
\DoxyCodeLine{714 }
\DoxyCodeLine{715 \textcolor{keyword}{inline} \textcolor{keyword}{auto} code\_point\_index(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char8\_type>}} s, \textcolor{keywordtype}{size\_t} n)}
\DoxyCodeLine{716     -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{717   \textcolor{keywordflow}{return} code\_point\_index(}
\DoxyCodeLine{718       \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}()), s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()), n);}
\DoxyCodeLine{719 \}}
\DoxyCodeLine{720 }
\DoxyCodeLine{721 \textcolor{preprocessor}{\#ifndef FMT\_USE\_FLOAT128}}
\DoxyCodeLine{722 \textcolor{preprocessor}{\#  ifdef \_\_SIZEOF\_FLOAT128\_\_}}
\DoxyCodeLine{723 \textcolor{preprocessor}{\#    define FMT\_USE\_FLOAT128 1}}
\DoxyCodeLine{724 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{725 \textcolor{preprocessor}{\#    define FMT\_USE\_FLOAT128 0}}
\DoxyCodeLine{726 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{727 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{728 \textcolor{preprocessor}{\#if FMT\_USE\_FLOAT128}}
\DoxyCodeLine{729 \textcolor{keyword}{using }float128 = \_\_float128;}
\DoxyCodeLine{730 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{731 \textcolor{keyword}{using }float128 = void;}
\DoxyCodeLine{732 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{733 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }is\_float128 = std::is\_same<T, float128>;}
\DoxyCodeLine{734 }
\DoxyCodeLine{735 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{736 \textcolor{keyword}{using }is\_floating\_point =}
\DoxyCodeLine{737     bool\_constant<std::is\_floating\_point<T>::value || is\_float128<T>::value>;}
\DoxyCodeLine{738 }
\DoxyCodeLine{739 template <typename T, bool = std::is\_floating\_point<T>::value>}
\DoxyCodeLine{740 \textcolor{keyword}{struct }is\_fast\_float : bool\_constant<std::numeric\_limits<T>::is\_iec559 \&\&}
\DoxyCodeLine{741                                      sizeof(T) <= sizeof(double)> \{\};}
\DoxyCodeLine{742 template <typename T> struct is\_fast\_float<T, false> : std::false\_type \{\};}
\DoxyCodeLine{743 }
\DoxyCodeLine{744 template <typename T>}
\DoxyCodeLine{745 using is\_double\_double = bool\_constant<std::numeric\_limits<T>::digits == 106>;}
\DoxyCodeLine{746 }
\DoxyCodeLine{747 \#ifndef FMT\_USE\_FULL\_CACHE\_DRAGONBOX}
\DoxyCodeLine{748 \#  define FMT\_USE\_FULL\_CACHE\_DRAGONBOX 0}
\DoxyCodeLine{749 \#endif}
\DoxyCodeLine{750 }
\DoxyCodeLine{751 template <typename T>}
\DoxyCodeLine{752 template <typename U>}
\DoxyCodeLine{753 void buffer<T>::append(const U* begin, const U* end) \{}
\DoxyCodeLine{754   while (begin != end) \{}
\DoxyCodeLine{755     auto count = to\_unsigned(end -\/ begin);}
\DoxyCodeLine{756     try\_reserve(size\_ + count);}
\DoxyCodeLine{757     auto free\_cap = capacity\_ -\/ size\_;}
\DoxyCodeLine{758     if (free\_cap < count) count = free\_cap;}
\DoxyCodeLine{759     std::uninitialized\_copy\_n(begin, count, make\_checked(ptr\_ + size\_, count));}
\DoxyCodeLine{760     size\_ += count;}
\DoxyCodeLine{761     begin += count;}
\DoxyCodeLine{762   \}}
\DoxyCodeLine{763 \}}
\DoxyCodeLine{764 }
\DoxyCodeLine{765 template <typename T, typename Enable = void>}
\DoxyCodeLine{766 struct is\_locale : std::false\_type \{\};}
\DoxyCodeLine{767 template <typename T>}
\DoxyCodeLine{768 struct is\_locale<T, void\_t<decltype(T::classic())>> : std::true\_type \{\};}
\DoxyCodeLine{769 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{770 }
\DoxyCodeLine{771 FMT\_MODULE\_EXPORT\_BEGIN}
\DoxyCodeLine{772 }
\DoxyCodeLine{773 \textcolor{comment}{// The number of characters to store in the basic\_memory\_buffer object itself}}
\DoxyCodeLine{774 \textcolor{comment}{// to avoid dynamic memory allocation.}}
\DoxyCodeLine{775 enum \{ inline\_buffer\_size = 500 \};}
\DoxyCodeLine{776 }
\DoxyCodeLine{798 template <typename T, size\_t SIZE = inline\_buffer\_size,}
\DoxyCodeLine{799           typename Allocator = std::allocator<T>>}
\DoxyCodeLine{800 class basic\_memory\_buffer final : public detail::buffer<T> \{}
\DoxyCodeLine{801  private:}
\DoxyCodeLine{802   T store\_[SIZE];}
\DoxyCodeLine{803 }
\DoxyCodeLine{804   \textcolor{comment}{// Don't inherit from Allocator avoid generating type\_info for it.}}
\DoxyCodeLine{805   Allocator alloc\_;}
\DoxyCodeLine{806 }
\DoxyCodeLine{807   \textcolor{comment}{// Deallocate memory allocated by the buffer.}}
\DoxyCodeLine{808   FMT\_CONSTEXPR20 void deallocate() \{}
\DoxyCodeLine{809     T* data = this-\/>data();}
\DoxyCodeLine{810     if (data != store\_) alloc\_.deallocate(data, this-\/>capacity());}
\DoxyCodeLine{811   \}}
\DoxyCodeLine{812 }
\DoxyCodeLine{813  \textcolor{keyword}{protected}:}
\DoxyCodeLine{814   FMT\_CONSTEXPR20 void grow(size\_t size) override;}
\DoxyCodeLine{815 }
\DoxyCodeLine{816  \textcolor{keyword}{public}:}
\DoxyCodeLine{817   using value\_type = T;}
\DoxyCodeLine{818   using const\_reference = const T\&;}
\DoxyCodeLine{819 }
\DoxyCodeLine{820   FMT\_CONSTEXPR20 explicit \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}(}
\DoxyCodeLine{821       const Allocator\& alloc = Allocator())}
\DoxyCodeLine{822       : alloc\_(alloc) \{}
\DoxyCodeLine{823     this-\/>set(store\_, SIZE);}
\DoxyCodeLine{824     \textcolor{keywordflow}{if} (detail::is\_constant\_evaluated()) detail::fill\_n(store\_, SIZE, T());}
\DoxyCodeLine{825   \}}
\DoxyCodeLine{826   FMT\_CONSTEXPR20 \mbox{\hyperlink{classbasic__memory__buffer}{\string~basic\_memory\_buffer}}() \{ deallocate(); \}}
\DoxyCodeLine{827 }
\DoxyCodeLine{828  \textcolor{keyword}{private}:}
\DoxyCodeLine{829   \textcolor{comment}{// Move data from other to this buffer.}}
\DoxyCodeLine{830   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} move(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\& other) \{}
\DoxyCodeLine{831     alloc\_ = std::move(other.alloc\_);}
\DoxyCodeLine{832     T* data = other.data();}
\DoxyCodeLine{833     \textcolor{keywordtype}{size\_t} size = other.size(), capacity = other.capacity();}
\DoxyCodeLine{834     \textcolor{keywordflow}{if} (data == other.store\_) \{}
\DoxyCodeLine{835       this-\/>set(store\_, capacity);}
\DoxyCodeLine{836       detail::copy\_str<T>(other.store\_, other.store\_ + size,}
\DoxyCodeLine{837                           detail::make\_checked(store\_, capacity));}
\DoxyCodeLine{838     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{839       this-\/>set(data, capacity);}
\DoxyCodeLine{840       \textcolor{comment}{// Set pointer to the inline array so that delete is not called}}
\DoxyCodeLine{841       \textcolor{comment}{// when deallocating.}}
\DoxyCodeLine{842       other.set(other.store\_, 0);}
\DoxyCodeLine{843       other.clear();}
\DoxyCodeLine{844     \}}
\DoxyCodeLine{845     this-\/>resize(size);}
\DoxyCodeLine{846   \}}
\DoxyCodeLine{847 }
\DoxyCodeLine{848  \textcolor{keyword}{public}:}
\DoxyCodeLine{855   FMT\_CONSTEXPR20 \mbox{\hyperlink{classbasic__memory__buffer_ade18cff12fc914085665a07af2e8fb7b}{basic\_memory\_buffer}}(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\&\& other) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{856     move(other);}
\DoxyCodeLine{857   \}}
\DoxyCodeLine{858 }
\DoxyCodeLine{864   \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__memory__buffer_a20c8cea076154a579ab0a04afb6c1f84}{operator=}}(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\&\& other) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\& \{}
\DoxyCodeLine{865     FMT\_ASSERT(\textcolor{keyword}{this} != \&other, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{866     deallocate();}
\DoxyCodeLine{867     move(other);}
\DoxyCodeLine{868     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{869   \}}
\DoxyCodeLine{870 }
\DoxyCodeLine{871   \textcolor{comment}{// Returns a copy of the allocator associated with this buffer.}}
\DoxyCodeLine{872   \textcolor{keyword}{auto} get\_allocator() const -\/> Allocator \{ \textcolor{keywordflow}{return} alloc\_; \}}
\DoxyCodeLine{873 }
\DoxyCodeLine{878   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(\textcolor{keywordtype}{size\_t} count) \{ this-\/>try\_resize(count); \}}
\DoxyCodeLine{879 }
\DoxyCodeLine{881   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer_a27f096451ed4e6738d3a33161fda3e90}{reserve}}(\textcolor{keywordtype}{size\_t} new\_capacity) \{ this-\/>try\_reserve(new\_capacity); \}}
\DoxyCodeLine{882 }
\DoxyCodeLine{883   \textcolor{comment}{// Directly append data into the buffer}}
\DoxyCodeLine{884   \textcolor{keyword}{using }detail::buffer<T>::append;}
\DoxyCodeLine{885   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContiguousRange>}
\DoxyCodeLine{886   \textcolor{keywordtype}{void} append(\textcolor{keyword}{const} ContiguousRange\& range) \{}
\DoxyCodeLine{887     append(range.data(), range.data() + range.size());}
\DoxyCodeLine{888   \}}
\DoxyCodeLine{889 \};}
\DoxyCodeLine{890 }
\DoxyCodeLine{891 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} SIZE, \textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{892 FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<T, SIZE, Allocator>::grow}}(}
\DoxyCodeLine{893     \textcolor{keywordtype}{size\_t} size) \{}
\DoxyCodeLine{894   detail::abort\_fuzzing\_if(size > 5000);}
\DoxyCodeLine{895   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_size = std::allocator\_traits<Allocator>::max\_size(alloc\_);}
\DoxyCodeLine{896   \textcolor{keywordtype}{size\_t} old\_capacity = this-\/>capacity();}
\DoxyCodeLine{897   \textcolor{keywordtype}{size\_t} new\_capacity = old\_capacity + old\_capacity / 2;}
\DoxyCodeLine{898   \textcolor{keywordflow}{if} (size > new\_capacity)}
\DoxyCodeLine{899     new\_capacity = size;}
\DoxyCodeLine{900   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (new\_capacity > max\_size)}
\DoxyCodeLine{901     new\_capacity = size > max\_size ? size : max\_size;}
\DoxyCodeLine{902   T* old\_data = this-\/>data();}
\DoxyCodeLine{903   T* new\_data =}
\DoxyCodeLine{904       std::allocator\_traits<Allocator>::allocate(alloc\_, new\_capacity);}
\DoxyCodeLine{905   \textcolor{comment}{// The following code doesn't throw, so the raw pointer above doesn't leak.}}
\DoxyCodeLine{906   std::uninitialized\_copy(old\_data, old\_data + this-\/>size(),}
\DoxyCodeLine{907                           detail::make\_checked(new\_data, new\_capacity));}
\DoxyCodeLine{908   this-\/>set(new\_data, new\_capacity);}
\DoxyCodeLine{909   \textcolor{comment}{// deallocate must not throw according to the standard, but even if it does,}}
\DoxyCodeLine{910   \textcolor{comment}{// the buffer already uses the new storage and will deallocate it in}}
\DoxyCodeLine{911   \textcolor{comment}{// destructor.}}
\DoxyCodeLine{912   \textcolor{keywordflow}{if} (old\_data != store\_) alloc\_.deallocate(old\_data, old\_capacity);}
\DoxyCodeLine{913 \}}
\DoxyCodeLine{914 }
\DoxyCodeLine{915 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<char>}};}
\DoxyCodeLine{916 }
\DoxyCodeLine{917 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} SIZE, \textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{918 \textcolor{keyword}{struct }is\_contiguous<\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}<T, SIZE, Allocator>> : std::true\_type \{}
\DoxyCodeLine{919 \};}
\DoxyCodeLine{920 }
\DoxyCodeLine{921 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{922 FMT\_API \textcolor{keywordtype}{void} print(std::FILE*, \mbox{\hyperlink{classbasic__string__view}{string\_view}});}
\DoxyCodeLine{923 \}}
\DoxyCodeLine{924 }
\DoxyCodeLine{926 FMT\_CLASS\_API}
\DoxyCodeLine{927 \textcolor{keyword}{class }FMT\_API \mbox{\hyperlink{classformat__error}{format\_error}} : \textcolor{keyword}{public} std::runtime\_error \{}
\DoxyCodeLine{928  \textcolor{keyword}{public}:}
\DoxyCodeLine{929   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) : std::runtime\_error(message) \{\}}
\DoxyCodeLine{930   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{keyword}{const} std::string\& message)}
\DoxyCodeLine{931       : std::runtime\_error(message) \{\}}
\DoxyCodeLine{932   \mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{keyword}{const} \mbox{\hyperlink{classformat__error}{format\_error}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{933   \mbox{\hyperlink{classformat__error}{format\_error}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classformat__error}{format\_error}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{934   \mbox{\hyperlink{classformat__error}{format\_error}}(\mbox{\hyperlink{classformat__error}{format\_error}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{935   \mbox{\hyperlink{classformat__error}{format\_error}}\& operator=(\mbox{\hyperlink{classformat__error}{format\_error}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{936   \mbox{\hyperlink{classformat__error}{\string~format\_error}}() \textcolor{keyword}{noexcept} \textcolor{keyword}{override} FMT\_MSC\_DEFAULT;}
\DoxyCodeLine{937 \};}
\DoxyCodeLine{938 }
\DoxyCodeLine{939 \textcolor{keyword}{namespace }detail\_exported \{}
\DoxyCodeLine{940 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{941 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }fixed\_string \{}
\DoxyCodeLine{942   \textcolor{keyword}{constexpr} fixed\_string(\textcolor{keyword}{const} Char (\&str)[N]) \{}
\DoxyCodeLine{943     detail::copy\_str<Char, const Char*, Char*>(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Char*\textcolor{keyword}{>}(str),}
\DoxyCodeLine{944                                                str + N, data);}
\DoxyCodeLine{945   \}}
\DoxyCodeLine{946   Char data[N] = \{\};}
\DoxyCodeLine{947 \};}
\DoxyCodeLine{948 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{949 }
\DoxyCodeLine{950 \textcolor{comment}{// Converts a compile-\/time string to basic\_string\_view.}}
\DoxyCodeLine{951 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{952 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_string\_to\_view(\textcolor{keyword}{const} Char (\&s)[N])}
\DoxyCodeLine{953     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{954   \textcolor{comment}{// Remove trailing NUL character if needed. Won't be present if this is used}}
\DoxyCodeLine{955   \textcolor{comment}{// with a raw character array (i.e. not defined as a string).}}
\DoxyCodeLine{956   \textcolor{keywordflow}{return} \{s, N -\/ (std::char\_traits<Char>::to\_int\_type(s[N -\/ 1]) == 0 ? 1 : 0)\};}
\DoxyCodeLine{957 \}}
\DoxyCodeLine{958 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{959 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_string\_to\_view(detail::std\_string\_view<Char> s)}
\DoxyCodeLine{960     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{961   \textcolor{keywordflow}{return} \{s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}(), s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()\};}
\DoxyCodeLine{962 \}}
\DoxyCodeLine{963 \}  \textcolor{comment}{// namespace detail\_exported}}
\DoxyCodeLine{964 }
\DoxyCodeLine{965 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{966 }
\DoxyCodeLine{967 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_integral : std::is\_integral<T> \{\};}
\DoxyCodeLine{968 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }is\_integral<int128\_opt> : std::true\_type \{\};}
\DoxyCodeLine{969 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }is\_integral<uint128\_t> : std::true\_type \{\};}
\DoxyCodeLine{970 }
\DoxyCodeLine{971 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{972 \textcolor{keyword}{using }is\_signed =}
\DoxyCodeLine{973     std::integral\_constant<bool, std::numeric\_limits<T>::is\_signed ||}
\DoxyCodeLine{974                                      std::is\_same<T, int128\_opt>::value>;}
\DoxyCodeLine{975 }
\DoxyCodeLine{976 \textcolor{comment}{// Returns true if value is negative, false otherwise.}}
\DoxyCodeLine{977 \textcolor{comment}{// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.}}
\DoxyCodeLine{978 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{signed}<T>::value)>}
\DoxyCodeLine{979 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_negative(T value) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{980   \textcolor{keywordflow}{return} value < 0;}
\DoxyCodeLine{981 \}}
\DoxyCodeLine{982 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{signed}<T>::value)>}
\DoxyCodeLine{983 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_negative(T) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{984   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{985 \}}
\DoxyCodeLine{986 }
\DoxyCodeLine{987 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{988 FMT\_CONSTEXPR \textcolor{keyword}{auto} is\_supported\_floating\_point(T) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{989   \textcolor{keywordflow}{if} (std::is\_same<T, float>()) \textcolor{keywordflow}{return} FMT\_USE\_FLOAT;}
\DoxyCodeLine{990   \textcolor{keywordflow}{if} (std::is\_same<T, double>()) \textcolor{keywordflow}{return} FMT\_USE\_DOUBLE;}
\DoxyCodeLine{991   \textcolor{keywordflow}{if} (std::is\_same<T, long double>()) \textcolor{keywordflow}{return} FMT\_USE\_LONG\_DOUBLE;}
\DoxyCodeLine{992   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{993 \}}
\DoxyCodeLine{994 }
\DoxyCodeLine{995 \textcolor{comment}{// Smallest of uint32\_t, uint64\_t, uint128\_t that is large enough to}}
\DoxyCodeLine{996 \textcolor{comment}{// represent all values of an integral type T.}}
\DoxyCodeLine{997 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{998 \textcolor{keyword}{using }uint32\_or\_64\_or\_128\_t =}
\DoxyCodeLine{999     conditional\_t<num\_bits<T>() <= 32 \&\& !FMT\_REDUCE\_INT\_INSTANTIATIONS,}
\DoxyCodeLine{1000                   uint32\_t,}
\DoxyCodeLine{1001                   conditional\_t<num\_bits<T>() <= 64, uint64\_t, uint128\_t>>;}
\DoxyCodeLine{1002 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1003 \textcolor{keyword}{using }uint64\_or\_128\_t = conditional\_t<num\_bits<T>() <= 64, uint64\_t, uint128\_t>;}
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005 \textcolor{preprocessor}{\#define FMT\_POWERS\_OF\_10(factor)                                             \(\backslash\)}}
\DoxyCodeLine{1006 \textcolor{preprocessor}{  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \(\backslash\)}}
\DoxyCodeLine{1007 \textcolor{preprocessor}{      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \(\backslash\)}}
\DoxyCodeLine{1008 \textcolor{preprocessor}{      (factor)*1000000000}}
\DoxyCodeLine{1009 }
\DoxyCodeLine{1010 \textcolor{comment}{// Converts value in the range [0, 100) to a string.}}
\DoxyCodeLine{1011 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* digits2(\textcolor{keywordtype}{size\_t} value) \{}
\DoxyCodeLine{1012   \textcolor{comment}{// GCC generates slightly better code when value is pointer-\/size.}}
\DoxyCodeLine{1013   \textcolor{keywordflow}{return} \&\textcolor{stringliteral}{"{}0001020304050607080910111213141516171819"{}}}
\DoxyCodeLine{1014          \textcolor{stringliteral}{"{}2021222324252627282930313233343536373839"{}}}
\DoxyCodeLine{1015          \textcolor{stringliteral}{"{}4041424344454647484950515253545556575859"{}}}
\DoxyCodeLine{1016          \textcolor{stringliteral}{"{}6061626364656667686970717273747576777879"{}}}
\DoxyCodeLine{1017          \textcolor{stringliteral}{"{}8081828384858687888990919293949596979899"{}}[value * 2];}
\DoxyCodeLine{1018 \}}
\DoxyCodeLine{1019 }
\DoxyCodeLine{1020 \textcolor{comment}{// Sign is a template parameter to workaround a bug in gcc 4.8.}}
\DoxyCodeLine{1021 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Sign> \textcolor{keyword}{constexpr} Char sign(Sign s) \{}
\DoxyCodeLine{1022 \textcolor{preprocessor}{\#if !FMT\_GCC\_VERSION || FMT\_GCC\_VERSION >= 604}}
\DoxyCodeLine{1023   \textcolor{keyword}{static\_assert}(std::is\_same<Sign, sign\_t>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1024 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1025   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{stringliteral}{"{}\(\backslash\)0-\/+ "{}}[s]);}
\DoxyCodeLine{1026 \}}
\DoxyCodeLine{1027 }
\DoxyCodeLine{1028 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_CONSTEXPR \textcolor{keyword}{auto} count\_digits\_fallback(T n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1029   \textcolor{keywordtype}{int} count = 1;}
\DoxyCodeLine{1030   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{1031     \textcolor{comment}{// Integer division is slow so do it for a group of four digits instead}}
\DoxyCodeLine{1032     \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{1033     \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{1034     \textcolor{keywordflow}{if} (n < 10) \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{1035     \textcolor{keywordflow}{if} (n < 100) \textcolor{keywordflow}{return} count + 1;}
\DoxyCodeLine{1036     \textcolor{keywordflow}{if} (n < 1000) \textcolor{keywordflow}{return} count + 2;}
\DoxyCodeLine{1037     \textcolor{keywordflow}{if} (n < 10000) \textcolor{keywordflow}{return} count + 3;}
\DoxyCodeLine{1038     n /= 10000u;}
\DoxyCodeLine{1039     count += 4;}
\DoxyCodeLine{1040   \}}
\DoxyCodeLine{1041 \}}
\DoxyCodeLine{1042 \textcolor{preprocessor}{\#if FMT\_USE\_INT128}}
\DoxyCodeLine{1043 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} count\_digits(uint128\_opt n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1044   \textcolor{keywordflow}{return} count\_digits\_fallback(n);}
\DoxyCodeLine{1045 \}}
\DoxyCodeLine{1046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1048 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZLL}}
\DoxyCodeLine{1049 \textcolor{comment}{// It is a separate function rather than a part of count\_digits to workaround}}
\DoxyCodeLine{1050 \textcolor{comment}{// the lack of static constexpr in constexpr functions.}}
\DoxyCodeLine{1051 \textcolor{keyword}{inline} \textcolor{keyword}{auto} do\_count\_digits(uint64\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1052   \textcolor{comment}{// This has comparable performance to the version by Kendall Willets}}
\DoxyCodeLine{1053   \textcolor{comment}{// (https://github.com/fmtlib/format-\/benchmark/blob/master/digits10)}}
\DoxyCodeLine{1054   \textcolor{comment}{// but uses smaller tables.}}
\DoxyCodeLine{1055   \textcolor{comment}{// Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) -\/ 1)).}}
\DoxyCodeLine{1056   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint8\_t bsr2log10[] = \{}
\DoxyCodeLine{1057       1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,}
\DoxyCodeLine{1058       6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,}
\DoxyCodeLine{1059       10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,}
\DoxyCodeLine{1060       15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20\};}
\DoxyCodeLine{1061   \textcolor{keyword}{auto} t = bsr2log10[FMT\_BUILTIN\_CLZLL(n | 1) \string^ 63];}
\DoxyCodeLine{1062   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} uint64\_t zero\_or\_powers\_of\_10[] = \{}
\DoxyCodeLine{1063       0, 0, FMT\_POWERS\_OF\_10(1U), FMT\_POWERS\_OF\_10(1000000000ULL),}
\DoxyCodeLine{1064       10000000000000000000ULL\};}
\DoxyCodeLine{1065   \textcolor{keywordflow}{return} t -\/ (n < zero\_or\_powers\_of\_10[t]);}
\DoxyCodeLine{1066 \}}
\DoxyCodeLine{1067 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1068 }
\DoxyCodeLine{1069 \textcolor{comment}{// Returns the number of decimal digits in n. Leading zeros are not counted}}
\DoxyCodeLine{1070 \textcolor{comment}{// except for n == 0 in which case count\_digits returns 1.}}
\DoxyCodeLine{1071 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} count\_digits(uint64\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1072 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZLL}}
\DoxyCodeLine{1073   \textcolor{keywordflow}{if} (!is\_constant\_evaluated()) \{}
\DoxyCodeLine{1074     \textcolor{keywordflow}{return} do\_count\_digits(n);}
\DoxyCodeLine{1075   \}}
\DoxyCodeLine{1076 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1077   \textcolor{keywordflow}{return} count\_digits\_fallback(n);}
\DoxyCodeLine{1078 \}}
\DoxyCodeLine{1079 }
\DoxyCodeLine{1080 \textcolor{comment}{// Counts the number of digits in n. BITS = log2(radix).}}
\DoxyCodeLine{1081 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} BITS, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1082 FMT\_CONSTEXPR \textcolor{keyword}{auto} count\_digits(UInt n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1083 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1084   \textcolor{keywordflow}{if} (!is\_constant\_evaluated() \&\& num\_bits<UInt>() == 32)}
\DoxyCodeLine{1085     \textcolor{keywordflow}{return} (FMT\_BUILTIN\_CLZ(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(n) | 1) \string^ 31) / BITS + 1;}
\DoxyCodeLine{1086 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1087   \textcolor{comment}{// Lambda avoids unreachable code warnings from NVHPC.}}
\DoxyCodeLine{1088   \textcolor{keywordflow}{return} [](UInt m) \{}
\DoxyCodeLine{1089     \textcolor{keywordtype}{int} num\_digits = 0;}
\DoxyCodeLine{1090     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1091       ++num\_digits;}
\DoxyCodeLine{1092     \} \textcolor{keywordflow}{while} ((m >>= BITS) != 0);}
\DoxyCodeLine{1093     \textcolor{keywordflow}{return} num\_digits;}
\DoxyCodeLine{1094   \}(n);}
\DoxyCodeLine{1095 \}}
\DoxyCodeLine{1096 }
\DoxyCodeLine{1097 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1098 \textcolor{comment}{// It is a separate function rather than a part of count\_digits to workaround}}
\DoxyCodeLine{1099 \textcolor{comment}{// the lack of static constexpr in constexpr functions.}}
\DoxyCodeLine{1100 FMT\_INLINE \textcolor{keyword}{auto} do\_count\_digits(uint32\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1101 \textcolor{comment}{// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.}}
\DoxyCodeLine{1102 \textcolor{comment}{// This increments the upper 32 bits (log10(T) -\/ 1) when >= T is added.}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{\#  define FMT\_INC(T) (((sizeof(\#  T) -\/ 1ull) << 32) -\/ T)}}
\DoxyCodeLine{1104   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint64\_t table[] = \{}
\DoxyCodeLine{1105       FMT\_INC(0),          FMT\_INC(0),          FMT\_INC(0),           \textcolor{comment}{// 8}}
\DoxyCodeLine{1106       FMT\_INC(10),         FMT\_INC(10),         FMT\_INC(10),          \textcolor{comment}{// 64}}
\DoxyCodeLine{1107       FMT\_INC(100),        FMT\_INC(100),        FMT\_INC(100),         \textcolor{comment}{// 512}}
\DoxyCodeLine{1108       FMT\_INC(1000),       FMT\_INC(1000),       FMT\_INC(1000),        \textcolor{comment}{// 4096}}
\DoxyCodeLine{1109       FMT\_INC(10000),      FMT\_INC(10000),      FMT\_INC(10000),       \textcolor{comment}{// 32k}}
\DoxyCodeLine{1110       FMT\_INC(100000),     FMT\_INC(100000),     FMT\_INC(100000),      \textcolor{comment}{// 256k}}
\DoxyCodeLine{1111       FMT\_INC(1000000),    FMT\_INC(1000000),    FMT\_INC(1000000),     \textcolor{comment}{// 2048k}}
\DoxyCodeLine{1112       FMT\_INC(10000000),   FMT\_INC(10000000),   FMT\_INC(10000000),    \textcolor{comment}{// 16M}}
\DoxyCodeLine{1113       FMT\_INC(100000000),  FMT\_INC(100000000),  FMT\_INC(100000000),   \textcolor{comment}{// 128M}}
\DoxyCodeLine{1114       FMT\_INC(1000000000), FMT\_INC(1000000000), FMT\_INC(1000000000),  \textcolor{comment}{// 1024M}}
\DoxyCodeLine{1115       FMT\_INC(1000000000), FMT\_INC(1000000000)                        \textcolor{comment}{// 4B}}
\DoxyCodeLine{1116   \};}
\DoxyCodeLine{1117   \textcolor{keyword}{auto} inc = table[FMT\_BUILTIN\_CLZ(n | 1) \string^ 31];}
\DoxyCodeLine{1118   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((n + inc) >> 32);}
\DoxyCodeLine{1119 \}}
\DoxyCodeLine{1120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1121 }
\DoxyCodeLine{1122 \textcolor{comment}{// Optional version of count\_digits for better performance on 32-\/bit platforms.}}
\DoxyCodeLine{1123 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} count\_digits(uint32\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1124 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1125   \textcolor{keywordflow}{if} (!is\_constant\_evaluated()) \{}
\DoxyCodeLine{1126     \textcolor{keywordflow}{return} do\_count\_digits(n);}
\DoxyCodeLine{1127   \}}
\DoxyCodeLine{1128 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1129   \textcolor{keywordflow}{return} count\_digits\_fallback(n);}
\DoxyCodeLine{1130 \}}
\DoxyCodeLine{1131 }
\DoxyCodeLine{1132 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} digits10() noexcept -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1133   \textcolor{keywordflow}{return} std::numeric\_limits<Int>::digits10;}
\DoxyCodeLine{1134 \}}
\DoxyCodeLine{1135 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} digits10<int128\_opt>() noexcept -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 38; \}}
\DoxyCodeLine{1136 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} digits10<uint128\_t>() noexcept -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 38; \}}
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }thousands\_sep\_result \{}
\DoxyCodeLine{1139   std::string grouping;}
\DoxyCodeLine{1140   Char thousands\_sep;}
\DoxyCodeLine{1141 \};}
\DoxyCodeLine{1142 }
\DoxyCodeLine{1143 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1144 FMT\_API \textcolor{keyword}{auto} thousands\_sep\_impl(locale\_ref loc) -\/> thousands\_sep\_result<Char>;}
\DoxyCodeLine{1145 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1146 \textcolor{keyword}{inline} \textcolor{keyword}{auto} thousands\_sep(locale\_ref loc) -\/> thousands\_sep\_result<Char> \{}
\DoxyCodeLine{1147   \textcolor{keyword}{auto} result = thousands\_sep\_impl<char>(loc);}
\DoxyCodeLine{1148   \textcolor{keywordflow}{return} \{result.grouping, Char(result.thousands\_sep)\};}
\DoxyCodeLine{1149 \}}
\DoxyCodeLine{1150 \textcolor{keyword}{template} <>}
\DoxyCodeLine{1151 \textcolor{keyword}{inline} \textcolor{keyword}{auto} thousands\_sep(locale\_ref loc) -\/> thousands\_sep\_result<wchar\_t> \{}
\DoxyCodeLine{1152   \textcolor{keywordflow}{return} thousands\_sep\_impl<wchar\_t>(loc);}
\DoxyCodeLine{1153 \}}
\DoxyCodeLine{1154 }
\DoxyCodeLine{1155 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1156 FMT\_API \textcolor{keyword}{auto} decimal\_point\_impl(locale\_ref loc) -\/> Char;}
\DoxyCodeLine{1157 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{inline} \textcolor{keyword}{auto} decimal\_point(locale\_ref loc) -\/> Char \{}
\DoxyCodeLine{1158   \textcolor{keywordflow}{return} Char(decimal\_point\_impl<char>(loc));}
\DoxyCodeLine{1159 \}}
\DoxyCodeLine{1160 \textcolor{keyword}{template} <> \textcolor{keyword}{inline} \textcolor{keyword}{auto} decimal\_point(locale\_ref loc) -\/> \textcolor{keywordtype}{wchar\_t} \{}
\DoxyCodeLine{1161   \textcolor{keywordflow}{return} decimal\_point\_impl<wchar\_t>(loc);}
\DoxyCodeLine{1162 \}}
\DoxyCodeLine{1163 }
\DoxyCodeLine{1164 \textcolor{comment}{// Compares two characters for equality.}}
\DoxyCodeLine{1165 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{auto} equal2(\textcolor{keyword}{const} Char* lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1166   \textcolor{keywordflow}{return} lhs[0] == Char(rhs[0]) \&\& lhs[1] == Char(rhs[1]);}
\DoxyCodeLine{1167 \}}
\DoxyCodeLine{1168 \textcolor{keyword}{inline} \textcolor{keyword}{auto} equal2(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1169   \textcolor{keywordflow}{return} memcmp(lhs, rhs, 2) == 0;}
\DoxyCodeLine{1170 \}}
\DoxyCodeLine{1171 }
\DoxyCodeLine{1172 \textcolor{comment}{// Copies two characters from src to dst.}}
\DoxyCodeLine{1173 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1174 FMT\_CONSTEXPR20 FMT\_INLINE \textcolor{keywordtype}{void} copy2(Char* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* src) \{}
\DoxyCodeLine{1175   \textcolor{keywordflow}{if} (!is\_constant\_evaluated() \&\& \textcolor{keyword}{sizeof}(Char) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) \{}
\DoxyCodeLine{1176     memcpy(dst, src, 2);}
\DoxyCodeLine{1177     \textcolor{keywordflow}{return};}
\DoxyCodeLine{1178   \}}
\DoxyCodeLine{1179   *dst++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(*src++);}
\DoxyCodeLine{1180   *dst = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(*src);}
\DoxyCodeLine{1181 \}}
\DoxyCodeLine{1182 }
\DoxyCodeLine{1183 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator> \textcolor{keyword}{struct }format\_decimal\_result \{}
\DoxyCodeLine{1184   Iterator begin;}
\DoxyCodeLine{1185   Iterator end;}
\DoxyCodeLine{1186 \};}
\DoxyCodeLine{1187 }
\DoxyCodeLine{1188 \textcolor{comment}{// Formats a decimal unsigned integer value writing into out pointing to a}}
\DoxyCodeLine{1189 \textcolor{comment}{// buffer of specified size. The caller must ensure that the buffer is large}}
\DoxyCodeLine{1190 \textcolor{comment}{// enough.}}
\DoxyCodeLine{1191 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1192 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} format\_decimal(Char* out, UInt value, \textcolor{keywordtype}{int} size)}
\DoxyCodeLine{1193     -\/> format\_decimal\_result<Char*> \{}
\DoxyCodeLine{1194   FMT\_ASSERT(size >= count\_digits(value), \textcolor{stringliteral}{"{}invalid digit count"{}});}
\DoxyCodeLine{1195   out += size;}
\DoxyCodeLine{1196   Char* end = out;}
\DoxyCodeLine{1197   \textcolor{keywordflow}{while} (value >= 100) \{}
\DoxyCodeLine{1198     \textcolor{comment}{// Integer division is slow so do it for a group of two digits instead}}
\DoxyCodeLine{1199     \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{1200     \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{1201     out -\/= 2;}
\DoxyCodeLine{1202     copy2(out, digits2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(value \% 100)));}
\DoxyCodeLine{1203     value /= 100;}
\DoxyCodeLine{1204   \}}
\DoxyCodeLine{1205   \textcolor{keywordflow}{if} (value < 10) \{}
\DoxyCodeLine{1206     *-\/-\/out = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + value);}
\DoxyCodeLine{1207     \textcolor{keywordflow}{return} \{out, end\};}
\DoxyCodeLine{1208   \}}
\DoxyCodeLine{1209   out -\/= 2;}
\DoxyCodeLine{1210   copy2(out, digits2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(value)));}
\DoxyCodeLine{1211   \textcolor{keywordflow}{return} \{out, end\};}
\DoxyCodeLine{1212 \}}
\DoxyCodeLine{1213 }
\DoxyCodeLine{1214 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Iterator,}
\DoxyCodeLine{1215           FMT\_ENABLE\_IF(!std::is\_pointer<remove\_cvref\_t<Iterator>>::value)>}
\DoxyCodeLine{1216 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format\_decimal(Iterator out, UInt value, \textcolor{keywordtype}{int} size)}
\DoxyCodeLine{1217     -\/> format\_decimal\_result<Iterator> \{}
\DoxyCodeLine{1218   \textcolor{comment}{// Buffer is large enough to hold all digits (digits10 + 1).}}
\DoxyCodeLine{1219   Char \mbox{\hyperlink{classbuffer}{buffer}}[digits10<UInt>() + 1];}
\DoxyCodeLine{1220   \textcolor{keyword}{auto} end = format\_decimal(\mbox{\hyperlink{classbuffer}{buffer}}, value, size).end;}
\DoxyCodeLine{1221   \textcolor{keywordflow}{return} \{out, detail::copy\_str\_noinline<Char>(\mbox{\hyperlink{classbuffer}{buffer}}, end, out)\};}
\DoxyCodeLine{1222 \}}
\DoxyCodeLine{1223 }
\DoxyCodeLine{1224 \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BASE\_BITS, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1225 FMT\_CONSTEXPR \textcolor{keyword}{auto} format\_uint(Char* \mbox{\hyperlink{classbuffer}{buffer}}, UInt value, \textcolor{keywordtype}{int} num\_digits,}
\DoxyCodeLine{1226                                \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false}) -\/> Char* \{}
\DoxyCodeLine{1227   \mbox{\hyperlink{classbuffer}{buffer}} += num\_digits;}
\DoxyCodeLine{1228   Char* end = \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{1229   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1230     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* digits = upper ? \textcolor{stringliteral}{"{}0123456789ABCDEF"{}} : \textcolor{stringliteral}{"{}0123456789abcdef"{}};}
\DoxyCodeLine{1231     \textcolor{keywordtype}{unsigned} digit = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(value \& ((1 << BASE\_BITS) -\/ 1));}
\DoxyCodeLine{1232     *-\/-\/\mbox{\hyperlink{classbuffer}{buffer}} = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(BASE\_BITS < 4 ? static\_cast<char>(\textcolor{charliteral}{'0'} + digit)}
\DoxyCodeLine{1233                                                 : digits[digit]);}
\DoxyCodeLine{1234   \} \textcolor{keywordflow}{while} ((value >>= BASE\_BITS) != 0);}
\DoxyCodeLine{1235   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{1236 \}}
\DoxyCodeLine{1237 }
\DoxyCodeLine{1238 \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BASE\_BITS, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} It, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1239 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format\_uint(It out, UInt value, \textcolor{keywordtype}{int} num\_digits, \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false})}
\DoxyCodeLine{1240     -\/> It \{}
\DoxyCodeLine{1241   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} ptr = to\_pointer<Char>(out, to\_unsigned(num\_digits))) \{}
\DoxyCodeLine{1242     format\_uint<BASE\_BITS>(ptr, value, num\_digits, upper);}
\DoxyCodeLine{1243     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1244   \}}
\DoxyCodeLine{1245   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits / BASE\_BITS + 1).}}
\DoxyCodeLine{1246   \textcolor{keywordtype}{char} \mbox{\hyperlink{classbuffer}{buffer}}[num\_bits<UInt>() / BASE\_BITS + 1];}
\DoxyCodeLine{1247   format\_uint<BASE\_BITS>(\mbox{\hyperlink{classbuffer}{buffer}}, value, num\_digits, upper);}
\DoxyCodeLine{1248   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(\mbox{\hyperlink{classbuffer}{buffer}}, \mbox{\hyperlink{classbuffer}{buffer}} + num\_digits, out);}
\DoxyCodeLine{1249 \}}
\DoxyCodeLine{1250 }
\DoxyCodeLine{1251 \textcolor{comment}{// A converter from UTF-\/8 to UTF-\/16.}}
\DoxyCodeLine{1252 \textcolor{keyword}{class }utf8\_to\_utf16 \{}
\DoxyCodeLine{1253  \textcolor{keyword}{private}:}
\DoxyCodeLine{1254   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<wchar\_t>}} buffer\_;}
\DoxyCodeLine{1255 }
\DoxyCodeLine{1256  \textcolor{keyword}{public}:}
\DoxyCodeLine{1257   FMT\_API \textcolor{keyword}{explicit} utf8\_to\_utf16(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s);}
\DoxyCodeLine{1258   \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<wchar\_t>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{\&buffer\_[0], size()\}; \}}
\DoxyCodeLine{1259   \textcolor{keyword}{auto} size() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} buffer\_.size() -\/ 1; \}}
\DoxyCodeLine{1260   \textcolor{keyword}{auto} c\_str() const -\/> const \textcolor{keywordtype}{wchar\_t}* \{ \textcolor{keywordflow}{return} \&buffer\_[0]; \}}
\DoxyCodeLine{1261   \textcolor{keyword}{auto} str() const -\/> std::wstring \{ \textcolor{keywordflow}{return} \{\&buffer\_[0], size()\}; \}}
\DoxyCodeLine{1262 \};}
\DoxyCodeLine{1263 }
\DoxyCodeLine{1264 \textcolor{keyword}{namespace }dragonbox \{}
\DoxyCodeLine{1265 }
\DoxyCodeLine{1266 \textcolor{comment}{// Type-\/specific information that Dragonbox uses.}}
\DoxyCodeLine{1267 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }float\_info;}
\DoxyCodeLine{1268 }
\DoxyCodeLine{1269 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }float\_info<float> \{}
\DoxyCodeLine{1270   \textcolor{keyword}{using }carrier\_uint = uint32\_t;}
\DoxyCodeLine{1271   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bits = 8;}
\DoxyCodeLine{1272   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} kappa = 1;}
\DoxyCodeLine{1273   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} big\_divisor = 100;}
\DoxyCodeLine{1274   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} small\_divisor = 10;}
\DoxyCodeLine{1275   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_k = -\/31;}
\DoxyCodeLine{1276   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_k = 46;}
\DoxyCodeLine{1277   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} divisibility\_check\_by\_5\_threshold = 39;}
\DoxyCodeLine{1278   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} case\_fc\_pm\_half\_lower\_threshold = -\/1;}
\DoxyCodeLine{1279   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_lower\_threshold = -\/35;}
\DoxyCodeLine{1280   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_upper\_threshold = -\/35;}
\DoxyCodeLine{1281 \};}
\DoxyCodeLine{1282 }
\DoxyCodeLine{1283 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }float\_info<double> \{}
\DoxyCodeLine{1284   \textcolor{keyword}{using }carrier\_uint = uint64\_t;}
\DoxyCodeLine{1285   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bits = 11;}
\DoxyCodeLine{1286   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} kappa = 2;}
\DoxyCodeLine{1287   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} big\_divisor = 1000;}
\DoxyCodeLine{1288   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} small\_divisor = 100;}
\DoxyCodeLine{1289   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_k = -\/292;}
\DoxyCodeLine{1290   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_k = 326;}
\DoxyCodeLine{1291   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} divisibility\_check\_by\_5\_threshold = 86;}
\DoxyCodeLine{1292   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} case\_fc\_pm\_half\_lower\_threshold = -\/2;}
\DoxyCodeLine{1293   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_lower\_threshold = -\/77;}
\DoxyCodeLine{1294   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_upper\_threshold = -\/77;}
\DoxyCodeLine{1295 \};}
\DoxyCodeLine{1296 }
\DoxyCodeLine{1297 \textcolor{comment}{// An 80-\/ or 128-\/bit floating point number.}}
\DoxyCodeLine{1298 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1299 \textcolor{keyword}{struct }float\_info<T, enable\_if\_t<std::numeric\_limits<T>::digits == 64 ||}
\DoxyCodeLine{1300                                  std::numeric\_limits<T>::digits == 113 ||}
\DoxyCodeLine{1301                                  is\_float128<T>::value>> \{}
\DoxyCodeLine{1302   \textcolor{keyword}{using }carrier\_uint = detail::uint128\_t;}
\DoxyCodeLine{1303   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bits = 15;}
\DoxyCodeLine{1304 \};}
\DoxyCodeLine{1305 }
\DoxyCodeLine{1306 \textcolor{comment}{// A double-\/double floating point number.}}
\DoxyCodeLine{1307 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1308 \textcolor{keyword}{struct }float\_info<T, enable\_if\_t<is\_double\_double<T>::value>> \{}
\DoxyCodeLine{1309   \textcolor{keyword}{using }carrier\_uint = detail::uint128\_t;}
\DoxyCodeLine{1310 \};}
\DoxyCodeLine{1311 }
\DoxyCodeLine{1312 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }decimal\_fp \{}
\DoxyCodeLine{1313   \textcolor{keyword}{using }significand\_type = \textcolor{keyword}{typename} float\_info<T>::carrier\_uint;}
\DoxyCodeLine{1314   significand\_type significand;}
\DoxyCodeLine{1315   \textcolor{keywordtype}{int} exponent;}
\DoxyCodeLine{1316 \};}
\DoxyCodeLine{1317 }
\DoxyCodeLine{1318 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_API \textcolor{keyword}{auto} to\_decimal(T x) \textcolor{keyword}{noexcept} -\/> decimal\_fp<T>;}
\DoxyCodeLine{1319 \}  \textcolor{comment}{// namespace dragonbox}}
\DoxyCodeLine{1320 }
\DoxyCodeLine{1321 \textcolor{comment}{// Returns true iff Float has the implicit bit which is not stored.}}
\DoxyCodeLine{1322 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} has\_implicit\_bit() \{}
\DoxyCodeLine{1323   \textcolor{comment}{// An 80-\/bit FP number has a 64-\/bit significand an no implicit bit.}}
\DoxyCodeLine{1324   \textcolor{keywordflow}{return} std::numeric\_limits<Float>::digits != 64;}
\DoxyCodeLine{1325 \}}
\DoxyCodeLine{1326 }
\DoxyCodeLine{1327 \textcolor{comment}{// Returns the number of significand bits stored in Float. The implicit bit is}}
\DoxyCodeLine{1328 \textcolor{comment}{// not counted since it is not stored.}}
\DoxyCodeLine{1329 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} num\_significand\_bits() \{}
\DoxyCodeLine{1330   \textcolor{comment}{// std::numeric\_limits may not support \_\_float128.}}
\DoxyCodeLine{1331   \textcolor{keywordflow}{return} is\_float128<Float>() ? 112}
\DoxyCodeLine{1332                               : (std::numeric\_limits<Float>::digits -\/}
\DoxyCodeLine{1333                                  (has\_implicit\_bit<Float>() ? 1 : 0));}
\DoxyCodeLine{1334 \}}
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{1337 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} exponent\_mask() -\/>}
\DoxyCodeLine{1338     \textcolor{keyword}{typename} dragonbox::float\_info<Float>::carrier\_uint \{}
\DoxyCodeLine{1339   \textcolor{keyword}{using }uint = \textcolor{keyword}{typename} dragonbox::float\_info<Float>::carrier\_uint;}
\DoxyCodeLine{1340   \textcolor{keywordflow}{return} ((uint(1) << dragonbox::float\_info<Float>::exponent\_bits) -\/ 1)}
\DoxyCodeLine{1341          << num\_significand\_bits<Float>();}
\DoxyCodeLine{1342 \}}
\DoxyCodeLine{1343 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} exponent\_bias() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1344   \textcolor{comment}{// std::numeric\_limits may not support \_\_float128.}}
\DoxyCodeLine{1345   \textcolor{keywordflow}{return} is\_float128<Float>() ? 16383}
\DoxyCodeLine{1346                               : std::numeric\_limits<Float>::max\_exponent -\/ 1;}
\DoxyCodeLine{1347 \}}
\DoxyCodeLine{1348 }
\DoxyCodeLine{1349 \textcolor{comment}{// Writes the exponent exp in the form "{}[+-\/]d\{2,3\}"{} to buffer.}}
\DoxyCodeLine{1350 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} It>}
\DoxyCodeLine{1351 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_exponent(\textcolor{keywordtype}{int} exp, It it) -\/> It \{}
\DoxyCodeLine{1352   FMT\_ASSERT(-\/10000 < exp \&\& exp < 10000, \textcolor{stringliteral}{"{}exponent out of range"{}});}
\DoxyCodeLine{1353   \textcolor{keywordflow}{if} (exp < 0) \{}
\DoxyCodeLine{1354     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{1355     exp = -\/exp;}
\DoxyCodeLine{1356   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1357     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'+'});}
\DoxyCodeLine{1358   \}}
\DoxyCodeLine{1359   \textcolor{keywordflow}{if} (exp >= 100) \{}
\DoxyCodeLine{1360     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* top = digits2(to\_unsigned(exp / 100));}
\DoxyCodeLine{1361     \textcolor{keywordflow}{if} (exp >= 1000) *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(top[0]);}
\DoxyCodeLine{1362     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(top[1]);}
\DoxyCodeLine{1363     exp \%= 100;}
\DoxyCodeLine{1364   \}}
\DoxyCodeLine{1365   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* d = digits2(to\_unsigned(exp));}
\DoxyCodeLine{1366   *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(d[0]);}
\DoxyCodeLine{1367   *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(d[1]);}
\DoxyCodeLine{1368   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1369 \}}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371 \textcolor{comment}{// A floating-\/point number f * pow(2, e) where F is an unsigned type.}}
\DoxyCodeLine{1372 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F> \textcolor{keyword}{struct }basic\_fp \{}
\DoxyCodeLine{1373   F f;}
\DoxyCodeLine{1374   \textcolor{keywordtype}{int} e;}
\DoxyCodeLine{1375 }
\DoxyCodeLine{1376   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_significand\_bits =}
\DoxyCodeLine{1377       \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{sizeof}(F) * num\_bits<unsigned char>());}
\DoxyCodeLine{1378 }
\DoxyCodeLine{1379   \textcolor{keyword}{constexpr} basic\_fp() : f(0), e(0) \{\}}
\DoxyCodeLine{1380   \textcolor{keyword}{constexpr} basic\_fp(uint64\_t f\_val, \textcolor{keywordtype}{int} e\_val) : f(f\_val), e(e\_val) \{\}}
\DoxyCodeLine{1381 }
\DoxyCodeLine{1382   \textcolor{comment}{// Constructs fp from an IEEE754 floating-\/point number.}}
\DoxyCodeLine{1383   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> FMT\_CONSTEXPR basic\_fp(Float n) \{ assign(n); \}}
\DoxyCodeLine{1384 }
\DoxyCodeLine{1385   \textcolor{comment}{// Assigns n to this and return true iff predecessor is closer than successor.}}
\DoxyCodeLine{1386   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{double}\_\textcolor{keywordtype}{double}<Float>::value)>}
\DoxyCodeLine{1387   FMT\_CONSTEXPR \textcolor{keyword}{auto} assign(Float n) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1388     \textcolor{keyword}{static\_assert}(std::numeric\_limits<Float>::digits <= 113, \textcolor{stringliteral}{"{}unsupported FP"{}});}
\DoxyCodeLine{1389     \textcolor{comment}{// Assume Float is in the format [sign][exponent][significand].}}
\DoxyCodeLine{1390     \textcolor{keyword}{using }carrier\_uint = \textcolor{keyword}{typename} dragonbox::float\_info<Float>::carrier\_uint;}
\DoxyCodeLine{1391     \textcolor{keyword}{const} \textcolor{keyword}{auto} num\_float\_significand\_bits =}
\DoxyCodeLine{1392         detail::num\_significand\_bits<Float>();}
\DoxyCodeLine{1393     \textcolor{keyword}{const} \textcolor{keyword}{auto} implicit\_bit = carrier\_uint(1) << num\_float\_significand\_bits;}
\DoxyCodeLine{1394     \textcolor{keyword}{const} \textcolor{keyword}{auto} significand\_mask = implicit\_bit -\/ 1;}
\DoxyCodeLine{1395     \textcolor{keyword}{auto} u = bit\_cast<carrier\_uint>(n);}
\DoxyCodeLine{1396     f = \textcolor{keyword}{static\_cast<}F\textcolor{keyword}{>}(u \& significand\_mask);}
\DoxyCodeLine{1397     \textcolor{keyword}{auto} biased\_e = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((u \& exponent\_mask<Float>()) >>}
\DoxyCodeLine{1398                                      num\_float\_significand\_bits);}
\DoxyCodeLine{1399     \textcolor{comment}{// The predecessor is closer if n is a normalized power of 2 (f == 0)}}
\DoxyCodeLine{1400     \textcolor{comment}{// other than the smallest normalized number (biased\_e > 1).}}
\DoxyCodeLine{1401     \textcolor{keyword}{auto} is\_predecessor\_closer = f == 0 \&\& biased\_e > 1;}
\DoxyCodeLine{1402     \textcolor{keywordflow}{if} (biased\_e == 0)}
\DoxyCodeLine{1403       biased\_e = 1;  \textcolor{comment}{// Subnormals use biased exponent 1 (min exponent).}}
\DoxyCodeLine{1404     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (has\_implicit\_bit<Float>())}
\DoxyCodeLine{1405       f += \textcolor{keyword}{static\_cast<}F\textcolor{keyword}{>}(implicit\_bit);}
\DoxyCodeLine{1406     e = biased\_e -\/ exponent\_bias<Float>() -\/ num\_float\_significand\_bits;}
\DoxyCodeLine{1407     \textcolor{keywordflow}{if} (!has\_implicit\_bit<Float>()) ++e;}
\DoxyCodeLine{1408     \textcolor{keywordflow}{return} is\_predecessor\_closer;}
\DoxyCodeLine{1409   \}}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{double}\_\textcolor{keywordtype}{double}<Float>::value)>}
\DoxyCodeLine{1412   FMT\_CONSTEXPR \textcolor{keyword}{auto} assign(Float n) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1413     \textcolor{keyword}{static\_assert}(std::numeric\_limits<double>::is\_iec559, \textcolor{stringliteral}{"{}unsupported FP"{}});}
\DoxyCodeLine{1414     \textcolor{keywordflow}{return} assign(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(n));}
\DoxyCodeLine{1415   \}}
\DoxyCodeLine{1416 \};}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418 \textcolor{keyword}{using }fp = basic\_fp<unsigned long long>;}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420 \textcolor{comment}{// Normalizes the value converted from double and multiplied by (1 << SHIFT).}}
\DoxyCodeLine{1421 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} SHIFT = 0, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{1422 FMT\_CONSTEXPR basic\_fp<F> normalize(basic\_fp<F> value) \{}
\DoxyCodeLine{1423   \textcolor{comment}{// Handle subnormals.}}
\DoxyCodeLine{1424   \textcolor{keyword}{const} \textcolor{keyword}{auto} implicit\_bit = F(1) << num\_significand\_bits<double>();}
\DoxyCodeLine{1425   \textcolor{keyword}{const} \textcolor{keyword}{auto} shifted\_implicit\_bit = implicit\_bit << SHIFT;}
\DoxyCodeLine{1426   \textcolor{keywordflow}{while} ((value.f \& shifted\_implicit\_bit) == 0) \{}
\DoxyCodeLine{1427     value.f <<= 1;}
\DoxyCodeLine{1428     -\/-\/value.e;}
\DoxyCodeLine{1429   \}}
\DoxyCodeLine{1430   \textcolor{comment}{// Subtract 1 to account for hidden bit.}}
\DoxyCodeLine{1431   \textcolor{keyword}{const} \textcolor{keyword}{auto} offset = basic\_fp<F>::num\_significand\_bits -\/}
\DoxyCodeLine{1432                       num\_significand\_bits<double>() -\/ SHIFT -\/ 1;}
\DoxyCodeLine{1433   value.f <<= offset;}
\DoxyCodeLine{1434   value.e -\/= offset;}
\DoxyCodeLine{1435   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{1436 \}}
\DoxyCodeLine{1437 }
\DoxyCodeLine{1438 \textcolor{comment}{// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-\/up tie breaking.}}
\DoxyCodeLine{1439 FMT\_CONSTEXPR \textcolor{keyword}{inline} uint64\_t multiply(uint64\_t lhs, uint64\_t rhs) \{}
\DoxyCodeLine{1440 \textcolor{preprocessor}{\#if FMT\_USE\_INT128}}
\DoxyCodeLine{1441   \textcolor{keyword}{auto} product = \textcolor{keyword}{static\_cast<}\_\_uint128\_t\textcolor{keyword}{>}(lhs) * rhs;}
\DoxyCodeLine{1442   \textcolor{keyword}{auto} f = \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(product >> 64);}
\DoxyCodeLine{1443   \textcolor{keywordflow}{return} (\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(product) \& (1ULL << 63)) != 0 ? f + 1 : f;}
\DoxyCodeLine{1444 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1445   \textcolor{comment}{// Multiply 32-\/bit parts of significands.}}
\DoxyCodeLine{1446   uint64\_t mask = (1ULL << 32) -\/ 1;}
\DoxyCodeLine{1447   uint64\_t a = lhs >> 32, b = lhs \& mask;}
\DoxyCodeLine{1448   uint64\_t c = rhs >> 32, d = rhs \& mask;}
\DoxyCodeLine{1449   uint64\_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;}
\DoxyCodeLine{1450   \textcolor{comment}{// Compute mid 64-\/bit of result and round.}}
\DoxyCodeLine{1451   uint64\_t mid = (bd >> 32) + (ad \& mask) + (bc \& mask) + (1U << 31);}
\DoxyCodeLine{1452   \textcolor{keywordflow}{return} ac + (ad >> 32) + (bc >> 32) + (mid >> 32);}
\DoxyCodeLine{1453 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1454 \}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456 FMT\_CONSTEXPR \textcolor{keyword}{inline} fp operator*(fp x, fp y) \{}
\DoxyCodeLine{1457   \textcolor{keywordflow}{return} \{multiply(x.f, y.f), x.e + y.e + 64\};}
\DoxyCodeLine{1458 \}}
\DoxyCodeLine{1459 }
\DoxyCodeLine{1460 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }basic\_data \{}
\DoxyCodeLine{1461   \textcolor{comment}{// Normalized 64-\/bit significands of pow(10, k), for k = -\/348, -\/340, ..., 340.}}
\DoxyCodeLine{1462   \textcolor{comment}{// These are generated by support/compute-\/powers.py.}}
\DoxyCodeLine{1463   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint64\_t pow10\_significands[87] = \{}
\DoxyCodeLine{1464       0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,}
\DoxyCodeLine{1465       0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,}
\DoxyCodeLine{1466       0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,}
\DoxyCodeLine{1467       0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,}
\DoxyCodeLine{1468       0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,}
\DoxyCodeLine{1469       0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,}
\DoxyCodeLine{1470       0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,}
\DoxyCodeLine{1471       0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,}
\DoxyCodeLine{1472       0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,}
\DoxyCodeLine{1473       0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,}
\DoxyCodeLine{1474       0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,}
\DoxyCodeLine{1475       0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,}
\DoxyCodeLine{1476       0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,}
\DoxyCodeLine{1477       0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,}
\DoxyCodeLine{1478       0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,}
\DoxyCodeLine{1479       0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,}
\DoxyCodeLine{1480       0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,}
\DoxyCodeLine{1481       0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,}
\DoxyCodeLine{1482       0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,}
\DoxyCodeLine{1483       0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,}
\DoxyCodeLine{1484       0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,}
\DoxyCodeLine{1485       0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,}
\DoxyCodeLine{1486       0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,}
\DoxyCodeLine{1487       0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,}
\DoxyCodeLine{1488       0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,}
\DoxyCodeLine{1489       0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,}
\DoxyCodeLine{1490       0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,}
\DoxyCodeLine{1491       0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,}
\DoxyCodeLine{1492       0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,}
\DoxyCodeLine{1493   \};}
\DoxyCodeLine{1494 }
\DoxyCodeLine{1495 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}}
\DoxyCodeLine{1496 \textcolor{preprocessor}{\#  pragma GCC diagnostic push}}
\DoxyCodeLine{1497 \textcolor{preprocessor}{\#  pragma GCC diagnostic ignored "{}-\/Wnarrowing"{}}}
\DoxyCodeLine{1498 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1499   \textcolor{comment}{// Binary exponents of pow(10, k), for k = -\/348, -\/340, ..., 340, corresponding}}
\DoxyCodeLine{1500   \textcolor{comment}{// to significands above.}}
\DoxyCodeLine{1501   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} int16\_t pow10\_exponents[87] = \{}
\DoxyCodeLine{1502       -\/1220, -\/1193, -\/1166, -\/1140, -\/1113, -\/1087, -\/1060, -\/1034, -\/1007, -\/980, -\/954,}
\DoxyCodeLine{1503       -\/927,  -\/901,  -\/874,  -\/847,  -\/821,  -\/794,  -\/768,  -\/741,  -\/715,  -\/688, -\/661,}
\DoxyCodeLine{1504       -\/635,  -\/608,  -\/582,  -\/555,  -\/529,  -\/502,  -\/475,  -\/449,  -\/422,  -\/396, -\/369,}
\DoxyCodeLine{1505       -\/343,  -\/316,  -\/289,  -\/263,  -\/236,  -\/210,  -\/183,  -\/157,  -\/130,  -\/103, -\/77,}
\DoxyCodeLine{1506       -\/50,   -\/24,   3,     30,    56,    83,    109,   136,   162,   189,  216,}
\DoxyCodeLine{1507       242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,}
\DoxyCodeLine{1508       534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,}
\DoxyCodeLine{1509       827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066\};}
\DoxyCodeLine{1510 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}}
\DoxyCodeLine{1511 \textcolor{preprocessor}{\#  pragma GCC diagnostic pop}}
\DoxyCodeLine{1512 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1513 }
\DoxyCodeLine{1514   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint64\_t power\_of\_10\_64[20] = \{}
\DoxyCodeLine{1515       1, FMT\_POWERS\_OF\_10(1ULL), FMT\_POWERS\_OF\_10(1000000000ULL),}
\DoxyCodeLine{1516       10000000000000000000ULL\};}
\DoxyCodeLine{1517 \};}
\DoxyCodeLine{1518 }
\DoxyCodeLine{1519 \textcolor{preprocessor}{\#if FMT\_CPLUSPLUS < 201703L}}
\DoxyCodeLine{1520 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} uint64\_t basic\_data<T>::pow10\_significands[];}
\DoxyCodeLine{1521 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} int16\_t basic\_data<T>::pow10\_exponents[];}
\DoxyCodeLine{1522 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} uint64\_t basic\_data<T>::power\_of\_10\_64[];}
\DoxyCodeLine{1523 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1524 }
\DoxyCodeLine{1525 \textcolor{comment}{// This is a struct rather than an alias to avoid shadowing warnings in gcc.}}
\DoxyCodeLine{1526 \textcolor{keyword}{struct }data : basic\_data<> \{\};}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528 \textcolor{comment}{// Returns a cached power of 10 `c\_k = c\_k.f * pow(2, c\_k.e)` such that its}}
\DoxyCodeLine{1529 \textcolor{comment}{// (binary) exponent satisfies `min\_exponent <= c\_k.e <= min\_exponent + 28`.}}
\DoxyCodeLine{1530 FMT\_CONSTEXPR \textcolor{keyword}{inline} fp get\_cached\_power(\textcolor{keywordtype}{int} min\_exponent,}
\DoxyCodeLine{1531                                          \textcolor{keywordtype}{int}\& pow10\_exponent) \{}
\DoxyCodeLine{1532   \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = 32;}
\DoxyCodeLine{1533   \textcolor{comment}{// log10(2) = 0x0.4d104d427de7fbcc...}}
\DoxyCodeLine{1534   \textcolor{keyword}{const} int64\_t significand = 0x4d104d427de7fbcc;}
\DoxyCodeLine{1535   \textcolor{keywordtype}{int} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(}
\DoxyCodeLine{1536       ((min\_exponent + fp::num\_significand\_bits -\/ 1) * (significand >> shift) +}
\DoxyCodeLine{1537        ((int64\_t(1) << shift) -\/ 1))  \textcolor{comment}{// ceil}}
\DoxyCodeLine{1538       >> 32                          \textcolor{comment}{// arithmetic shift}}
\DoxyCodeLine{1539   );}
\DoxyCodeLine{1540   \textcolor{comment}{// Decimal exponent of the first (smallest) cached power of 10.}}
\DoxyCodeLine{1541   \textcolor{keyword}{const} \textcolor{keywordtype}{int} first\_dec\_exp = -\/348;}
\DoxyCodeLine{1542   \textcolor{comment}{// Difference between 2 consecutive decimal exponents in cached powers of 10.}}
\DoxyCodeLine{1543   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dec\_exp\_step = 8;}
\DoxyCodeLine{1544   index = (index -\/ first\_dec\_exp -\/ 1) / dec\_exp\_step + 1;}
\DoxyCodeLine{1545   pow10\_exponent = first\_dec\_exp + index * dec\_exp\_step;}
\DoxyCodeLine{1546   \textcolor{keywordflow}{return} \{data::pow10\_significands[index], data::pow10\_exponents[index]\};}
\DoxyCodeLine{1547 \}}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549 \textcolor{preprocessor}{\#ifndef \_MSC\_VER}}
\DoxyCodeLine{1550 \textcolor{preprocessor}{\#  define FMT\_SNPRINTF snprintf}}
\DoxyCodeLine{1551 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1552 FMT\_API \textcolor{keyword}{auto} fmt\_snprintf(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{size\_t} size, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* fmt, ...) -\/> int;}
\DoxyCodeLine{1553 \textcolor{preprocessor}{\#  define FMT\_SNPRINTF fmt\_snprintf}}
\DoxyCodeLine{1554 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{1555 }
\DoxyCodeLine{1556 \textcolor{comment}{// Formats a floating-\/point number with snprintf using the hexfloat format.}}
\DoxyCodeLine{1557 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1558 \textcolor{keyword}{auto} snprintf\_float(T value, \textcolor{keywordtype}{int} precision, float\_specs specs,}
\DoxyCodeLine{1559                     \mbox{\hyperlink{classbuffer}{buffer<char>}}\& buf) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1560   \textcolor{comment}{// Buffer capacity must be non-\/zero, otherwise MSVC's vsnprintf\_s will fail.}}
\DoxyCodeLine{1561   FMT\_ASSERT(buf.capacity() > buf.size(), \textcolor{stringliteral}{"{}empty buffer"{}});}
\DoxyCodeLine{1562   FMT\_ASSERT(specs.format == float\_format::hex, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1563   \textcolor{keyword}{static\_assert}(!std::is\_same<T, float>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1564 }
\DoxyCodeLine{1565   \textcolor{comment}{// Build the format string.}}
\DoxyCodeLine{1566   \textcolor{keywordtype}{char} format[7];  \textcolor{comment}{// The longest format is "{}\%\#.*Le"{}.}}
\DoxyCodeLine{1567   \textcolor{keywordtype}{char}* format\_ptr = format;}
\DoxyCodeLine{1568   *format\_ptr++ = \textcolor{charliteral}{'\%'};}
\DoxyCodeLine{1569   \textcolor{keywordflow}{if} (specs.showpoint) *format\_ptr++ = \textcolor{charliteral}{'\#'};}
\DoxyCodeLine{1570   \textcolor{keywordflow}{if} (precision >= 0) \{}
\DoxyCodeLine{1571     *format\_ptr++ = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1572     *format\_ptr++ = \textcolor{charliteral}{'*'};}
\DoxyCodeLine{1573   \}}
\DoxyCodeLine{1574   \textcolor{keywordflow}{if} (std::is\_same<T, long double>()) *format\_ptr++ = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{1575   *format\_ptr++ = specs.upper ? \textcolor{charliteral}{'A'} : \textcolor{charliteral}{'a'};}
\DoxyCodeLine{1576   *format\_ptr = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{1577 }
\DoxyCodeLine{1578   \textcolor{comment}{// Format using snprintf.}}
\DoxyCodeLine{1579   \textcolor{keyword}{auto} offset = buf.size();}
\DoxyCodeLine{1580   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{1581     \textcolor{keyword}{auto} begin = buf.data() + offset;}
\DoxyCodeLine{1582     \textcolor{keyword}{auto} capacity = buf.capacity() -\/ offset;}
\DoxyCodeLine{1583     abort\_fuzzing\_if(precision > 100000);}
\DoxyCodeLine{1584     \textcolor{comment}{// Suppress the warning about a nonliteral format string.}}
\DoxyCodeLine{1585     \textcolor{comment}{// Cannot use auto because of a bug in MinGW (\#1532).}}
\DoxyCodeLine{1586     int (*snprintf\_ptr)(\textcolor{keywordtype}{char}*, size\_t, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*, ...) = FMT\_SNPRINTF;}
\DoxyCodeLine{1587     \textcolor{keywordtype}{int} result = precision >= 0}
\DoxyCodeLine{1588                      ? snprintf\_ptr(begin, capacity, format, precision, value)}
\DoxyCodeLine{1589                      : snprintf\_ptr(begin, capacity, format, value);}
\DoxyCodeLine{1590     \textcolor{keywordflow}{if} (result < 0) \{}
\DoxyCodeLine{1591       \textcolor{comment}{// The buffer will grow exponentially.}}
\DoxyCodeLine{1592       buf.try\_reserve(buf.capacity() + 1);}
\DoxyCodeLine{1593       \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1594     \}}
\DoxyCodeLine{1595     \textcolor{keyword}{auto} size = to\_unsigned(result);}
\DoxyCodeLine{1596     \textcolor{comment}{// Size equal to capacity means that the last character was truncated.}}
\DoxyCodeLine{1597     \textcolor{keywordflow}{if} (size < capacity) \{}
\DoxyCodeLine{1598       buf.try\_resize(size + offset);}
\DoxyCodeLine{1599       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1600     \}}
\DoxyCodeLine{1601     buf.try\_reserve(size + offset + 1);  \textcolor{comment}{// Add 1 for the terminating '\(\backslash\)0'.}}
\DoxyCodeLine{1602   \}}
\DoxyCodeLine{1603 \}}
\DoxyCodeLine{1604 }
\DoxyCodeLine{1605 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1606 \textcolor{keyword}{using }convert\_float\_result =}
\DoxyCodeLine{1607     conditional\_t<std::is\_same<T, float>::value || \textcolor{keyword}{sizeof}(T) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}),}
\DoxyCodeLine{1608                   double, T>;}
\DoxyCodeLine{1609 }
\DoxyCodeLine{1610 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1611 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} convert\_float(T value) -\/> convert\_float\_result<T> \{}
\DoxyCodeLine{1612   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}convert\_float\_result<T>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{1613 \}}
\DoxyCodeLine{1614 }
\DoxyCodeLine{1615 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1616 FMT\_NOINLINE FMT\_CONSTEXPR \textcolor{keyword}{auto} fill(OutputIt it, \textcolor{keywordtype}{size\_t} n,}
\DoxyCodeLine{1617                                      \textcolor{keyword}{const} fill\_t<Char>\& fill) -\/> OutputIt \{}
\DoxyCodeLine{1618   \textcolor{keyword}{auto} fill\_size = fill.size();}
\DoxyCodeLine{1619   \textcolor{keywordflow}{if} (fill\_size == 1) \textcolor{keywordflow}{return} detail::fill\_n(it, n, fill[0]);}
\DoxyCodeLine{1620   \textcolor{keyword}{auto} data = fill.data();}
\DoxyCodeLine{1621   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; ++i)}
\DoxyCodeLine{1622     it = copy\_str<Char>(data, data + fill\_size, it);}
\DoxyCodeLine{1623   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1624 \}}
\DoxyCodeLine{1625 }
\DoxyCodeLine{1626 \textcolor{comment}{// Writes the output of f, padded according to format specifications in specs.}}
\DoxyCodeLine{1627 \textcolor{comment}{// size: output size in code units.}}
\DoxyCodeLine{1628 \textcolor{comment}{// width: output display width in (terminal) column positions.}}
\DoxyCodeLine{1629 \textcolor{keyword}{template} <align::type align = align::left, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{1630           \textcolor{keyword}{typename} F>}
\DoxyCodeLine{1631 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_padded(OutputIt out,}
\DoxyCodeLine{1632                                 \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{1633                                 \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} width, F\&\& f) -\/> OutputIt \{}
\DoxyCodeLine{1634   \textcolor{keyword}{static\_assert}(align == align::left || align == align::right, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1635   \textcolor{keywordtype}{unsigned} spec\_width = to\_unsigned(specs.width);}
\DoxyCodeLine{1636   \textcolor{keywordtype}{size\_t} padding = spec\_width > width ? spec\_width -\/ width : 0;}
\DoxyCodeLine{1637   \textcolor{comment}{// Shifts are encoded as string literals because static constexpr is not}}
\DoxyCodeLine{1638   \textcolor{comment}{// supported in constexpr functions.}}
\DoxyCodeLine{1639   \textcolor{keyword}{auto}* shifts = align == align::left ? \textcolor{stringliteral}{"{}\(\backslash\)x1f\(\backslash\)x1f\(\backslash\)x00\(\backslash\)x01"{}} : \textcolor{stringliteral}{"{}\(\backslash\)x00\(\backslash\)x1f\(\backslash\)x00\(\backslash\)x01"{}};}
\DoxyCodeLine{1640   \textcolor{keywordtype}{size\_t} left\_padding = padding >> shifts[specs.align];}
\DoxyCodeLine{1641   \textcolor{keywordtype}{size\_t} right\_padding = padding -\/ left\_padding;}
\DoxyCodeLine{1642   \textcolor{keyword}{auto} it = reserve(out, size + padding * specs.fill.size());}
\DoxyCodeLine{1643   \textcolor{keywordflow}{if} (left\_padding != 0) it = fill(it, left\_padding, specs.fill);}
\DoxyCodeLine{1644   it = f(it);}
\DoxyCodeLine{1645   \textcolor{keywordflow}{if} (right\_padding != 0) it = fill(it, right\_padding, specs.fill);}
\DoxyCodeLine{1646   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{1647 \}}
\DoxyCodeLine{1648 }
\DoxyCodeLine{1649 \textcolor{keyword}{template} <align::type align = align::left, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{1650           \textcolor{keyword}{typename} F>}
\DoxyCodeLine{1651 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} write\_padded(OutputIt out, \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{1652                             \textcolor{keywordtype}{size\_t} size, F\&\& f) -\/> OutputIt \{}
\DoxyCodeLine{1653   \textcolor{keywordflow}{return} write\_padded<align>(out, specs, size, size, f);}
\DoxyCodeLine{1654 \}}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656 \textcolor{keyword}{template} <align::type align = align::left, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1657 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_bytes(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} bytes,}
\DoxyCodeLine{1658                                \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs)}
\DoxyCodeLine{1659     -\/> OutputIt \{}
\DoxyCodeLine{1660   \textcolor{keywordflow}{return} write\_padded<align>(}
\DoxyCodeLine{1661       out, specs, bytes.size(), [bytes](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1662         const char* data = bytes.data();}
\DoxyCodeLine{1663         return copy\_str<Char>(data, data + bytes.size(), it);}
\DoxyCodeLine{1664       \});}
\DoxyCodeLine{1665 \}}
\DoxyCodeLine{1666 }
\DoxyCodeLine{1667 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UIntPtr>}
\DoxyCodeLine{1668 \textcolor{keyword}{auto} write\_ptr(OutputIt out, UIntPtr value,}
\DoxyCodeLine{1669                \textcolor{keyword}{const} basic\_format\_specs<Char>* specs) -\/> OutputIt \{}
\DoxyCodeLine{1670   \textcolor{keywordtype}{int} num\_digits = count\_digits<4>(value);}
\DoxyCodeLine{1671   \textcolor{keyword}{auto} size = to\_unsigned(num\_digits) + size\_t(2);}
\DoxyCodeLine{1672   \textcolor{keyword}{auto} write = [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1673     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{1674     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'x'});}
\DoxyCodeLine{1675     \textcolor{keywordflow}{return} format\_uint<4, Char>(it, value, num\_digits);}
\DoxyCodeLine{1676   \};}
\DoxyCodeLine{1677   \textcolor{keywordflow}{return} specs ? write\_padded<align::right>(out, *specs, size, write)}
\DoxyCodeLine{1678                : base\_iterator(out, write(reserve(out, size)));}
\DoxyCodeLine{1679 \}}
\DoxyCodeLine{1680 }
\DoxyCodeLine{1681 \textcolor{comment}{// Returns true iff the code point cp is printable.}}
\DoxyCodeLine{1682 FMT\_API \textcolor{keyword}{auto} is\_printable(uint32\_t cp) -\/> bool;}
\DoxyCodeLine{1683 }
\DoxyCodeLine{1684 \textcolor{keyword}{inline} \textcolor{keyword}{auto} needs\_escape(uint32\_t cp) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1685   \textcolor{keywordflow}{return} cp < 0x20 || cp == 0x7f || cp == \textcolor{charliteral}{'"{}'} || cp == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} ||}
\DoxyCodeLine{1686          !is\_printable(cp);}
\DoxyCodeLine{1687 \}}
\DoxyCodeLine{1688 }
\DoxyCodeLine{1689 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }find\_escape\_result \{}
\DoxyCodeLine{1690   \textcolor{keyword}{const} Char* begin;}
\DoxyCodeLine{1691   \textcolor{keyword}{const} Char* end;}
\DoxyCodeLine{1692   uint32\_t cp;}
\DoxyCodeLine{1693 \};}
\DoxyCodeLine{1694 }
\DoxyCodeLine{1695 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1696 \textcolor{keyword}{using }make\_unsigned\_char =}
\DoxyCodeLine{1697     \textcolor{keyword}{typename} conditional\_t<std::is\_integral<Char>::value,}
\DoxyCodeLine{1698                            std::make\_unsigned<Char>,}
\DoxyCodeLine{1699                            type\_identity<uint32\_t>>::type;}
\DoxyCodeLine{1700 }
\DoxyCodeLine{1701 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1702 \textcolor{keyword}{auto} find\_escape(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end)}
\DoxyCodeLine{1703     -\/> find\_escape\_result<Char> \{}
\DoxyCodeLine{1704   \textcolor{keywordflow}{for} (; begin != end; ++begin) \{}
\DoxyCodeLine{1705     uint32\_t cp = \textcolor{keyword}{static\_cast<}make\_unsigned\_char<Char>\textcolor{keyword}{>}(*begin);}
\DoxyCodeLine{1706     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(Char) == 1) \&\& cp >= 0x80) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1707     \textcolor{keywordflow}{if} (needs\_escape(cp)) \textcolor{keywordflow}{return} \{begin, begin + 1, cp\};}
\DoxyCodeLine{1708   \}}
\DoxyCodeLine{1709   \textcolor{keywordflow}{return} \{begin, \textcolor{keyword}{nullptr}, 0\};}
\DoxyCodeLine{1710 \}}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712 \textcolor{keyword}{inline} \textcolor{keyword}{auto} find\_escape(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* begin, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* end)}
\DoxyCodeLine{1713     -\/> find\_escape\_result<char> \{}
\DoxyCodeLine{1714   \textcolor{keywordflow}{if} (!is\_utf8()) \textcolor{keywordflow}{return} find\_escape<char>(begin, end);}
\DoxyCodeLine{1715   \textcolor{keyword}{auto} result = find\_escape\_result<char>\{end, \textcolor{keyword}{nullptr}, 0\};}
\DoxyCodeLine{1716   for\_each\_codepoint(\mbox{\hyperlink{classbasic__string__view}{string\_view}}(begin, to\_unsigned(end -\/ begin)),}
\DoxyCodeLine{1717                      [\&](uint32\_t cp, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sv) \{}
\DoxyCodeLine{1718                        \textcolor{keywordflow}{if} (needs\_escape(cp)) \{}
\DoxyCodeLine{1719                          result = \{sv.begin(), sv.end(), cp\};}
\DoxyCodeLine{1720                          \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1721                        \}}
\DoxyCodeLine{1722                        \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1723                      \});}
\DoxyCodeLine{1724   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1725 \}}
\DoxyCodeLine{1726 }
\DoxyCodeLine{1727 \textcolor{preprocessor}{\#define FMT\_STRING\_IMPL(s, base, explicit)                                 \(\backslash\)}}
\DoxyCodeLine{1728 \textcolor{preprocessor}{  [] \{                                                                     \(\backslash\)}}
\DoxyCodeLine{1729 \textcolor{preprocessor}{    }\textcolor{comment}{/* Use the hidden visibility as a workaround for a GCC bug (\#1973). */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1730 \textcolor{preprocessor}{    }\textcolor{comment}{/* Use a macro-\/like name to avoid shadowing warnings. */}\textcolor{preprocessor}{               \(\backslash\)}}
\DoxyCodeLine{1731 \textcolor{preprocessor}{    struct FMT\_GCC\_VISIBILITY\_HIDDEN FMT\_COMPILE\_STRING : base \{           \(\backslash\)}}
\DoxyCodeLine{1732 \textcolor{preprocessor}{      using char\_type = fmt::remove\_cvref\_t<decltype(s[0])>;               \(\backslash\)}}
\DoxyCodeLine{1733 \textcolor{preprocessor}{      FMT\_MAYBE\_UNUSED FMT\_CONSTEXPR explicit                              \(\backslash\)}}
\DoxyCodeLine{1734 \textcolor{preprocessor}{      operator fmt::basic\_string\_view<char\_type>() const \{                 \(\backslash\)}}
\DoxyCodeLine{1735 \textcolor{preprocessor}{        return fmt::detail\_exported::compile\_string\_to\_view<char\_type>(s); \(\backslash\)}}
\DoxyCodeLine{1736 \textcolor{preprocessor}{      \}                                                                    \(\backslash\)}}
\DoxyCodeLine{1737 \textcolor{preprocessor}{    \};                                                                     \(\backslash\)}}
\DoxyCodeLine{1738 \textcolor{preprocessor}{    return FMT\_COMPILE\_STRING();                                           \(\backslash\)}}
\DoxyCodeLine{1739 \textcolor{preprocessor}{  \}()}}
\DoxyCodeLine{1740 }
\DoxyCodeLine{1751 \textcolor{preprocessor}{\#define FMT\_STRING(s) FMT\_STRING\_IMPL(s, fmt::detail::compile\_string, )}}
\DoxyCodeLine{1752 }
\DoxyCodeLine{1753 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\textcolor{keywordtype}{id}th, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1754 \textcolor{keyword}{auto} write\_codepoint(OutputIt out, \textcolor{keywordtype}{char} prefix, uint32\_t cp) -\/> OutputIt \{}
\DoxyCodeLine{1755   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1756   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(prefix);}
\DoxyCodeLine{1757   Char buf[width];}
\DoxyCodeLine{1758   fill\_n(buf, width, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'}));}
\DoxyCodeLine{1759   format\_uint<4>(buf, cp, width);}
\DoxyCodeLine{1760   \textcolor{keywordflow}{return} copy\_str<Char>(buf, buf + width, out);}
\DoxyCodeLine{1761 \}}
\DoxyCodeLine{1762 }
\DoxyCodeLine{1763 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1764 \textcolor{keyword}{auto} write\_escaped\_cp(OutputIt out, \textcolor{keyword}{const} find\_escape\_result<Char>\& escape)}
\DoxyCodeLine{1765     -\/> OutputIt \{}
\DoxyCodeLine{1766   \textcolor{keyword}{auto} c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(escape.cp);}
\DoxyCodeLine{1767   \textcolor{keywordflow}{switch} (escape.cp) \{}
\DoxyCodeLine{1768   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{1769     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1770     c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'n'});}
\DoxyCodeLine{1771     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1772   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)r'}:}
\DoxyCodeLine{1773     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1774     c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'r'});}
\DoxyCodeLine{1775     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1776   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}:}
\DoxyCodeLine{1777     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1778     c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'t'});}
\DoxyCodeLine{1779     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1780   \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{1781     FMT\_FALLTHROUGH;}
\DoxyCodeLine{1782   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)''}:}
\DoxyCodeLine{1783     FMT\_FALLTHROUGH;}
\DoxyCodeLine{1784   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}:}
\DoxyCodeLine{1785     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1786     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1787   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1788     \textcolor{keywordflow}{if} (is\_utf8()) \{}
\DoxyCodeLine{1789       \textcolor{keywordflow}{if} (escape.cp < 0x100) \{}
\DoxyCodeLine{1790         \textcolor{keywordflow}{return} write\_codepoint<2, Char>(out, \textcolor{charliteral}{'x'}, escape.cp);}
\DoxyCodeLine{1791       \}}
\DoxyCodeLine{1792       \textcolor{keywordflow}{if} (escape.cp < 0x10000) \{}
\DoxyCodeLine{1793         \textcolor{keywordflow}{return} write\_codepoint<4, Char>(out, \textcolor{charliteral}{'u'}, escape.cp);}
\DoxyCodeLine{1794       \}}
\DoxyCodeLine{1795       \textcolor{keywordflow}{if} (escape.cp < 0x110000) \{}
\DoxyCodeLine{1796         \textcolor{keywordflow}{return} write\_codepoint<8, Char>(out, \textcolor{charliteral}{'U'}, escape.cp);}
\DoxyCodeLine{1797       \}}
\DoxyCodeLine{1798     \}}
\DoxyCodeLine{1799     \textcolor{keywordflow}{for} (Char escape\_char : \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(}
\DoxyCodeLine{1800              escape.begin, to\_unsigned(escape.end -\/ escape.begin))) \{}
\DoxyCodeLine{1801       out = write\_codepoint<2, Char>(out, \textcolor{charliteral}{'x'},}
\DoxyCodeLine{1802                                      \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(escape\_char) \& 0xFF);}
\DoxyCodeLine{1803     \}}
\DoxyCodeLine{1804     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1805   \}}
\DoxyCodeLine{1806   *out++ = c;}
\DoxyCodeLine{1807   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1808 \}}
\DoxyCodeLine{1809 }
\DoxyCodeLine{1810 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1811 \textcolor{keyword}{auto} write\_escaped\_string(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str)}
\DoxyCodeLine{1812     -\/> OutputIt \{}
\DoxyCodeLine{1813   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'"{}'});}
\DoxyCodeLine{1814   \textcolor{keyword}{auto} begin = str.begin(), end = str.end();}
\DoxyCodeLine{1815   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1816     \textcolor{keyword}{auto} escape = find\_escape(begin, end);}
\DoxyCodeLine{1817     out = copy\_str<Char>(begin, escape.begin, out);}
\DoxyCodeLine{1818     begin = escape.end;}
\DoxyCodeLine{1819     \textcolor{keywordflow}{if} (!begin) \textcolor{keywordflow}{break};}
\DoxyCodeLine{1820     out = write\_escaped\_cp<OutputIt, Char>(out, escape);}
\DoxyCodeLine{1821   \} \textcolor{keywordflow}{while} (begin != end);}
\DoxyCodeLine{1822   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'"{}'});}
\DoxyCodeLine{1823   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1824 \}}
\DoxyCodeLine{1825 }
\DoxyCodeLine{1826 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1827 \textcolor{keyword}{auto} write\_escaped\_char(OutputIt out, Char v) -\/> OutputIt \{}
\DoxyCodeLine{1828   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)''});}
\DoxyCodeLine{1829   \textcolor{keywordflow}{if} ((needs\_escape(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(v)) \&\& v != \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'"{}'})) ||}
\DoxyCodeLine{1830       v == \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)''})) \{}
\DoxyCodeLine{1831     out = write\_escaped\_cp(}
\DoxyCodeLine{1832         out, find\_escape\_result<Char>\{\&v, \&v + 1, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(v)\});}
\DoxyCodeLine{1833   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1834     *out++ = v;}
\DoxyCodeLine{1835   \}}
\DoxyCodeLine{1836   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)''});}
\DoxyCodeLine{1837   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1838 \}}
\DoxyCodeLine{1839 }
\DoxyCodeLine{1840 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1841 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_char(OutputIt out, Char value,}
\DoxyCodeLine{1842                               \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs)}
\DoxyCodeLine{1843     -\/> OutputIt \{}
\DoxyCodeLine{1844   \textcolor{keywordtype}{bool} is\_debug = specs.type == presentation\_type::debug;}
\DoxyCodeLine{1845   \textcolor{keywordflow}{return} write\_padded(out, specs, 1, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1846     \textcolor{keywordflow}{if} (is\_debug) \textcolor{keywordflow}{return} write\_escaped\_char(it, value);}
\DoxyCodeLine{1847     *it++ = value;}
\DoxyCodeLine{1848     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1849   \});}
\DoxyCodeLine{1850 \}}
\DoxyCodeLine{1851 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1852 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, Char value,}
\DoxyCodeLine{1853                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{1854                          locale\_ref loc = \{\}) -\/> OutputIt \{}
\DoxyCodeLine{1855   \textcolor{keywordflow}{return} check\_char\_specs(specs)}
\DoxyCodeLine{1856              ? write\_char(out, value, specs)}
\DoxyCodeLine{1857              : write(out, static\_cast<int>(value), specs, loc);}
\DoxyCodeLine{1858 \}}
\DoxyCodeLine{1859 }
\DoxyCodeLine{1860 \textcolor{comment}{// Data for write\_int that doesn't depend on output iterator type. It is used to}}
\DoxyCodeLine{1861 \textcolor{comment}{// avoid template code bloat.}}
\DoxyCodeLine{1862 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }write\_int\_data \{}
\DoxyCodeLine{1863   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{1864   \textcolor{keywordtype}{size\_t} padding;}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1866   FMT\_CONSTEXPR write\_int\_data(\textcolor{keywordtype}{int} num\_digits, \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{1867                                \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs)}
\DoxyCodeLine{1868       : size((prefix >> 24) + to\_unsigned(num\_digits)), padding(0) \{}
\DoxyCodeLine{1869     \textcolor{keywordflow}{if} (specs.align == align::numeric) \{}
\DoxyCodeLine{1870       \textcolor{keyword}{auto} width = to\_unsigned(specs.width);}
\DoxyCodeLine{1871       \textcolor{keywordflow}{if} (width > size) \{}
\DoxyCodeLine{1872         padding = width -\/ size;}
\DoxyCodeLine{1873         size = width;}
\DoxyCodeLine{1874       \}}
\DoxyCodeLine{1875     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (specs.precision > num\_digits) \{}
\DoxyCodeLine{1876       size = (prefix >> 24) + to\_unsigned(specs.precision);}
\DoxyCodeLine{1877       padding = to\_unsigned(specs.precision -\/ num\_digits);}
\DoxyCodeLine{1878     \}}
\DoxyCodeLine{1879   \}}
\DoxyCodeLine{1880 \};}
\DoxyCodeLine{1881 }
\DoxyCodeLine{1882 \textcolor{comment}{// Writes an integer in the format}}
\DoxyCodeLine{1883 \textcolor{comment}{//   <left-\/padding><prefix><numeric-\/padding><digits><right-\/padding>}}
\DoxyCodeLine{1884 \textcolor{comment}{// where <digits> are written by write\_digits(it).}}
\DoxyCodeLine{1885 \textcolor{comment}{// prefix contains chars in three lower bytes and the size in the fourth byte.}}
\DoxyCodeLine{1886 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} W>}
\DoxyCodeLine{1887 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write\_int(OutputIt out, \textcolor{keywordtype}{int} num\_digits,}
\DoxyCodeLine{1888                                         \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{1889                                         \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{1890                                         W write\_digits) -\/> OutputIt \{}
\DoxyCodeLine{1891   \textcolor{comment}{// Slightly faster check for specs.width == 0 \&\& specs.precision == -\/1.}}
\DoxyCodeLine{1892   \textcolor{keywordflow}{if} ((specs.width | (specs.precision + 1)) == 0) \{}
\DoxyCodeLine{1893     \textcolor{keyword}{auto} it = reserve(out, to\_unsigned(num\_digits) + (prefix >> 24));}
\DoxyCodeLine{1894     \textcolor{keywordflow}{if} (prefix != 0) \{}
\DoxyCodeLine{1895       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} p = prefix \& 0xffffff; p != 0; p >>= 8)}
\DoxyCodeLine{1896         *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(p \& 0xff);}
\DoxyCodeLine{1897     \}}
\DoxyCodeLine{1898     \textcolor{keywordflow}{return} base\_iterator(out, write\_digits(it));}
\DoxyCodeLine{1899   \}}
\DoxyCodeLine{1900   \textcolor{keyword}{auto} data = write\_int\_data<Char>(num\_digits, prefix, specs);}
\DoxyCodeLine{1901   \textcolor{keywordflow}{return} write\_padded<align::right>(}
\DoxyCodeLine{1902       out, specs, data.size, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1903         for (unsigned p = prefix \& 0xffffff; p != 0; p >>= 8)}
\DoxyCodeLine{1904           *it++ = static\_cast<Char>(p \& 0xff);}
\DoxyCodeLine{1905         it = detail::fill\_n(it, data.padding, static\_cast<Char>(\textcolor{stringliteral}{'0'}));}
\DoxyCodeLine{1906         return write\_digits(it);}
\DoxyCodeLine{1907       \});}
\DoxyCodeLine{1908 \}}
\DoxyCodeLine{1909 }
\DoxyCodeLine{1910 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }digit\_grouping \{}
\DoxyCodeLine{1911  \textcolor{keyword}{private}:}
\DoxyCodeLine{1912   thousands\_sep\_result<Char> sep\_;}
\DoxyCodeLine{1913 }
\DoxyCodeLine{1914   \textcolor{keyword}{struct }next\_state \{}
\DoxyCodeLine{1915     std::string::const\_iterator group;}
\DoxyCodeLine{1916     \textcolor{keywordtype}{int} pos;}
\DoxyCodeLine{1917   \};}
\DoxyCodeLine{1918   next\_state initial\_state()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{sep\_.grouping.begin(), 0\}; \}}
\DoxyCodeLine{1919 }
\DoxyCodeLine{1920   \textcolor{comment}{// Returns the next digit group separator position.}}
\DoxyCodeLine{1921   \textcolor{keywordtype}{int} next(next\_state\& state)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1922     \textcolor{keywordflow}{if} (!sep\_.thousands\_sep) \textcolor{keywordflow}{return} max\_value<int>();}
\DoxyCodeLine{1923     \textcolor{keywordflow}{if} (state.group == sep\_.grouping.end())}
\DoxyCodeLine{1924       \textcolor{keywordflow}{return} state.pos += sep\_.grouping.back();}
\DoxyCodeLine{1925     \textcolor{keywordflow}{if} (*state.group <= 0 || *state.group == max\_value<char>())}
\DoxyCodeLine{1926       \textcolor{keywordflow}{return} max\_value<int>();}
\DoxyCodeLine{1927     state.pos += *state.group++;}
\DoxyCodeLine{1928     \textcolor{keywordflow}{return} state.pos;}
\DoxyCodeLine{1929   \}}
\DoxyCodeLine{1930 }
\DoxyCodeLine{1931  \textcolor{keyword}{public}:}
\DoxyCodeLine{1932   \textcolor{keyword}{explicit} digit\_grouping(locale\_ref loc, \textcolor{keywordtype}{bool} localized = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1933     \textcolor{keywordflow}{if} (localized)}
\DoxyCodeLine{1934       sep\_ = thousands\_sep<Char>(loc);}
\DoxyCodeLine{1935     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1936       sep\_.thousands\_sep = Char();}
\DoxyCodeLine{1937   \}}
\DoxyCodeLine{1938   \textcolor{keyword}{explicit} digit\_grouping(thousands\_sep\_result<Char> sep) : sep\_(sep) \{\}}
\DoxyCodeLine{1939 }
\DoxyCodeLine{1940   Char separator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} sep\_.thousands\_sep; \}}
\DoxyCodeLine{1941 }
\DoxyCodeLine{1942   \textcolor{keywordtype}{int} count\_separators(\textcolor{keywordtype}{int} num\_digits)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1943     \textcolor{keywordtype}{int} count = 0;}
\DoxyCodeLine{1944     \textcolor{keyword}{auto} state = initial\_state();}
\DoxyCodeLine{1945     \textcolor{keywordflow}{while} (num\_digits > next(state)) ++count;}
\DoxyCodeLine{1946     \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{1947   \}}
\DoxyCodeLine{1948 }
\DoxyCodeLine{1949   \textcolor{comment}{// Applies grouping to digits and write the output to out.}}
\DoxyCodeLine{1950   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Out, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{1951   Out apply(Out out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<C>}} digits)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1952     \textcolor{keyword}{auto} num\_digits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(digits.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}());}
\DoxyCodeLine{1953     \textcolor{keyword}{auto} separators = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<int>}}();}
\DoxyCodeLine{1954     separators.push\_back(0);}
\DoxyCodeLine{1955     \textcolor{keyword}{auto} state = initial\_state();}
\DoxyCodeLine{1956     \textcolor{keywordflow}{while} (\textcolor{keywordtype}{int} i = next(state)) \{}
\DoxyCodeLine{1957       \textcolor{keywordflow}{if} (i >= num\_digits) \textcolor{keywordflow}{break};}
\DoxyCodeLine{1958       separators.push\_back(i);}
\DoxyCodeLine{1959     \}}
\DoxyCodeLine{1960     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0, sep\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(separators.size() -\/ 1);}
\DoxyCodeLine{1961          i < num\_digits; ++i) \{}
\DoxyCodeLine{1962       \textcolor{keywordflow}{if} (num\_digits -\/ i == separators[sep\_index]) \{}
\DoxyCodeLine{1963         *out++ = separator();}
\DoxyCodeLine{1964         -\/-\/sep\_index;}
\DoxyCodeLine{1965       \}}
\DoxyCodeLine{1966       *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(digits[to\_unsigned(i)]);}
\DoxyCodeLine{1967     \}}
\DoxyCodeLine{1968     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1969   \}}
\DoxyCodeLine{1970 \};}
\DoxyCodeLine{1971 }
\DoxyCodeLine{1972 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1973 \textcolor{keyword}{auto} write\_int\_localized(OutputIt out, UInt value, \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{1974                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{1975                          \textcolor{keyword}{const} digit\_grouping<Char>\& grouping) -\/> OutputIt \{}
\DoxyCodeLine{1976   \textcolor{keyword}{static\_assert}(std::is\_same<uint64\_or\_128\_t<UInt>, UInt>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1977   \textcolor{keywordtype}{int} num\_digits = count\_digits(value);}
\DoxyCodeLine{1978   \textcolor{keywordtype}{char} digits[40];}
\DoxyCodeLine{1979   format\_decimal(digits, value, num\_digits);}
\DoxyCodeLine{1980   \textcolor{keywordtype}{unsigned} size = to\_unsigned((prefix != 0 ? 1 : 0) + num\_digits +}
\DoxyCodeLine{1981                               grouping.count\_separators(num\_digits));}
\DoxyCodeLine{1982   \textcolor{keywordflow}{return} write\_padded<align::right>(}
\DoxyCodeLine{1983       out, specs, size, size, [\&](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1984         \textcolor{keywordflow}{if} (prefix != 0) *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(prefix);}
\DoxyCodeLine{1985         \textcolor{keywordflow}{return} grouping.apply(it, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(digits, to\_unsigned(num\_digits)));}
\DoxyCodeLine{1986       \});}
\DoxyCodeLine{1987 \}}
\DoxyCodeLine{1988 }
\DoxyCodeLine{1989 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1990 \textcolor{keyword}{auto} write\_int\_localized(OutputIt\& out, UInt value, \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{1991                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs, locale\_ref loc)}
\DoxyCodeLine{1992     -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1993   \textcolor{keyword}{auto} grouping = digit\_grouping<Char>(loc);}
\DoxyCodeLine{1994   out = write\_int\_localized(out, value, prefix, specs, grouping);}
\DoxyCodeLine{1995   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1996 \}}
\DoxyCodeLine{1997 }
\DoxyCodeLine{1998 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keywordtype}{void} prefix\_append(\textcolor{keywordtype}{unsigned}\& prefix, \textcolor{keywordtype}{unsigned} value) \{}
\DoxyCodeLine{1999   prefix |= prefix != 0 ? value << 8 : value;}
\DoxyCodeLine{2000   prefix += (1u + (value > 0xff ? 1 : 0)) << 24;}
\DoxyCodeLine{2001 \}}
\DoxyCodeLine{2002 }
\DoxyCodeLine{2003 \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt> \textcolor{keyword}{struct }write\_int\_arg \{}
\DoxyCodeLine{2004   UInt abs\_value;}
\DoxyCodeLine{2005   \textcolor{keywordtype}{unsigned} prefix;}
\DoxyCodeLine{2006 \};}
\DoxyCodeLine{2007 }
\DoxyCodeLine{2008 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2009 FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_write\_int\_arg(T value, sign\_t sign)}
\DoxyCodeLine{2010     -\/> write\_int\_arg<uint32\_or\_64\_or\_128\_t<T>> \{}
\DoxyCodeLine{2011   \textcolor{keyword}{auto} prefix = 0u;}
\DoxyCodeLine{2012   \textcolor{keyword}{auto} abs\_value = \textcolor{keyword}{static\_cast<}uint32\_or\_64\_or\_128\_t<T>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2013   \textcolor{keywordflow}{if} (is\_negative(value)) \{}
\DoxyCodeLine{2014     prefix = 0x01000000 | \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{2015     abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{2016   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2017     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} prefixes[4] = \{0, 0, 0x1000000u | \textcolor{charliteral}{'+'},}
\DoxyCodeLine{2018                                             0x1000000u | \textcolor{charliteral}{' '}\};}
\DoxyCodeLine{2019     prefix = prefixes[sign];}
\DoxyCodeLine{2020   \}}
\DoxyCodeLine{2021   \textcolor{keywordflow}{return} \{abs\_value, prefix\};}
\DoxyCodeLine{2022 \}}
\DoxyCodeLine{2023 }
\DoxyCodeLine{2024 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2025 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write\_int(OutputIt out, write\_int\_arg<T> arg,}
\DoxyCodeLine{2026                                         \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2027                                         locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2028   \textcolor{keyword}{static\_assert}(std::is\_same<T, uint32\_or\_64\_or\_128\_t<T>>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2029   \textcolor{keyword}{auto} abs\_value = arg.abs\_value;}
\DoxyCodeLine{2030   \textcolor{keyword}{auto} prefix = arg.prefix;}
\DoxyCodeLine{2031   \textcolor{keywordflow}{switch} (specs.type) \{}
\DoxyCodeLine{2032   \textcolor{keywordflow}{case} presentation\_type::none:}
\DoxyCodeLine{2033   \textcolor{keywordflow}{case} presentation\_type::dec: \{}
\DoxyCodeLine{2034     \textcolor{keywordflow}{if} (specs.localized \&\&}
\DoxyCodeLine{2035         write\_int\_localized(out, \textcolor{keyword}{static\_cast<}uint64\_or\_128\_t<T>\textcolor{keyword}{>}(abs\_value),}
\DoxyCodeLine{2036                             prefix, specs, loc)) \{}
\DoxyCodeLine{2037       \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2038     \}}
\DoxyCodeLine{2039     \textcolor{keyword}{auto} num\_digits = count\_digits(abs\_value);}
\DoxyCodeLine{2040     \textcolor{keywordflow}{return} write\_int(}
\DoxyCodeLine{2041         out, num\_digits, prefix, specs, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2042           \textcolor{keywordflow}{return} format\_decimal<Char>(it, abs\_value, num\_digits).end;}
\DoxyCodeLine{2043         \});}
\DoxyCodeLine{2044   \}}
\DoxyCodeLine{2045   \textcolor{keywordflow}{case} presentation\_type::hex\_lower:}
\DoxyCodeLine{2046   \textcolor{keywordflow}{case} presentation\_type::hex\_upper: \{}
\DoxyCodeLine{2047     \textcolor{keywordtype}{bool} upper = specs.type == presentation\_type::hex\_upper;}
\DoxyCodeLine{2048     \textcolor{keywordflow}{if} (specs.alt)}
\DoxyCodeLine{2049       prefix\_append(prefix, \textcolor{keywordtype}{unsigned}(upper ? \textcolor{charliteral}{'X'} : \textcolor{charliteral}{'x'}) << 8 | \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2050     \textcolor{keywordtype}{int} num\_digits = count\_digits<4>(abs\_value);}
\DoxyCodeLine{2051     \textcolor{keywordflow}{return} write\_int(}
\DoxyCodeLine{2052         out, num\_digits, prefix, specs, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2053           \textcolor{keywordflow}{return} format\_uint<4, Char>(it, abs\_value, num\_digits, upper);}
\DoxyCodeLine{2054         \});}
\DoxyCodeLine{2055   \}}
\DoxyCodeLine{2056   \textcolor{keywordflow}{case} presentation\_type::bin\_lower:}
\DoxyCodeLine{2057   \textcolor{keywordflow}{case} presentation\_type::bin\_upper: \{}
\DoxyCodeLine{2058     \textcolor{keywordtype}{bool} upper = specs.type == presentation\_type::bin\_upper;}
\DoxyCodeLine{2059     \textcolor{keywordflow}{if} (specs.alt)}
\DoxyCodeLine{2060       prefix\_append(prefix, \textcolor{keywordtype}{unsigned}(upper ? \textcolor{charliteral}{'B'} : \textcolor{charliteral}{'b'}) << 8 | \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2061     \textcolor{keywordtype}{int} num\_digits = count\_digits<1>(abs\_value);}
\DoxyCodeLine{2062     \textcolor{keywordflow}{return} write\_int(out, num\_digits, prefix, specs,}
\DoxyCodeLine{2063                      [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2064                        \textcolor{keywordflow}{return} format\_uint<1, Char>(it, abs\_value, num\_digits);}
\DoxyCodeLine{2065                      \});}
\DoxyCodeLine{2066   \}}
\DoxyCodeLine{2067   \textcolor{keywordflow}{case} presentation\_type::oct: \{}
\DoxyCodeLine{2068     \textcolor{keywordtype}{int} num\_digits = count\_digits<3>(abs\_value);}
\DoxyCodeLine{2069     \textcolor{comment}{// Octal prefix '0' is counted as a digit, so only add it if precision}}
\DoxyCodeLine{2070     \textcolor{comment}{// is not greater than the number of digits.}}
\DoxyCodeLine{2071     \textcolor{keywordflow}{if} (specs.alt \&\& specs.precision <= num\_digits \&\& abs\_value != 0)}
\DoxyCodeLine{2072       prefix\_append(prefix, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2073     \textcolor{keywordflow}{return} write\_int(out, num\_digits, prefix, specs,}
\DoxyCodeLine{2074                      [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2075                        \textcolor{keywordflow}{return} format\_uint<3, Char>(it, abs\_value, num\_digits);}
\DoxyCodeLine{2076                      \});}
\DoxyCodeLine{2077   \}}
\DoxyCodeLine{2078   \textcolor{keywordflow}{case} presentation\_type::chr:}
\DoxyCodeLine{2079     \textcolor{keywordflow}{return} write\_char(out, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(abs\_value), specs);}
\DoxyCodeLine{2080   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2081     throw\_format\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2082   \}}
\DoxyCodeLine{2083   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2084 \}}
\DoxyCodeLine{2085 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2086 FMT\_CONSTEXPR FMT\_NOINLINE \textcolor{keyword}{auto} write\_int\_noinline(}
\DoxyCodeLine{2087     OutputIt out, write\_int\_arg<T> arg, \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2088     locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2089   \textcolor{keywordflow}{return} write\_int(out, arg, specs, loc);}
\DoxyCodeLine{2090 \}}
\DoxyCodeLine{2091 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{2092           FMT\_ENABLE\_IF(is\_integral<T>::value \&\&}
\DoxyCodeLine{2093                         !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{2094                         std::is\_same<OutputIt, buffer\_appender<Char>>::value)>}
\DoxyCodeLine{2095 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{2096                                     \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2097                                     locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2098   \textcolor{keywordflow}{return} write\_int\_noinline(out, make\_write\_int\_arg(value, specs.sign), specs,}
\DoxyCodeLine{2099                             loc);}
\DoxyCodeLine{2100 \}}
\DoxyCodeLine{2101 \textcolor{comment}{// An inlined version of write used in format string compilation.}}
\DoxyCodeLine{2102 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{2103           FMT\_ENABLE\_IF(is\_integral<T>::value \&\&}
\DoxyCodeLine{2104                         !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{2105                         !std::is\_same<OutputIt, buffer\_appender<Char>>::value)>}
\DoxyCodeLine{2106 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{2107                                     \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2108                                     locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2109   \textcolor{keywordflow}{return} write\_int(out, make\_write\_int\_arg(value, specs.sign), specs, loc);}
\DoxyCodeLine{2110 \}}
\DoxyCodeLine{2111 }
\DoxyCodeLine{2112 \textcolor{comment}{// An output iterator that counts the number of objects written to it and}}
\DoxyCodeLine{2113 \textcolor{comment}{// discards them.}}
\DoxyCodeLine{2114 \textcolor{keyword}{class }counting\_iterator \{}
\DoxyCodeLine{2115  \textcolor{keyword}{private}:}
\DoxyCodeLine{2116   \textcolor{keywordtype}{size\_t} count\_;}
\DoxyCodeLine{2117 }
\DoxyCodeLine{2118  \textcolor{keyword}{public}:}
\DoxyCodeLine{2119   \textcolor{keyword}{using }iterator\_category = std::output\_iterator\_tag;}
\DoxyCodeLine{2120   \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{2121   \textcolor{keyword}{using }pointer = void;}
\DoxyCodeLine{2122   \textcolor{keyword}{using }reference = void;}
\DoxyCodeLine{2123   FMT\_UNCHECKED\_ITERATOR(counting\_iterator);}
\DoxyCodeLine{2124 }
\DoxyCodeLine{2125   \textcolor{keyword}{struct }value\_type \{}
\DoxyCodeLine{2126     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} T\&) \{\}}
\DoxyCodeLine{2127   \};}
\DoxyCodeLine{2128 }
\DoxyCodeLine{2129   counting\_iterator() : count\_(0) \{\}}
\DoxyCodeLine{2130 }
\DoxyCodeLine{2131   \textcolor{keywordtype}{size\_t} count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{2132 }
\DoxyCodeLine{2133   counting\_iterator\& operator++() \{}
\DoxyCodeLine{2134     ++count\_;}
\DoxyCodeLine{2135     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2136   \}}
\DoxyCodeLine{2137   counting\_iterator operator++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{2138     \textcolor{keyword}{auto} it = *\textcolor{keyword}{this};}
\DoxyCodeLine{2139     ++*\textcolor{keyword}{this};}
\DoxyCodeLine{2140     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2141   \}}
\DoxyCodeLine{2142 }
\DoxyCodeLine{2143   \textcolor{keyword}{friend} counting\_iterator operator+(counting\_iterator it, difference\_type n) \{}
\DoxyCodeLine{2144     it.count\_ += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n);}
\DoxyCodeLine{2145     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2146   \}}
\DoxyCodeLine{2147 }
\DoxyCodeLine{2148   value\_type operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{2149 \};}
\DoxyCodeLine{2150 }
\DoxyCodeLine{2151 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2152 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s,}
\DoxyCodeLine{2153                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs) -\/> OutputIt \{}
\DoxyCodeLine{2154   \textcolor{keyword}{auto} data = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{2155   \textcolor{keyword}{auto} size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{2156   \textcolor{keywordflow}{if} (specs.precision >= 0 \&\& to\_unsigned(specs.precision) < size)}
\DoxyCodeLine{2157     size = code\_point\_index(s, to\_unsigned(specs.precision));}
\DoxyCodeLine{2158   \textcolor{keywordtype}{bool} is\_debug = specs.type == presentation\_type::debug;}
\DoxyCodeLine{2159   \textcolor{keywordtype}{size\_t} width = 0;}
\DoxyCodeLine{2160   \textcolor{keywordflow}{if} (specs.width != 0) \{}
\DoxyCodeLine{2161     \textcolor{keywordflow}{if} (is\_debug)}
\DoxyCodeLine{2162       width = write\_escaped\_string(counting\_iterator\{\}, s).count();}
\DoxyCodeLine{2163     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2164       width = compute\_width(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(data, size));}
\DoxyCodeLine{2165   \}}
\DoxyCodeLine{2166   \textcolor{keywordflow}{return} write\_padded(out, specs, size, width,}
\DoxyCodeLine{2167                       [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2168                         \textcolor{keywordflow}{if} (is\_debug) \textcolor{keywordflow}{return} write\_escaped\_string(it, s);}
\DoxyCodeLine{2169                         \textcolor{keywordflow}{return} copy\_str<Char>(data, data + size, it);}
\DoxyCodeLine{2170                       \});}
\DoxyCodeLine{2171 \}}
\DoxyCodeLine{2172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2173 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out,}
\DoxyCodeLine{2174                          \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}<type\_identity\_t<Char>> s,}
\DoxyCodeLine{2175                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs, locale\_ref)}
\DoxyCodeLine{2176     -\/> OutputIt \{}
\DoxyCodeLine{2177   check\_string\_type\_spec(specs.type);}
\DoxyCodeLine{2178   \textcolor{keywordflow}{return} write(out, s, specs);}
\DoxyCodeLine{2179 \}}
\DoxyCodeLine{2180 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2181 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} Char* s,}
\DoxyCodeLine{2182                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs, locale\_ref)}
\DoxyCodeLine{2183     -\/> OutputIt \{}
\DoxyCodeLine{2184   \textcolor{keywordflow}{return} check\_cstring\_type\_spec(specs.type)}
\DoxyCodeLine{2185              ? write(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(s), specs, \{\})}
\DoxyCodeLine{2186              : write\_ptr<Char>(out, bit\_cast<uintptr\_t>(s), \&specs);}
\DoxyCodeLine{2187 \}}
\DoxyCodeLine{2188 }
\DoxyCodeLine{2189 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{2190           FMT\_ENABLE\_IF(is\_integral<T>::value \&\&}
\DoxyCodeLine{2191                         !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{2192                         !std::is\_same<T, Char>::value)>}
\DoxyCodeLine{2193 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{2194   \textcolor{keyword}{auto} abs\_value = \textcolor{keyword}{static\_cast<}uint32\_or\_64\_or\_128\_t<T>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2195   \textcolor{keywordtype}{bool} negative = is\_negative(value);}
\DoxyCodeLine{2196   \textcolor{comment}{// Don't do -\/abs\_value since it trips unsigned-\/integer-\/overflow sanitizer.}}
\DoxyCodeLine{2197   \textcolor{keywordflow}{if} (negative) abs\_value = \string~abs\_value + 1;}
\DoxyCodeLine{2198   \textcolor{keywordtype}{int} num\_digits = count\_digits(abs\_value);}
\DoxyCodeLine{2199   \textcolor{keyword}{auto} size = (negative ? 1 : 0) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(num\_digits);}
\DoxyCodeLine{2200   \textcolor{keyword}{auto} it = reserve(out, size);}
\DoxyCodeLine{2201   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} ptr = to\_pointer<Char>(it, size)) \{}
\DoxyCodeLine{2202     \textcolor{keywordflow}{if} (negative) *ptr++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{2203     format\_decimal<Char>(ptr, abs\_value, num\_digits);}
\DoxyCodeLine{2204     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2205   \}}
\DoxyCodeLine{2206   \textcolor{keywordflow}{if} (negative) *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{2207   it = format\_decimal<Char>(it, abs\_value, num\_digits).end;}
\DoxyCodeLine{2208   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{2209 \}}
\DoxyCodeLine{2210 }
\DoxyCodeLine{2211 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2212 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_nonfinite(OutputIt out, \textcolor{keywordtype}{bool} isnan,}
\DoxyCodeLine{2213                                      basic\_format\_specs<Char> specs,}
\DoxyCodeLine{2214                                      \textcolor{keyword}{const} float\_specs\& fspecs) -\/> OutputIt \{}
\DoxyCodeLine{2215   \textcolor{keyword}{auto} str =}
\DoxyCodeLine{2216       isnan ? (fspecs.upper ? \textcolor{stringliteral}{"{}NAN"{}} : \textcolor{stringliteral}{"{}nan"{}}) : (fspecs.upper ? \textcolor{stringliteral}{"{}INF"{}} : \textcolor{stringliteral}{"{}inf"{}});}
\DoxyCodeLine{2217   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} str\_size = 3;}
\DoxyCodeLine{2218   \textcolor{keyword}{auto} sign = fspecs.sign;}
\DoxyCodeLine{2219   \textcolor{keyword}{auto} size = str\_size + (sign ? 1 : 0);}
\DoxyCodeLine{2220   \textcolor{comment}{// Replace '0'-\/padding with space for non-\/finite values.}}
\DoxyCodeLine{2221   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_zero\_fill =}
\DoxyCodeLine{2222       specs.fill.size() == 1 \&\& *specs.fill.data() == \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{2223   \textcolor{keywordflow}{if} (is\_zero\_fill) specs.fill[0] = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{' '});}
\DoxyCodeLine{2224   \textcolor{keywordflow}{return} write\_padded(out, specs, size, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2225     \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2226     \textcolor{keywordflow}{return} copy\_str<Char>(str, str + str\_size, it);}
\DoxyCodeLine{2227   \});}
\DoxyCodeLine{2228 \}}
\DoxyCodeLine{2229 }
\DoxyCodeLine{2230 \textcolor{comment}{// A decimal floating-\/point number significand * pow(10, exp).}}
\DoxyCodeLine{2231 \textcolor{keyword}{struct }big\_decimal\_fp \{}
\DoxyCodeLine{2232   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* significand;}
\DoxyCodeLine{2233   \textcolor{keywordtype}{int} significand\_size;}
\DoxyCodeLine{2234   \textcolor{keywordtype}{int} exponent;}
\DoxyCodeLine{2235 \};}
\DoxyCodeLine{2236 }
\DoxyCodeLine{2237 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} get\_significand\_size(\textcolor{keyword}{const} big\_decimal\_fp\& f) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2238   \textcolor{keywordflow}{return} f.significand\_size;}
\DoxyCodeLine{2239 \}}
\DoxyCodeLine{2240 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2241 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_significand\_size(\textcolor{keyword}{const} dragonbox::decimal\_fp<T>\& f) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2242   \textcolor{keywordflow}{return} count\_digits(f.significand);}
\DoxyCodeLine{2243 \}}
\DoxyCodeLine{2244 }
\DoxyCodeLine{2245 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2246 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} write\_significand(OutputIt out, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* significand,}
\DoxyCodeLine{2247                                  \textcolor{keywordtype}{int} significand\_size) -\/> OutputIt \{}
\DoxyCodeLine{2248   \textcolor{keywordflow}{return} copy\_str<Char>(significand, significand + significand\_size, out);}
\DoxyCodeLine{2249 \}}
\DoxyCodeLine{2250 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{2251 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_significand(OutputIt out, UInt significand,}
\DoxyCodeLine{2252                               \textcolor{keywordtype}{int} significand\_size) -\/> OutputIt \{}
\DoxyCodeLine{2253   \textcolor{keywordflow}{return} format\_decimal<Char>(out, significand, significand\_size).end;}
\DoxyCodeLine{2254 \}}
\DoxyCodeLine{2255 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Grouping>}
\DoxyCodeLine{2256 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_significand(OutputIt out, T significand,}
\DoxyCodeLine{2257                                        \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} exponent,}
\DoxyCodeLine{2258                                        \textcolor{keyword}{const} Grouping\& grouping) -\/> OutputIt \{}
\DoxyCodeLine{2259   \textcolor{keywordflow}{if} (!grouping.separator()) \{}
\DoxyCodeLine{2260     out = write\_significand<Char>(out, significand, significand\_size);}
\DoxyCodeLine{2261     \textcolor{keywordflow}{return} detail::fill\_n(out, exponent, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'}));}
\DoxyCodeLine{2262   \}}
\DoxyCodeLine{2263   \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer}{buffer}} = \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}}();}
\DoxyCodeLine{2264   write\_significand<char>(appender(\mbox{\hyperlink{classbuffer}{buffer}}), significand, significand\_size);}
\DoxyCodeLine{2265   detail::fill\_n(appender(\mbox{\hyperlink{classbuffer}{buffer}}), exponent, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2266   \textcolor{keywordflow}{return} grouping.apply(out, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()));}
\DoxyCodeLine{2267 \}}
\DoxyCodeLine{2268 }
\DoxyCodeLine{2269 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt,}
\DoxyCodeLine{2270           FMT\_ENABLE\_IF(std::is\_integral<UInt>::value)>}
\DoxyCodeLine{2271 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_significand(Char* out, UInt significand, \textcolor{keywordtype}{int} significand\_size,}
\DoxyCodeLine{2272                               \textcolor{keywordtype}{int} integral\_size, Char decimal\_point) -\/> Char* \{}
\DoxyCodeLine{2273   \textcolor{keywordflow}{if} (!decimal\_point)}
\DoxyCodeLine{2274     \textcolor{keywordflow}{return} format\_decimal(out, significand, significand\_size).end;}
\DoxyCodeLine{2275   out += significand\_size + 1;}
\DoxyCodeLine{2276   Char* end = out;}
\DoxyCodeLine{2277   \textcolor{keywordtype}{int} floating\_size = significand\_size -\/ integral\_size;}
\DoxyCodeLine{2278   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = floating\_size / 2; i > 0; -\/-\/i) \{}
\DoxyCodeLine{2279     out -\/= 2;}
\DoxyCodeLine{2280     copy2(out, digits2(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(significand \% 100)));}
\DoxyCodeLine{2281     significand /= 100;}
\DoxyCodeLine{2282   \}}
\DoxyCodeLine{2283   \textcolor{keywordflow}{if} (floating\_size \% 2 != 0) \{}
\DoxyCodeLine{2284     *-\/-\/out = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + significand \% 10);}
\DoxyCodeLine{2285     significand /= 10;}
\DoxyCodeLine{2286   \}}
\DoxyCodeLine{2287   *-\/-\/out = decimal\_point;}
\DoxyCodeLine{2288   format\_decimal(out -\/ integral\_size, significand, integral\_size);}
\DoxyCodeLine{2289   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{2290 \}}
\DoxyCodeLine{2291 }
\DoxyCodeLine{2292 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{2293           FMT\_ENABLE\_IF(!std::is\_pointer<remove\_cvref\_t<OutputIt>>::value)>}
\DoxyCodeLine{2294 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_significand(OutputIt out, UInt significand,}
\DoxyCodeLine{2295                               \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} integral\_size,}
\DoxyCodeLine{2296                               Char decimal\_point) -\/> OutputIt \{}
\DoxyCodeLine{2297   \textcolor{comment}{// Buffer is large enough to hold digits (digits10 + 1) and a decimal point.}}
\DoxyCodeLine{2298   Char \mbox{\hyperlink{classbuffer}{buffer}}[digits10<UInt>() + 2];}
\DoxyCodeLine{2299   \textcolor{keyword}{auto} end = write\_significand(\mbox{\hyperlink{classbuffer}{buffer}}, significand, significand\_size,}
\DoxyCodeLine{2300                                integral\_size, decimal\_point);}
\DoxyCodeLine{2301   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(\mbox{\hyperlink{classbuffer}{buffer}}, end, out);}
\DoxyCodeLine{2302 \}}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2305 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_significand(OutputIt out, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* significand,}
\DoxyCodeLine{2306                                      \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} integral\_size,}
\DoxyCodeLine{2307                                      Char decimal\_point) -\/> OutputIt \{}
\DoxyCodeLine{2308   out = detail::copy\_str\_noinline<Char>(significand,}
\DoxyCodeLine{2309                                         significand + integral\_size, out);}
\DoxyCodeLine{2310   \textcolor{keywordflow}{if} (!decimal\_point) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2311   *out++ = decimal\_point;}
\DoxyCodeLine{2312   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(significand + integral\_size,}
\DoxyCodeLine{2313                                          significand + significand\_size, out);}
\DoxyCodeLine{2314 \}}
\DoxyCodeLine{2315 }
\DoxyCodeLine{2316 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Grouping>}
\DoxyCodeLine{2317 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_significand(OutputIt out, T significand,}
\DoxyCodeLine{2318                                        \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} integral\_size,}
\DoxyCodeLine{2319                                        Char decimal\_point,}
\DoxyCodeLine{2320                                        \textcolor{keyword}{const} Grouping\& grouping) -\/> OutputIt \{}
\DoxyCodeLine{2321   \textcolor{keywordflow}{if} (!grouping.separator()) \{}
\DoxyCodeLine{2322     \textcolor{keywordflow}{return} write\_significand(out, significand, significand\_size, integral\_size,}
\DoxyCodeLine{2323                              decimal\_point);}
\DoxyCodeLine{2324   \}}
\DoxyCodeLine{2325   \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer}{buffer}} = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{2326   write\_significand(buffer\_appender<Char>(\mbox{\hyperlink{classbuffer}{buffer}}), significand,}
\DoxyCodeLine{2327                     significand\_size, integral\_size, decimal\_point);}
\DoxyCodeLine{2328   grouping.apply(}
\DoxyCodeLine{2329       out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), to\_unsigned(integral\_size)));}
\DoxyCodeLine{2330   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}() + integral\_size,}
\DoxyCodeLine{2331                                          \mbox{\hyperlink{classbuffer}{buffer}}.end(), out);}
\DoxyCodeLine{2332 \}}
\DoxyCodeLine{2333 }
\DoxyCodeLine{2334 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} DecimalFP, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{2335           \textcolor{keyword}{typename} Grouping = digit\_grouping<Char>>}
\DoxyCodeLine{2336 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} do\_write\_float(OutputIt out, \textcolor{keyword}{const} DecimalFP\& f,}
\DoxyCodeLine{2337                                     \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2338                                     float\_specs fspecs, locale\_ref loc)}
\DoxyCodeLine{2339     -\/> OutputIt \{}
\DoxyCodeLine{2340   \textcolor{keyword}{auto} significand = f.significand;}
\DoxyCodeLine{2341   \textcolor{keywordtype}{int} significand\_size = get\_significand\_size(f);}
\DoxyCodeLine{2342   \textcolor{keyword}{const} Char zero = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{2343   \textcolor{keyword}{auto} sign = fspecs.sign;}
\DoxyCodeLine{2344   \textcolor{keywordtype}{size\_t} size = to\_unsigned(significand\_size) + (sign ? 1 : 0);}
\DoxyCodeLine{2345   \textcolor{keyword}{using }iterator = reserve\_iterator<OutputIt>;}
\DoxyCodeLine{2346 }
\DoxyCodeLine{2347   Char decimal\_point =}
\DoxyCodeLine{2348       fspecs.locale ? detail::decimal\_point<Char>(loc) : static\_cast<Char>(\textcolor{stringliteral}{'.'});}
\DoxyCodeLine{2349 }
\DoxyCodeLine{2350   \textcolor{keywordtype}{int} output\_exp = f.exponent + significand\_size -\/ 1;}
\DoxyCodeLine{2351   \textcolor{keyword}{auto} use\_exp\_format = [=]() \{}
\DoxyCodeLine{2352     \textcolor{keywordflow}{if} (fspecs.format == float\_format::exp) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2353     \textcolor{keywordflow}{if} (fspecs.format != float\_format::general) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2354     \textcolor{comment}{// Use the fixed notation if the exponent is in [exp\_lower, exp\_upper),}}
\DoxyCodeLine{2355     \textcolor{comment}{// e.g. 0.0001 instead of 1e-\/04. Otherwise use the exponent notation.}}
\DoxyCodeLine{2356     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp\_lower = -\/4, exp\_upper = 16;}
\DoxyCodeLine{2357     \textcolor{keywordflow}{return} output\_exp < exp\_lower ||}
\DoxyCodeLine{2358            output\_exp >= (fspecs.precision > 0 ? fspecs.precision : exp\_upper);}
\DoxyCodeLine{2359   \};}
\DoxyCodeLine{2360   \textcolor{keywordflow}{if} (use\_exp\_format()) \{}
\DoxyCodeLine{2361     \textcolor{keywordtype}{int} num\_zeros = 0;}
\DoxyCodeLine{2362     \textcolor{keywordflow}{if} (fspecs.showpoint) \{}
\DoxyCodeLine{2363       num\_zeros = fspecs.precision -\/ significand\_size;}
\DoxyCodeLine{2364       \textcolor{keywordflow}{if} (num\_zeros < 0) num\_zeros = 0;}
\DoxyCodeLine{2365       size += to\_unsigned(num\_zeros);}
\DoxyCodeLine{2366     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (significand\_size == 1) \{}
\DoxyCodeLine{2367       decimal\_point = Char();}
\DoxyCodeLine{2368     \}}
\DoxyCodeLine{2369     \textcolor{keyword}{auto} abs\_output\_exp = output\_exp >= 0 ? output\_exp : -\/output\_exp;}
\DoxyCodeLine{2370     \textcolor{keywordtype}{int} exp\_digits = 2;}
\DoxyCodeLine{2371     \textcolor{keywordflow}{if} (abs\_output\_exp >= 100) exp\_digits = abs\_output\_exp >= 1000 ? 4 : 3;}
\DoxyCodeLine{2372 }
\DoxyCodeLine{2373     size += to\_unsigned((decimal\_point ? 1 : 0) + 2 + exp\_digits);}
\DoxyCodeLine{2374     \textcolor{keywordtype}{char} exp\_char = fspecs.upper ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'e'};}
\DoxyCodeLine{2375     \textcolor{keyword}{auto} write = [=](iterator it) \{}
\DoxyCodeLine{2376       \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2377       \textcolor{comment}{// Insert a decimal point after the first digit and add an exponent.}}
\DoxyCodeLine{2378       it = write\_significand(it, significand, significand\_size, 1,}
\DoxyCodeLine{2379                              decimal\_point);}
\DoxyCodeLine{2380       \textcolor{keywordflow}{if} (num\_zeros > 0) it = detail::fill\_n(it, num\_zeros, zero);}
\DoxyCodeLine{2381       *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(exp\_char);}
\DoxyCodeLine{2382       \textcolor{keywordflow}{return} write\_exponent<Char>(output\_exp, it);}
\DoxyCodeLine{2383     \};}
\DoxyCodeLine{2384     \textcolor{keywordflow}{return} specs.width > 0 ? write\_padded<align::right>(out, specs, size, write)}
\DoxyCodeLine{2385                            : base\_iterator(out, write(reserve(out, size)));}
\DoxyCodeLine{2386   \}}
\DoxyCodeLine{2387 }
\DoxyCodeLine{2388   \textcolor{keywordtype}{int} exp = f.exponent + significand\_size;}
\DoxyCodeLine{2389   \textcolor{keywordflow}{if} (f.exponent >= 0) \{}
\DoxyCodeLine{2390     \textcolor{comment}{// 1234e5 -\/> 123400000[.0+]}}
\DoxyCodeLine{2391     size += to\_unsigned(f.exponent);}
\DoxyCodeLine{2392     \textcolor{keywordtype}{int} num\_zeros = fspecs.precision -\/ exp;}
\DoxyCodeLine{2393     abort\_fuzzing\_if(num\_zeros > 5000);}
\DoxyCodeLine{2394     \textcolor{keywordflow}{if} (fspecs.showpoint) \{}
\DoxyCodeLine{2395       ++size;}
\DoxyCodeLine{2396       \textcolor{keywordflow}{if} (num\_zeros <= 0 \&\& fspecs.format != float\_format::fixed) num\_zeros = 1;}
\DoxyCodeLine{2397       \textcolor{keywordflow}{if} (num\_zeros > 0) size += to\_unsigned(num\_zeros);}
\DoxyCodeLine{2398     \}}
\DoxyCodeLine{2399     \textcolor{keyword}{auto} grouping = Grouping(loc, fspecs.locale);}
\DoxyCodeLine{2400     size += to\_unsigned(grouping.count\_separators(exp));}
\DoxyCodeLine{2401     \textcolor{keywordflow}{return} write\_padded<align::right>(out, specs, size, [\&](iterator it) \{}
\DoxyCodeLine{2402       \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2403       it = write\_significand<Char>(it, significand, significand\_size,}
\DoxyCodeLine{2404                                    f.exponent, grouping);}
\DoxyCodeLine{2405       \textcolor{keywordflow}{if} (!fspecs.showpoint) \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2406       *it++ = decimal\_point;}
\DoxyCodeLine{2407       \textcolor{keywordflow}{return} num\_zeros > 0 ? detail::fill\_n(it, num\_zeros, zero) : it;}
\DoxyCodeLine{2408     \});}
\DoxyCodeLine{2409   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exp > 0) \{}
\DoxyCodeLine{2410     \textcolor{comment}{// 1234e-\/2 -\/> 12.34[0+]}}
\DoxyCodeLine{2411     \textcolor{keywordtype}{int} num\_zeros = fspecs.showpoint ? fspecs.precision -\/ significand\_size : 0;}
\DoxyCodeLine{2412     size += 1 + to\_unsigned(num\_zeros > 0 ? num\_zeros : 0);}
\DoxyCodeLine{2413     \textcolor{keyword}{auto} grouping = Grouping(loc, fspecs.locale);}
\DoxyCodeLine{2414     size += to\_unsigned(grouping.count\_separators(significand\_size));}
\DoxyCodeLine{2415     \textcolor{keywordflow}{return} write\_padded<align::right>(out, specs, size, [\&](iterator it) \{}
\DoxyCodeLine{2416       \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2417       it = write\_significand(it, significand, significand\_size, exp,}
\DoxyCodeLine{2418                              decimal\_point, grouping);}
\DoxyCodeLine{2419       \textcolor{keywordflow}{return} num\_zeros > 0 ? detail::fill\_n(it, num\_zeros, zero) : it;}
\DoxyCodeLine{2420     \});}
\DoxyCodeLine{2421   \}}
\DoxyCodeLine{2422   \textcolor{comment}{// 1234e-\/6 -\/> 0.001234}}
\DoxyCodeLine{2423   \textcolor{keywordtype}{int} num\_zeros = -\/exp;}
\DoxyCodeLine{2424   \textcolor{keywordflow}{if} (significand\_size == 0 \&\& fspecs.precision >= 0 \&\&}
\DoxyCodeLine{2425       fspecs.precision < num\_zeros) \{}
\DoxyCodeLine{2426     num\_zeros = fspecs.precision;}
\DoxyCodeLine{2427   \}}
\DoxyCodeLine{2428   \textcolor{keywordtype}{bool} pointy = num\_zeros != 0 || significand\_size != 0 || fspecs.showpoint;}
\DoxyCodeLine{2429   size += 1 + (pointy ? 1 : 0) + to\_unsigned(num\_zeros);}
\DoxyCodeLine{2430   \textcolor{keywordflow}{return} write\_padded<align::right>(out, specs, size, [\&](iterator it) \{}
\DoxyCodeLine{2431     \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2432     *it++ = zero;}
\DoxyCodeLine{2433     \textcolor{keywordflow}{if} (!pointy) \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2434     *it++ = decimal\_point;}
\DoxyCodeLine{2435     it = detail::fill\_n(it, num\_zeros, zero);}
\DoxyCodeLine{2436     \textcolor{keywordflow}{return} write\_significand<Char>(it, significand, significand\_size);}
\DoxyCodeLine{2437   \});}
\DoxyCodeLine{2438 \}}
\DoxyCodeLine{2439 }
\DoxyCodeLine{2440 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }fallback\_digit\_grouping \{}
\DoxyCodeLine{2441  \textcolor{keyword}{public}:}
\DoxyCodeLine{2442   \textcolor{keyword}{constexpr} fallback\_digit\_grouping(locale\_ref, \textcolor{keywordtype}{bool}) \{\}}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444   \textcolor{keyword}{constexpr} Char separator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} Char(); \}}
\DoxyCodeLine{2445 }
\DoxyCodeLine{2446   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} count\_separators(\textcolor{keywordtype}{int})\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{2447 }
\DoxyCodeLine{2448   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Out, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{2449   \textcolor{keyword}{constexpr} Out apply(Out out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<C>}})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2450     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2451   \}}
\DoxyCodeLine{2452 \};}
\DoxyCodeLine{2453 }
\DoxyCodeLine{2454 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} DecimalFP, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2455 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_float(OutputIt out, \textcolor{keyword}{const} DecimalFP\& f,}
\DoxyCodeLine{2456                                  \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2457                                  float\_specs fspecs, locale\_ref loc)}
\DoxyCodeLine{2458     -\/> OutputIt \{}
\DoxyCodeLine{2459   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{2460     \textcolor{keywordflow}{return} do\_write\_float<OutputIt, DecimalFP, Char,}
\DoxyCodeLine{2461                           fallback\_digit\_grouping<Char>>(out, f, specs, fspecs,}
\DoxyCodeLine{2462                                                          loc);}
\DoxyCodeLine{2463   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2464     \textcolor{keywordflow}{return} do\_write\_float(out, f, specs, fspecs, loc);}
\DoxyCodeLine{2465   \}}
\DoxyCodeLine{2466 \}}
\DoxyCodeLine{2467 }
\DoxyCodeLine{2468 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} isnan(T value) \{}
\DoxyCodeLine{2469   \textcolor{keywordflow}{return} !(value >= value);  \textcolor{comment}{// std::isnan doesn't support \_\_float128.}}
\DoxyCodeLine{2470 \}}
\DoxyCodeLine{2471 }
\DoxyCodeLine{2472 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{2473 \textcolor{keyword}{struct }has\_isfinite : std::false\_type \{\};}
\DoxyCodeLine{2474 }
\DoxyCodeLine{2475 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2476 \textcolor{keyword}{struct }has\_isfinite<T, enable\_if\_t<sizeof(std::isfinite(T())) != 0>>}
\DoxyCodeLine{2477     : std::true\_type \{\};}
\DoxyCodeLine{2478 }
\DoxyCodeLine{2479 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{float}ing\_po\textcolor{keywordtype}{int}<T>::value\&\&}
\DoxyCodeLine{2480                                         has\_isfinite<T>::value)>}
\DoxyCodeLine{2481 FMT\_CONSTEXPR20 \textcolor{keywordtype}{bool} isfinite(T value) \{}
\DoxyCodeLine{2482   \textcolor{keyword}{constexpr} T inf = T(std::numeric\_limits<double>::infinity());}
\DoxyCodeLine{2483   \textcolor{keywordflow}{if} (is\_constant\_evaluated())}
\DoxyCodeLine{2484     \textcolor{keywordflow}{return} !detail::isnan(value) \&\& value != inf \&\& value != -\/inf;}
\DoxyCodeLine{2485   \textcolor{keywordflow}{return} std::isfinite(value);}
\DoxyCodeLine{2486 \}}
\DoxyCodeLine{2487 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!has\_isfinite<T>::value)>}
\DoxyCodeLine{2488 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} isfinite(T value) \{}
\DoxyCodeLine{2489   T inf = T(std::numeric\_limits<double>::infinity());}
\DoxyCodeLine{2490   \textcolor{comment}{// std::isfinite doesn't support \_\_float128.}}
\DoxyCodeLine{2491   \textcolor{keywordflow}{return} !detail::isnan(value) \&\& value != inf \&\& value != -\/inf;}
\DoxyCodeLine{2492 \}}
\DoxyCodeLine{2493 }
\DoxyCodeLine{2494 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{float}ing\_po\textcolor{keywordtype}{int}<T>::value)>}
\DoxyCodeLine{2495 FMT\_INLINE FMT\_CONSTEXPR \textcolor{keywordtype}{bool} signbit(T value) \{}
\DoxyCodeLine{2496   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{2497 \textcolor{preprocessor}{\#ifdef \_\_cpp\_if\_constexpr}}
\DoxyCodeLine{2498     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::numeric\_limits<double>::is\_iec559) \{}
\DoxyCodeLine{2499       \textcolor{keyword}{auto} bits = detail::bit\_cast<uint64\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{2500       \textcolor{keywordflow}{return} (bits >> (num\_bits<uint64\_t>() -\/ 1)) != 0;}
\DoxyCodeLine{2501     \}}
\DoxyCodeLine{2502 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2503   \}}
\DoxyCodeLine{2504   \textcolor{keywordflow}{return} std::signbit(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{2505 \}}
\DoxyCodeLine{2506 }
\DoxyCodeLine{2507 \textcolor{keyword}{enum class} round\_direction \{ unknown, up, down \};}
\DoxyCodeLine{2508 }
\DoxyCodeLine{2509 \textcolor{comment}{// Given the divisor (normally a power of 10), the remainder = v \% divisor for}}
\DoxyCodeLine{2510 \textcolor{comment}{// some number v and the error, returns whether v should be rounded up, down, or}}
\DoxyCodeLine{2511 \textcolor{comment}{// whether the rounding direction can't be determined due to error.}}
\DoxyCodeLine{2512 \textcolor{comment}{// error should be less than divisor / 2.}}
\DoxyCodeLine{2513 FMT\_CONSTEXPR \textcolor{keyword}{inline} round\_direction get\_round\_direction(uint64\_t divisor,}
\DoxyCodeLine{2514                                                          uint64\_t remainder,}
\DoxyCodeLine{2515                                                          uint64\_t error) \{}
\DoxyCodeLine{2516   FMT\_ASSERT(remainder < divisor, \textcolor{stringliteral}{"{}"{}});  \textcolor{comment}{// divisor -\/ remainder won't overflow.}}
\DoxyCodeLine{2517   FMT\_ASSERT(error < divisor, \textcolor{stringliteral}{"{}"{}});      \textcolor{comment}{// divisor -\/ error won't overflow.}}
\DoxyCodeLine{2518   FMT\_ASSERT(error < divisor -\/ error, \textcolor{stringliteral}{"{}"{}});  \textcolor{comment}{// error * 2 won't overflow.}}
\DoxyCodeLine{2519   \textcolor{comment}{// Round down if (remainder + error) * 2 <= divisor.}}
\DoxyCodeLine{2520   \textcolor{keywordflow}{if} (remainder <= divisor -\/ remainder \&\& error * 2 <= divisor -\/ remainder * 2)}
\DoxyCodeLine{2521     \textcolor{keywordflow}{return} round\_direction::down;}
\DoxyCodeLine{2522   \textcolor{comment}{// Round up if (remainder -\/ error) * 2 >= divisor.}}
\DoxyCodeLine{2523   \textcolor{keywordflow}{if} (remainder >= error \&\&}
\DoxyCodeLine{2524       remainder -\/ error >= divisor -\/ (remainder -\/ error)) \{}
\DoxyCodeLine{2525     \textcolor{keywordflow}{return} round\_direction::up;}
\DoxyCodeLine{2526   \}}
\DoxyCodeLine{2527   \textcolor{keywordflow}{return} round\_direction::unknown;}
\DoxyCodeLine{2528 \}}
\DoxyCodeLine{2529 }
\DoxyCodeLine{2530 \textcolor{keyword}{namespace }digits \{}
\DoxyCodeLine{2531 \textcolor{keyword}{enum} result \{}
\DoxyCodeLine{2532   more,  \textcolor{comment}{// Generate more digits.}}
\DoxyCodeLine{2533   done,  \textcolor{comment}{// Done generating digits.}}
\DoxyCodeLine{2534   error  \textcolor{comment}{// Digit generation cancelled due to an error.}}
\DoxyCodeLine{2535 \};}
\DoxyCodeLine{2536 \}}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538 \textcolor{keyword}{struct }gen\_digits\_handler \{}
\DoxyCodeLine{2539   \textcolor{keywordtype}{char}* buf;}
\DoxyCodeLine{2540   \textcolor{keywordtype}{int} size;}
\DoxyCodeLine{2541   \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{2542   \textcolor{keywordtype}{int} exp10;}
\DoxyCodeLine{2543   \textcolor{keywordtype}{bool} fixed;}
\DoxyCodeLine{2544 }
\DoxyCodeLine{2545   FMT\_CONSTEXPR digits::result on\_digit(\textcolor{keywordtype}{char} digit, uint64\_t divisor,}
\DoxyCodeLine{2546                                         uint64\_t remainder, uint64\_t error,}
\DoxyCodeLine{2547                                         \textcolor{keywordtype}{bool} integral) \{}
\DoxyCodeLine{2548     FMT\_ASSERT(remainder < divisor, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2549     buf[size++] = digit;}
\DoxyCodeLine{2550     \textcolor{keywordflow}{if} (!integral \&\& error >= remainder) \textcolor{keywordflow}{return} digits::error;}
\DoxyCodeLine{2551     \textcolor{keywordflow}{if} (size < precision) \textcolor{keywordflow}{return} digits::more;}
\DoxyCodeLine{2552     \textcolor{keywordflow}{if} (!integral) \{}
\DoxyCodeLine{2553       \textcolor{comment}{// Check if error * 2 < divisor with overflow prevention.}}
\DoxyCodeLine{2554       \textcolor{comment}{// The check is not needed for the integral part because error = 1}}
\DoxyCodeLine{2555       \textcolor{comment}{// and divisor > (1 << 32) there.}}
\DoxyCodeLine{2556       \textcolor{keywordflow}{if} (error >= divisor || error >= divisor -\/ error) \textcolor{keywordflow}{return} digits::error;}
\DoxyCodeLine{2557     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2558       FMT\_ASSERT(error == 1 \&\& divisor > 2, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2559     \}}
\DoxyCodeLine{2560     \textcolor{keyword}{auto} dir = get\_round\_direction(divisor, remainder, error);}
\DoxyCodeLine{2561     \textcolor{keywordflow}{if} (dir != round\_direction::up)}
\DoxyCodeLine{2562       \textcolor{keywordflow}{return} dir == round\_direction::down ? digits::done : digits::error;}
\DoxyCodeLine{2563     ++buf[size -\/ 1];}
\DoxyCodeLine{2564     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = size -\/ 1; i > 0 \&\& buf[i] > \textcolor{charliteral}{'9'}; -\/-\/i) \{}
\DoxyCodeLine{2565       buf[i] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2566       ++buf[i -\/ 1];}
\DoxyCodeLine{2567     \}}
\DoxyCodeLine{2568     \textcolor{keywordflow}{if} (buf[0] > \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2569       buf[0] = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{2570       \textcolor{keywordflow}{if} (fixed)}
\DoxyCodeLine{2571         buf[size++] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2572       \textcolor{keywordflow}{else}}
\DoxyCodeLine{2573         ++exp10;}
\DoxyCodeLine{2574     \}}
\DoxyCodeLine{2575     \textcolor{keywordflow}{return} digits::done;}
\DoxyCodeLine{2576   \}}
\DoxyCodeLine{2577 \};}
\DoxyCodeLine{2578 }
\DoxyCodeLine{2579 \textcolor{keyword}{inline} FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} adjust\_precision(\textcolor{keywordtype}{int}\& precision, \textcolor{keywordtype}{int} exp10) \{}
\DoxyCodeLine{2580   \textcolor{comment}{// Adjust fixed precision by exponent because it is relative to decimal}}
\DoxyCodeLine{2581   \textcolor{comment}{// point.}}
\DoxyCodeLine{2582   \textcolor{keywordflow}{if} (exp10 > 0 \&\& precision > max\_value<int>() -\/ exp10)}
\DoxyCodeLine{2583     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{2584   precision += exp10;}
\DoxyCodeLine{2585 \}}
\DoxyCodeLine{2586 }
\DoxyCodeLine{2587 \textcolor{comment}{// Generates output using the Grisu digit-\/gen algorithm.}}
\DoxyCodeLine{2588 \textcolor{comment}{// error: the size of the region (lower, upper) outside of which numbers}}
\DoxyCodeLine{2589 \textcolor{comment}{// definitely do not round to value (Delta in Grisu3).}}
\DoxyCodeLine{2590 FMT\_INLINE FMT\_CONSTEXPR20 \textcolor{keyword}{auto} grisu\_gen\_digits(fp value, uint64\_t error,}
\DoxyCodeLine{2591                                                  \textcolor{keywordtype}{int}\& exp,}
\DoxyCodeLine{2592                                                  gen\_digits\_handler\& handler)}
\DoxyCodeLine{2593     -\/> digits::result \{}
\DoxyCodeLine{2594   \textcolor{keyword}{const} fp one(1ULL << -\/value.e, value.e);}
\DoxyCodeLine{2595   \textcolor{comment}{// The integral part of scaled value (p1 in Grisu) = value / one. It cannot be}}
\DoxyCodeLine{2596   \textcolor{comment}{// zero because it contains a product of two 64-\/bit numbers with MSB set (due}}
\DoxyCodeLine{2597   \textcolor{comment}{// to normalization) -\/ 1, shifted right by at most 60 bits.}}
\DoxyCodeLine{2598   \textcolor{keyword}{auto} integral = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(value.f >> -\/one.e);}
\DoxyCodeLine{2599   FMT\_ASSERT(integral != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2600   FMT\_ASSERT(integral == value.f >> -\/one.e, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2601   \textcolor{comment}{// The fractional part of scaled value (p2 in Grisu) c = value \% one.}}
\DoxyCodeLine{2602   uint64\_t fractional = value.f \& (one.f -\/ 1);}
\DoxyCodeLine{2603   exp = count\_digits(integral);  \textcolor{comment}{// kappa in Grisu.}}
\DoxyCodeLine{2604   \textcolor{comment}{// Non-\/fixed formats require at least one digit and no precision adjustment.}}
\DoxyCodeLine{2605   \textcolor{keywordflow}{if} (handler.fixed) \{}
\DoxyCodeLine{2606     adjust\_precision(handler.precision, exp + handler.exp10);}
\DoxyCodeLine{2607     \textcolor{comment}{// Check if precision is satisfied just by leading zeros, e.g.}}
\DoxyCodeLine{2608     \textcolor{comment}{// format("{}\{:.2f\}"{}, 0.001) gives "{}0.00"{} without generating any digits.}}
\DoxyCodeLine{2609     \textcolor{keywordflow}{if} (handler.precision <= 0) \{}
\DoxyCodeLine{2610       \textcolor{keywordflow}{if} (handler.precision < 0) \textcolor{keywordflow}{return} digits::done;}
\DoxyCodeLine{2611       \textcolor{comment}{// Divide by 10 to prevent overflow.}}
\DoxyCodeLine{2612       uint64\_t divisor = data::power\_of\_10\_64[exp -\/ 1] << -\/one.e;}
\DoxyCodeLine{2613       \textcolor{keyword}{auto} dir = get\_round\_direction(divisor, value.f / 10, error * 10);}
\DoxyCodeLine{2614       \textcolor{keywordflow}{if} (dir == round\_direction::unknown) \textcolor{keywordflow}{return} digits::error;}
\DoxyCodeLine{2615       handler.buf[handler.size++] = dir == round\_direction::up ? \textcolor{charliteral}{'1'} : \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2616       \textcolor{keywordflow}{return} digits::done;}
\DoxyCodeLine{2617     \}}
\DoxyCodeLine{2618   \}}
\DoxyCodeLine{2619   \textcolor{comment}{// Generate digits for the integral part. This can produce up to 10 digits.}}
\DoxyCodeLine{2620   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2621     uint32\_t digit = 0;}
\DoxyCodeLine{2622     \textcolor{keyword}{auto} divmod\_integral = [\&](uint32\_t divisor) \{}
\DoxyCodeLine{2623       digit = integral / divisor;}
\DoxyCodeLine{2624       integral \%= divisor;}
\DoxyCodeLine{2625     \};}
\DoxyCodeLine{2626     \textcolor{comment}{// This optimization by Milo Yip reduces the number of integer divisions by}}
\DoxyCodeLine{2627     \textcolor{comment}{// one per iteration.}}
\DoxyCodeLine{2628     \textcolor{keywordflow}{switch} (exp) \{}
\DoxyCodeLine{2629     \textcolor{keywordflow}{case} 10:}
\DoxyCodeLine{2630       divmod\_integral(1000000000);}
\DoxyCodeLine{2631       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2632     \textcolor{keywordflow}{case} 9:}
\DoxyCodeLine{2633       divmod\_integral(100000000);}
\DoxyCodeLine{2634       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2635     \textcolor{keywordflow}{case} 8:}
\DoxyCodeLine{2636       divmod\_integral(10000000);}
\DoxyCodeLine{2637       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2638     \textcolor{keywordflow}{case} 7:}
\DoxyCodeLine{2639       divmod\_integral(1000000);}
\DoxyCodeLine{2640       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2641     \textcolor{keywordflow}{case} 6:}
\DoxyCodeLine{2642       divmod\_integral(100000);}
\DoxyCodeLine{2643       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2644     \textcolor{keywordflow}{case} 5:}
\DoxyCodeLine{2645       divmod\_integral(10000);}
\DoxyCodeLine{2646       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2647     \textcolor{keywordflow}{case} 4:}
\DoxyCodeLine{2648       divmod\_integral(1000);}
\DoxyCodeLine{2649       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2650     \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{2651       divmod\_integral(100);}
\DoxyCodeLine{2652       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2653     \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{2654       divmod\_integral(10);}
\DoxyCodeLine{2655       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2656     \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{2657       digit = integral;}
\DoxyCodeLine{2658       integral = 0;}
\DoxyCodeLine{2659       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2660     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2661       FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}invalid number of digits"{}});}
\DoxyCodeLine{2662     \}}
\DoxyCodeLine{2663     -\/-\/exp;}
\DoxyCodeLine{2664     \textcolor{keyword}{auto} remainder = (\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(integral) << -\/one.e) + fractional;}
\DoxyCodeLine{2665     \textcolor{keyword}{auto} result = handler.on\_digit(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit),}
\DoxyCodeLine{2666                                    data::power\_of\_10\_64[exp] << -\/one.e,}
\DoxyCodeLine{2667                                    remainder, error, \textcolor{keyword}{true});}
\DoxyCodeLine{2668     \textcolor{keywordflow}{if} (result != digits::more) \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2669   \} \textcolor{keywordflow}{while} (exp > 0);}
\DoxyCodeLine{2670   \textcolor{comment}{// Generate digits for the fractional part.}}
\DoxyCodeLine{2671   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2672     fractional *= 10;}
\DoxyCodeLine{2673     error *= 10;}
\DoxyCodeLine{2674     \textcolor{keywordtype}{char} digit = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + (fractional >> -\/one.e));}
\DoxyCodeLine{2675     fractional \&= one.f -\/ 1;}
\DoxyCodeLine{2676     -\/-\/exp;}
\DoxyCodeLine{2677     \textcolor{keyword}{auto} result = handler.on\_digit(digit, one.f, fractional, error, \textcolor{keyword}{false});}
\DoxyCodeLine{2678     \textcolor{keywordflow}{if} (result != digits::more) \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2679   \}}
\DoxyCodeLine{2680 \}}
\DoxyCodeLine{2681 }
\DoxyCodeLine{2682 \textcolor{keyword}{class }bigint \{}
\DoxyCodeLine{2683  \textcolor{keyword}{private}:}
\DoxyCodeLine{2684   \textcolor{comment}{// A bigint is stored as an array of bigits (big digits), with bigit at index}}
\DoxyCodeLine{2685   \textcolor{comment}{// 0 being the least significant one.}}
\DoxyCodeLine{2686   \textcolor{keyword}{using }bigit = uint32\_t;}
\DoxyCodeLine{2687   \textcolor{keyword}{using }double\_bigit = uint64\_t;}
\DoxyCodeLine{2688   \textcolor{keyword}{enum} \{ bigits\_capacity = 32 \};}
\DoxyCodeLine{2689   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<bigit, bigits\_capacity>}} bigits\_;}
\DoxyCodeLine{2690   \textcolor{keywordtype}{int} exp\_;}
\DoxyCodeLine{2691 }
\DoxyCodeLine{2692   FMT\_CONSTEXPR20 bigit operator[](\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2693     \textcolor{keywordflow}{return} bigits\_[to\_unsigned(index)];}
\DoxyCodeLine{2694   \}}
\DoxyCodeLine{2695   FMT\_CONSTEXPR20 bigit\& operator[](\textcolor{keywordtype}{int} index) \{}
\DoxyCodeLine{2696     \textcolor{keywordflow}{return} bigits\_[to\_unsigned(index)];}
\DoxyCodeLine{2697   \}}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} bigit\_bits = num\_bits<bigit>();}
\DoxyCodeLine{2700 }
\DoxyCodeLine{2701   \textcolor{keyword}{friend} \textcolor{keyword}{struct }formatter<bigint>;}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} subtract\_bigits(\textcolor{keywordtype}{int} index, bigit other, bigit\& borrow) \{}
\DoxyCodeLine{2704     \textcolor{keyword}{auto} result = \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}((*this)[index]) -\/ other -\/ borrow;}
\DoxyCodeLine{2705     (*this)[index] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result);}
\DoxyCodeLine{2706     borrow = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result >> (bigit\_bits * 2 -\/ 1));}
\DoxyCodeLine{2707   \}}
\DoxyCodeLine{2708 }
\DoxyCodeLine{2709   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} remove\_leading\_zeros() \{}
\DoxyCodeLine{2710     \textcolor{keywordtype}{int} num\_bigits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.size()) -\/ 1;}
\DoxyCodeLine{2711     \textcolor{keywordflow}{while} (num\_bigits > 0 \&\& (*\textcolor{keyword}{this})[num\_bigits] == 0) -\/-\/num\_bigits;}
\DoxyCodeLine{2712     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(to\_unsigned(num\_bigits + 1));}
\DoxyCodeLine{2713   \}}
\DoxyCodeLine{2714 }
\DoxyCodeLine{2715   \textcolor{comment}{// Computes *this -\/= other assuming aligned bigints and *this >= other.}}
\DoxyCodeLine{2716   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} subtract\_aligned(\textcolor{keyword}{const} bigint\& other) \{}
\DoxyCodeLine{2717     FMT\_ASSERT(other.exp\_ >= exp\_, \textcolor{stringliteral}{"{}unaligned bigints"{}});}
\DoxyCodeLine{2718     FMT\_ASSERT(compare(*\textcolor{keyword}{this}, other) >= 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2719     bigit borrow = 0;}
\DoxyCodeLine{2720     \textcolor{keywordtype}{int} i = other.exp\_ -\/ exp\_;}
\DoxyCodeLine{2721     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} j = 0, n = other.bigits\_.size(); j != n; ++i, ++j)}
\DoxyCodeLine{2722       subtract\_bigits(i, other.bigits\_[j], borrow);}
\DoxyCodeLine{2723     \textcolor{keywordflow}{while} (borrow > 0) subtract\_bigits(i, 0, borrow);}
\DoxyCodeLine{2724     remove\_leading\_zeros();}
\DoxyCodeLine{2725   \}}
\DoxyCodeLine{2726 }
\DoxyCodeLine{2727   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} multiply(uint32\_t value) \{}
\DoxyCodeLine{2728     \textcolor{keyword}{const} double\_bigit wide\_value = value;}
\DoxyCodeLine{2729     bigit carry = 0;}
\DoxyCodeLine{2730     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, n = bigits\_.size(); i < n; ++i) \{}
\DoxyCodeLine{2731       double\_bigit result = bigits\_[i] * wide\_value + carry;}
\DoxyCodeLine{2732       bigits\_[i] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result);}
\DoxyCodeLine{2733       carry = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result >> bigit\_bits);}
\DoxyCodeLine{2734     \}}
\DoxyCodeLine{2735     \textcolor{keywordflow}{if} (carry != 0) bigits\_.push\_back(carry);}
\DoxyCodeLine{2736   \}}
\DoxyCodeLine{2737 }
\DoxyCodeLine{2738   \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt, FMT\_ENABLE\_IF(std::is\_same<UInt, u\textcolor{keywordtype}{int}64\_t>::value ||}
\DoxyCodeLine{2739                                          std::is\_same<UInt, u\textcolor{keywordtype}{int}128\_t>::value)>}
\DoxyCodeLine{2740   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} multiply(UInt value) \{}
\DoxyCodeLine{2741     \textcolor{keyword}{using }half\_uint =}
\DoxyCodeLine{2742         conditional\_t<std::is\_same<UInt, uint128\_t>::value, uint64\_t, uint32\_t>;}
\DoxyCodeLine{2743     \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = num\_bits<half\_uint>() -\/ bigit\_bits;}
\DoxyCodeLine{2744     \textcolor{keyword}{const} UInt lower = \textcolor{keyword}{static\_cast<}half\_uint\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2745     \textcolor{keyword}{const} UInt upper = value >> num\_bits<half\_uint>();}
\DoxyCodeLine{2746     UInt carry = 0;}
\DoxyCodeLine{2747     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, n = bigits\_.size(); i < n; ++i) \{}
\DoxyCodeLine{2748       UInt result = lower * bigits\_[i] + \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(carry);}
\DoxyCodeLine{2749       carry = (upper * bigits\_[i] << shift) + (result >> bigit\_bits) +}
\DoxyCodeLine{2750               (carry >> bigit\_bits);}
\DoxyCodeLine{2751       bigits\_[i] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result);}
\DoxyCodeLine{2752     \}}
\DoxyCodeLine{2753     \textcolor{keywordflow}{while} (carry != 0) \{}
\DoxyCodeLine{2754       bigits\_.push\_back(\textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(carry));}
\DoxyCodeLine{2755       carry >>= bigit\_bits;}
\DoxyCodeLine{2756     \}}
\DoxyCodeLine{2757   \}}
\DoxyCodeLine{2758 }
\DoxyCodeLine{2759   \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt, FMT\_ENABLE\_IF(std::is\_same<UInt, u\textcolor{keywordtype}{int}64\_t>::value ||}
\DoxyCodeLine{2760                                          std::is\_same<UInt, u\textcolor{keywordtype}{int}128\_t>::value)>}
\DoxyCodeLine{2761   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} assign(UInt n) \{}
\DoxyCodeLine{2762     \textcolor{keywordtype}{size\_t} num\_bigits = 0;}
\DoxyCodeLine{2763     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2764       bigits\_[num\_bigits++] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(n);}
\DoxyCodeLine{2765       n >>= bigit\_bits;}
\DoxyCodeLine{2766     \} \textcolor{keywordflow}{while} (n != 0);}
\DoxyCodeLine{2767     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(num\_bigits);}
\DoxyCodeLine{2768     exp\_ = 0;}
\DoxyCodeLine{2769   \}}
\DoxyCodeLine{2770 }
\DoxyCodeLine{2771  \textcolor{keyword}{public}:}
\DoxyCodeLine{2772   FMT\_CONSTEXPR20 bigint() : exp\_(0) \{\}}
\DoxyCodeLine{2773   \textcolor{keyword}{explicit} bigint(uint64\_t n) \{ assign(n); \}}
\DoxyCodeLine{2774 }
\DoxyCodeLine{2775   bigint(\textcolor{keyword}{const} bigint\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2776   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} bigint\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2777 }
\DoxyCodeLine{2778   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} assign(\textcolor{keyword}{const} bigint\& other) \{}
\DoxyCodeLine{2779     \textcolor{keyword}{auto} size = other.bigits\_.size();}
\DoxyCodeLine{2780     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(size);}
\DoxyCodeLine{2781     \textcolor{keyword}{auto} data = other.bigits\_.data();}
\DoxyCodeLine{2782     std::copy(data, data + size, make\_checked(bigits\_.data(), size));}
\DoxyCodeLine{2783     exp\_ = other.exp\_;}
\DoxyCodeLine{2784   \}}
\DoxyCodeLine{2785 }
\DoxyCodeLine{2786   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} operator=(Int n) \{}
\DoxyCodeLine{2787     FMT\_ASSERT(n > 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2788     assign(uint64\_or\_128\_t<Int>(n));}
\DoxyCodeLine{2789   \}}
\DoxyCodeLine{2790 }
\DoxyCodeLine{2791   FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} num\_bigits()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2792     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.size()) + exp\_;}
\DoxyCodeLine{2793   \}}
\DoxyCodeLine{2794 }
\DoxyCodeLine{2795   FMT\_NOINLINE FMT\_CONSTEXPR20 bigint\& operator<<=(\textcolor{keywordtype}{int} shift) \{}
\DoxyCodeLine{2796     FMT\_ASSERT(shift >= 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2797     exp\_ += shift / bigit\_bits;}
\DoxyCodeLine{2798     shift \%= bigit\_bits;}
\DoxyCodeLine{2799     \textcolor{keywordflow}{if} (shift == 0) \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2800     bigit carry = 0;}
\DoxyCodeLine{2801     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, n = bigits\_.size(); i < n; ++i) \{}
\DoxyCodeLine{2802       bigit c = bigits\_[i] >> (bigit\_bits -\/ shift);}
\DoxyCodeLine{2803       bigits\_[i] = (bigits\_[i] << shift) + carry;}
\DoxyCodeLine{2804       carry = c;}
\DoxyCodeLine{2805     \}}
\DoxyCodeLine{2806     \textcolor{keywordflow}{if} (carry != 0) bigits\_.push\_back(carry);}
\DoxyCodeLine{2807     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2808   \}}
\DoxyCodeLine{2809 }
\DoxyCodeLine{2810   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> FMT\_CONSTEXPR20 bigint\& operator*=(Int value) \{}
\DoxyCodeLine{2811     FMT\_ASSERT(value > 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2812     multiply(uint32\_or\_64\_or\_128\_t<Int>(value));}
\DoxyCodeLine{2813     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2814   \}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816   \textcolor{keyword}{friend} FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} compare(\textcolor{keyword}{const} bigint\& lhs, \textcolor{keyword}{const} bigint\& rhs) \{}
\DoxyCodeLine{2817     \textcolor{keywordtype}{int} num\_lhs\_bigits = lhs.num\_bigits(), num\_rhs\_bigits = rhs.num\_bigits();}
\DoxyCodeLine{2818     \textcolor{keywordflow}{if} (num\_lhs\_bigits != num\_rhs\_bigits)}
\DoxyCodeLine{2819       \textcolor{keywordflow}{return} num\_lhs\_bigits > num\_rhs\_bigits ? 1 : -\/1;}
\DoxyCodeLine{2820     \textcolor{keywordtype}{int} i = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(lhs.bigits\_.size()) -\/ 1;}
\DoxyCodeLine{2821     \textcolor{keywordtype}{int} j = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(rhs.bigits\_.size()) -\/ 1;}
\DoxyCodeLine{2822     \textcolor{keywordtype}{int} end = i -\/ j;}
\DoxyCodeLine{2823     \textcolor{keywordflow}{if} (end < 0) end = 0;}
\DoxyCodeLine{2824     \textcolor{keywordflow}{for} (; i >= end; -\/-\/i, -\/-\/j) \{}
\DoxyCodeLine{2825       bigit lhs\_bigit = lhs[i], rhs\_bigit = rhs[j];}
\DoxyCodeLine{2826       \textcolor{keywordflow}{if} (lhs\_bigit != rhs\_bigit) \textcolor{keywordflow}{return} lhs\_bigit > rhs\_bigit ? 1 : -\/1;}
\DoxyCodeLine{2827     \}}
\DoxyCodeLine{2828     \textcolor{keywordflow}{if} (i != j) \textcolor{keywordflow}{return} i > j ? 1 : -\/1;}
\DoxyCodeLine{2829     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2830   \}}
\DoxyCodeLine{2831 }
\DoxyCodeLine{2832   \textcolor{comment}{// Returns compare(lhs1 + lhs2, rhs).}}
\DoxyCodeLine{2833   \textcolor{keyword}{friend} FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} add\_compare(\textcolor{keyword}{const} bigint\& lhs1, \textcolor{keyword}{const} bigint\& lhs2,}
\DoxyCodeLine{2834                                          \textcolor{keyword}{const} bigint\& rhs) \{}
\DoxyCodeLine{2835     \textcolor{keyword}{auto} minimum = [](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} a < b ? a : b; \};}
\DoxyCodeLine{2836     \textcolor{keyword}{auto} maximum = [](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} a > b ? a : b; \};}
\DoxyCodeLine{2837     \textcolor{keywordtype}{int} max\_lhs\_bigits = maximum(lhs1.num\_bigits(), lhs2.num\_bigits());}
\DoxyCodeLine{2838     \textcolor{keywordtype}{int} num\_rhs\_bigits = rhs.num\_bigits();}
\DoxyCodeLine{2839     \textcolor{keywordflow}{if} (max\_lhs\_bigits + 1 < num\_rhs\_bigits) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2840     \textcolor{keywordflow}{if} (max\_lhs\_bigits > num\_rhs\_bigits) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2841     \textcolor{keyword}{auto} get\_bigit = [](\textcolor{keyword}{const} bigint\& n, \textcolor{keywordtype}{int} i) -\/> bigit \{}
\DoxyCodeLine{2842       \textcolor{keywordflow}{return} i >= n.exp\_ \&\& i < n.num\_bigits() ? n[i -\/ n.exp\_] : 0;}
\DoxyCodeLine{2843     \};}
\DoxyCodeLine{2844     double\_bigit borrow = 0;}
\DoxyCodeLine{2845     \textcolor{keywordtype}{int} min\_exp = minimum(minimum(lhs1.exp\_, lhs2.exp\_), rhs.exp\_);}
\DoxyCodeLine{2846     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = num\_rhs\_bigits -\/ 1; i >= min\_exp; -\/-\/i) \{}
\DoxyCodeLine{2847       double\_bigit sum =}
\DoxyCodeLine{2848           \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}(get\_bigit(lhs1, i)) + get\_bigit(lhs2, i);}
\DoxyCodeLine{2849       bigit rhs\_bigit = get\_bigit(rhs, i);}
\DoxyCodeLine{2850       \textcolor{keywordflow}{if} (sum > rhs\_bigit + borrow) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2851       borrow = rhs\_bigit + borrow -\/ sum;}
\DoxyCodeLine{2852       \textcolor{keywordflow}{if} (borrow > 1) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2853       borrow <<= bigit\_bits;}
\DoxyCodeLine{2854     \}}
\DoxyCodeLine{2855     \textcolor{keywordflow}{return} borrow != 0 ? -\/1 : 0;}
\DoxyCodeLine{2856   \}}
\DoxyCodeLine{2857 }
\DoxyCodeLine{2858   \textcolor{comment}{// Assigns pow(10, exp) to this bigint.}}
\DoxyCodeLine{2859   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} assign\_pow10(\textcolor{keywordtype}{int} exp) \{}
\DoxyCodeLine{2860     FMT\_ASSERT(exp >= 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2861     \textcolor{keywordflow}{if} (exp == 0) \textcolor{keywordflow}{return} *\textcolor{keyword}{this} = 1;}
\DoxyCodeLine{2862     \textcolor{comment}{// Find the top bit.}}
\DoxyCodeLine{2863     \textcolor{keywordtype}{int} bitmask = 1;}
\DoxyCodeLine{2864     \textcolor{keywordflow}{while} (exp >= bitmask) bitmask <<= 1;}
\DoxyCodeLine{2865     bitmask >>= 1;}
\DoxyCodeLine{2866     \textcolor{comment}{// pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by}}
\DoxyCodeLine{2867     \textcolor{comment}{// repeated squaring and multiplication.}}
\DoxyCodeLine{2868     *\textcolor{keyword}{this} = 5;}
\DoxyCodeLine{2869     bitmask >>= 1;}
\DoxyCodeLine{2870     \textcolor{keywordflow}{while} (bitmask != 0) \{}
\DoxyCodeLine{2871       square();}
\DoxyCodeLine{2872       \textcolor{keywordflow}{if} ((exp \& bitmask) != 0) *\textcolor{keyword}{this} *= 5;}
\DoxyCodeLine{2873       bitmask >>= 1;}
\DoxyCodeLine{2874     \}}
\DoxyCodeLine{2875     *\textcolor{keyword}{this} <<= exp;  \textcolor{comment}{// Multiply by pow(2, exp) by shifting.}}
\DoxyCodeLine{2876   \}}
\DoxyCodeLine{2877 }
\DoxyCodeLine{2878   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} square() \{}
\DoxyCodeLine{2879     \textcolor{keywordtype}{int} num\_bigits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.size());}
\DoxyCodeLine{2880     \textcolor{keywordtype}{int} num\_result\_bigits = 2 * num\_bigits;}
\DoxyCodeLine{2881     \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<bigit, bigits\_capacity>}} n(std::move(bigits\_));}
\DoxyCodeLine{2882     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(to\_unsigned(num\_result\_bigits));}
\DoxyCodeLine{2883     \textcolor{keyword}{auto} sum = uint128\_t();}
\DoxyCodeLine{2884     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} bigit\_index = 0; bigit\_index < num\_bigits; ++bigit\_index) \{}
\DoxyCodeLine{2885       \textcolor{comment}{// Compute bigit at position bigit\_index of the result by adding}}
\DoxyCodeLine{2886       \textcolor{comment}{// cross-\/product terms n[i] * n[j] such that i + j == bigit\_index.}}
\DoxyCodeLine{2887       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0, j = bigit\_index; j >= 0; ++i, -\/-\/j) \{}
\DoxyCodeLine{2888         \textcolor{comment}{// Most terms are multiplied twice which can be optimized in the future.}}
\DoxyCodeLine{2889         sum += \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}(n[i]) * n[j];}
\DoxyCodeLine{2890       \}}
\DoxyCodeLine{2891       (*this)[bigit\_index] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(sum);}
\DoxyCodeLine{2892       sum >>= num\_bits<bigit>();  \textcolor{comment}{// Compute the carry.}}
\DoxyCodeLine{2893     \}}
\DoxyCodeLine{2894     \textcolor{comment}{// Do the same for the top half.}}
\DoxyCodeLine{2895     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} bigit\_index = num\_bigits; bigit\_index < num\_result\_bigits;}
\DoxyCodeLine{2896          ++bigit\_index) \{}
\DoxyCodeLine{2897       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = num\_bigits -\/ 1, i = bigit\_index -\/ j; i < num\_bigits;)}
\DoxyCodeLine{2898         sum += \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}(n[i++]) * n[j-\/-\/];}
\DoxyCodeLine{2899       (*this)[bigit\_index] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(sum);}
\DoxyCodeLine{2900       sum >>= num\_bits<bigit>();}
\DoxyCodeLine{2901     \}}
\DoxyCodeLine{2902     remove\_leading\_zeros();}
\DoxyCodeLine{2903     exp\_ *= 2;}
\DoxyCodeLine{2904   \}}
\DoxyCodeLine{2905 }
\DoxyCodeLine{2906   \textcolor{comment}{// If this bigint has a bigger exponent than other, adds trailing zero to make}}
\DoxyCodeLine{2907   \textcolor{comment}{// exponents equal. This simplifies some operations such as subtraction.}}
\DoxyCodeLine{2908   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} align(\textcolor{keyword}{const} bigint\& other) \{}
\DoxyCodeLine{2909     \textcolor{keywordtype}{int} exp\_difference = exp\_ -\/ other.exp\_;}
\DoxyCodeLine{2910     \textcolor{keywordflow}{if} (exp\_difference <= 0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{2911     \textcolor{keywordtype}{int} num\_bigits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.size());}
\DoxyCodeLine{2912     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(to\_unsigned(num\_bigits + exp\_difference));}
\DoxyCodeLine{2913     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = num\_bigits -\/ 1, j = i + exp\_difference; i >= 0; -\/-\/i, -\/-\/j)}
\DoxyCodeLine{2914       bigits\_[j] = bigits\_[i];}
\DoxyCodeLine{2915     std::uninitialized\_fill\_n(bigits\_.data(), exp\_difference, 0);}
\DoxyCodeLine{2916     exp\_ -\/= exp\_difference;}
\DoxyCodeLine{2917   \}}
\DoxyCodeLine{2918 }
\DoxyCodeLine{2919   \textcolor{comment}{// Divides this bignum by divisor, assigning the remainder to this and}}
\DoxyCodeLine{2920   \textcolor{comment}{// returning the quotient.}}
\DoxyCodeLine{2921   FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} divmod\_assign(\textcolor{keyword}{const} bigint\& divisor) \{}
\DoxyCodeLine{2922     FMT\_ASSERT(\textcolor{keyword}{this} != \&divisor, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2923     \textcolor{keywordflow}{if} (compare(*\textcolor{keyword}{this}, divisor) < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2924     FMT\_ASSERT(divisor.bigits\_[divisor.bigits\_.size() -\/ 1u] != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2925     align(divisor);}
\DoxyCodeLine{2926     \textcolor{keywordtype}{int} quotient = 0;}
\DoxyCodeLine{2927     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2928       subtract\_aligned(divisor);}
\DoxyCodeLine{2929       ++quotient;}
\DoxyCodeLine{2930     \} \textcolor{keywordflow}{while} (compare(*\textcolor{keyword}{this}, divisor) >= 0);}
\DoxyCodeLine{2931     \textcolor{keywordflow}{return} quotient;}
\DoxyCodeLine{2932   \}}
\DoxyCodeLine{2933 \};}
\DoxyCodeLine{2934 }
\DoxyCodeLine{2935 \textcolor{comment}{// format\_dragon flags.}}
\DoxyCodeLine{2936 \textcolor{keyword}{enum} dragon \{}
\DoxyCodeLine{2937   predecessor\_closer = 1,}
\DoxyCodeLine{2938   fixup = 2,  \textcolor{comment}{// Run fixup to correct exp10 which can be off by one.}}
\DoxyCodeLine{2939   fixed = 4,}
\DoxyCodeLine{2940 \};}
\DoxyCodeLine{2941 }
\DoxyCodeLine{2942 \textcolor{comment}{// Formats a floating-\/point number using a variation of the Fixed-\/Precision}}
\DoxyCodeLine{2943 \textcolor{comment}{// Positive Floating-\/Point Printout ((FPP)\string^2) algorithm by Steele \& White:}}
\DoxyCodeLine{2944 \textcolor{comment}{// https://fmt.dev/papers/p372-\/steele.pdf.}}
\DoxyCodeLine{2945 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} format\_dragon(basic\_fp<uint128\_t> value,}
\DoxyCodeLine{2946                                           \textcolor{keywordtype}{unsigned} flags, \textcolor{keywordtype}{int} num\_digits,}
\DoxyCodeLine{2947                                           \mbox{\hyperlink{classbuffer}{buffer<char>}}\& buf, \textcolor{keywordtype}{int}\& exp10) \{}
\DoxyCodeLine{2948   bigint numerator;    \textcolor{comment}{// 2 * R in (FPP)\string^2.}}
\DoxyCodeLine{2949   bigint denominator;  \textcolor{comment}{// 2 * S in (FPP)\string^2.}}
\DoxyCodeLine{2950   \textcolor{comment}{// lower and upper are differences between value and corresponding boundaries.}}
\DoxyCodeLine{2951   bigint lower;             \textcolor{comment}{// (M\string^-\/ in (FPP)\string^2).}}
\DoxyCodeLine{2952   bigint upper\_store;       \textcolor{comment}{// upper's value if different from lower.}}
\DoxyCodeLine{2953   bigint* upper = \textcolor{keyword}{nullptr};  \textcolor{comment}{// (M\string^+ in (FPP)\string^2).}}
\DoxyCodeLine{2954   \textcolor{comment}{// Shift numerator and denominator by an extra bit or two (if lower boundary}}
\DoxyCodeLine{2955   \textcolor{comment}{// is closer) to make lower and upper integers. This eliminates multiplication}}
\DoxyCodeLine{2956   \textcolor{comment}{// by 2 during later computations.}}
\DoxyCodeLine{2957   \textcolor{keywordtype}{bool} is\_predecessor\_closer = (flags \& dragon::predecessor\_closer) != 0;}
\DoxyCodeLine{2958   \textcolor{keywordtype}{int} shift = is\_predecessor\_closer ? 2 : 1;}
\DoxyCodeLine{2959   \textcolor{keywordflow}{if} (value.e >= 0) \{}
\DoxyCodeLine{2960     numerator = value.f;}
\DoxyCodeLine{2961     numerator <<= value.e + shift;}
\DoxyCodeLine{2962     lower = 1;}
\DoxyCodeLine{2963     lower <<= value.e;}
\DoxyCodeLine{2964     \textcolor{keywordflow}{if} (is\_predecessor\_closer) \{}
\DoxyCodeLine{2965       upper\_store = 1;}
\DoxyCodeLine{2966       upper\_store <<= value.e + 1;}
\DoxyCodeLine{2967       upper = \&upper\_store;}
\DoxyCodeLine{2968     \}}
\DoxyCodeLine{2969     denominator.assign\_pow10(exp10);}
\DoxyCodeLine{2970     denominator <<= shift;}
\DoxyCodeLine{2971   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exp10 < 0) \{}
\DoxyCodeLine{2972     numerator.assign\_pow10(-\/exp10);}
\DoxyCodeLine{2973     lower.assign(numerator);}
\DoxyCodeLine{2974     \textcolor{keywordflow}{if} (is\_predecessor\_closer) \{}
\DoxyCodeLine{2975       upper\_store.assign(numerator);}
\DoxyCodeLine{2976       upper\_store <<= 1;}
\DoxyCodeLine{2977       upper = \&upper\_store;}
\DoxyCodeLine{2978     \}}
\DoxyCodeLine{2979     numerator *= value.f;}
\DoxyCodeLine{2980     numerator <<= shift;}
\DoxyCodeLine{2981     denominator = 1;}
\DoxyCodeLine{2982     denominator <<= shift -\/ value.e;}
\DoxyCodeLine{2983   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2984     numerator = value.f;}
\DoxyCodeLine{2985     numerator <<= shift;}
\DoxyCodeLine{2986     denominator.assign\_pow10(exp10);}
\DoxyCodeLine{2987     denominator <<= shift -\/ value.e;}
\DoxyCodeLine{2988     lower = 1;}
\DoxyCodeLine{2989     \textcolor{keywordflow}{if} (is\_predecessor\_closer) \{}
\DoxyCodeLine{2990       upper\_store = 1ULL << 1;}
\DoxyCodeLine{2991       upper = \&upper\_store;}
\DoxyCodeLine{2992     \}}
\DoxyCodeLine{2993   \}}
\DoxyCodeLine{2994   \textcolor{keywordtype}{bool} even = (value.f \& 1) == 0;}
\DoxyCodeLine{2995   \textcolor{keywordflow}{if} (!upper) upper = \&lower;}
\DoxyCodeLine{2996   \textcolor{keywordflow}{if} ((flags \& dragon::fixup) != 0) \{}
\DoxyCodeLine{2997     \textcolor{keywordflow}{if} (add\_compare(numerator, *upper, denominator) + even <= 0) \{}
\DoxyCodeLine{2998       -\/-\/exp10;}
\DoxyCodeLine{2999       numerator *= 10;}
\DoxyCodeLine{3000       \textcolor{keywordflow}{if} (num\_digits < 0) \{}
\DoxyCodeLine{3001         lower *= 10;}
\DoxyCodeLine{3002         \textcolor{keywordflow}{if} (upper != \&lower) *upper *= 10;}
\DoxyCodeLine{3003       \}}
\DoxyCodeLine{3004     \}}
\DoxyCodeLine{3005     \textcolor{keywordflow}{if} ((flags \& dragon::fixed) != 0) adjust\_precision(num\_digits, exp10 + 1);}
\DoxyCodeLine{3006   \}}
\DoxyCodeLine{3007   \textcolor{comment}{// Invariant: value == (numerator / denominator) * pow(10, exp10).}}
\DoxyCodeLine{3008   \textcolor{keywordflow}{if} (num\_digits < 0) \{}
\DoxyCodeLine{3009     \textcolor{comment}{// Generate the shortest representation.}}
\DoxyCodeLine{3010     num\_digits = 0;}
\DoxyCodeLine{3011     \textcolor{keywordtype}{char}* data = buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}();}
\DoxyCodeLine{3012     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{3013       \textcolor{keywordtype}{int} digit = numerator.divmod\_assign(denominator);}
\DoxyCodeLine{3014       \textcolor{keywordtype}{bool} low = compare(numerator, lower) -\/ even < 0;  \textcolor{comment}{// numerator <[=] lower.}}
\DoxyCodeLine{3015       \textcolor{comment}{// numerator + upper >[=] pow10:}}
\DoxyCodeLine{3016       \textcolor{keywordtype}{bool} high = add\_compare(numerator, *upper, denominator) + even > 0;}
\DoxyCodeLine{3017       data[num\_digits++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{3018       \textcolor{keywordflow}{if} (low || high) \{}
\DoxyCodeLine{3019         \textcolor{keywordflow}{if} (!low) \{}
\DoxyCodeLine{3020           ++data[num\_digits -\/ 1];}
\DoxyCodeLine{3021         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (high) \{}
\DoxyCodeLine{3022           \textcolor{keywordtype}{int} result = add\_compare(numerator, numerator, denominator);}
\DoxyCodeLine{3023           \textcolor{comment}{// Round half to even.}}
\DoxyCodeLine{3024           \textcolor{keywordflow}{if} (result > 0 || (result == 0 \&\& (digit \% 2) != 0))}
\DoxyCodeLine{3025             ++data[num\_digits -\/ 1];}
\DoxyCodeLine{3026         \}}
\DoxyCodeLine{3027         buf.try\_resize(to\_unsigned(num\_digits));}
\DoxyCodeLine{3028         exp10 -\/= num\_digits -\/ 1;}
\DoxyCodeLine{3029         \textcolor{keywordflow}{return};}
\DoxyCodeLine{3030       \}}
\DoxyCodeLine{3031       numerator *= 10;}
\DoxyCodeLine{3032       lower *= 10;}
\DoxyCodeLine{3033       \textcolor{keywordflow}{if} (upper != \&lower) *upper *= 10;}
\DoxyCodeLine{3034     \}}
\DoxyCodeLine{3035   \}}
\DoxyCodeLine{3036   \textcolor{comment}{// Generate the given number of digits.}}
\DoxyCodeLine{3037   exp10 -\/= num\_digits -\/ 1;}
\DoxyCodeLine{3038   \textcolor{keywordflow}{if} (num\_digits == 0) \{}
\DoxyCodeLine{3039     denominator *= 10;}
\DoxyCodeLine{3040     \textcolor{keyword}{auto} digit = add\_compare(numerator, numerator, denominator) > 0 ? \textcolor{charliteral}{'1'} : \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3041     buf.push\_back(digit);}
\DoxyCodeLine{3042     \textcolor{keywordflow}{return};}
\DoxyCodeLine{3043   \}}
\DoxyCodeLine{3044   buf.try\_resize(to\_unsigned(num\_digits));}
\DoxyCodeLine{3045   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_digits -\/ 1; ++i) \{}
\DoxyCodeLine{3046     \textcolor{keywordtype}{int} digit = numerator.divmod\_assign(denominator);}
\DoxyCodeLine{3047     buf[i] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{3048     numerator *= 10;}
\DoxyCodeLine{3049   \}}
\DoxyCodeLine{3050   \textcolor{keywordtype}{int} digit = numerator.divmod\_assign(denominator);}
\DoxyCodeLine{3051   \textcolor{keyword}{auto} result = add\_compare(numerator, numerator, denominator);}
\DoxyCodeLine{3052   \textcolor{keywordflow}{if} (result > 0 || (result == 0 \&\& (digit \% 2) != 0)) \{}
\DoxyCodeLine{3053     \textcolor{keywordflow}{if} (digit == 9) \{}
\DoxyCodeLine{3054       \textcolor{keyword}{const} \textcolor{keyword}{auto} overflow = \textcolor{charliteral}{'0'} + 10;}
\DoxyCodeLine{3055       buf[num\_digits -\/ 1] = overflow;}
\DoxyCodeLine{3056       \textcolor{comment}{// Propagate the carry.}}
\DoxyCodeLine{3057       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = num\_digits -\/ 1; i > 0 \&\& buf[i] == overflow; -\/-\/i) \{}
\DoxyCodeLine{3058         buf[i] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3059         ++buf[i -\/ 1];}
\DoxyCodeLine{3060       \}}
\DoxyCodeLine{3061       \textcolor{keywordflow}{if} (buf[0] == overflow) \{}
\DoxyCodeLine{3062         buf[0] = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{3063         ++exp10;}
\DoxyCodeLine{3064       \}}
\DoxyCodeLine{3065       \textcolor{keywordflow}{return};}
\DoxyCodeLine{3066     \}}
\DoxyCodeLine{3067     ++digit;}
\DoxyCodeLine{3068   \}}
\DoxyCodeLine{3069   buf[num\_digits -\/ 1] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{3070 \}}
\DoxyCodeLine{3071 }
\DoxyCodeLine{3072 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{3073 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} format\_float(Float value, \textcolor{keywordtype}{int} precision, float\_specs specs,}
\DoxyCodeLine{3074                                   \mbox{\hyperlink{classbuffer}{buffer<char>}}\& buf) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{3075   \textcolor{comment}{// float is passed as double to reduce the number of instantiations.}}
\DoxyCodeLine{3076   \textcolor{keyword}{static\_assert}(!std::is\_same<Float, float>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3077   FMT\_ASSERT(value >= 0, \textcolor{stringliteral}{"{}value is negative"{}});}
\DoxyCodeLine{3078   \textcolor{keyword}{auto} converted\_value = convert\_float(value);}
\DoxyCodeLine{3079 }
\DoxyCodeLine{3080   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} fixed = specs.format == float\_format::fixed;}
\DoxyCodeLine{3081   \textcolor{keywordflow}{if} (value <= 0) \{  \textcolor{comment}{// <= instead of == to silence a warning.}}
\DoxyCodeLine{3082     \textcolor{keywordflow}{if} (precision <= 0 || !fixed) \{}
\DoxyCodeLine{3083       buf.push\_back(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{3084       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3085     \}}
\DoxyCodeLine{3086     buf.try\_resize(to\_unsigned(precision));}
\DoxyCodeLine{3087     fill\_n(buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), precision, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{3088     \textcolor{keywordflow}{return} -\/precision;}
\DoxyCodeLine{3089   \}}
\DoxyCodeLine{3090 }
\DoxyCodeLine{3091   \textcolor{keywordtype}{int} exp = 0;}
\DoxyCodeLine{3092   \textcolor{keywordtype}{bool} use\_dragon = \textcolor{keyword}{true};}
\DoxyCodeLine{3093   \textcolor{keywordtype}{unsigned} dragon\_flags = 0;}
\DoxyCodeLine{3094   \textcolor{keywordflow}{if} (!is\_fast\_float<Float>()) \{}
\DoxyCodeLine{3095     \textcolor{keyword}{const} \textcolor{keyword}{auto} inv\_log2\_10 = 0.3010299956639812;  \textcolor{comment}{// 1 / log2(10)}}
\DoxyCodeLine{3096     \textcolor{keyword}{using }info = dragonbox::float\_info<\textcolor{keyword}{decltype}(converted\_value)>;}
\DoxyCodeLine{3097     \textcolor{keyword}{const} \textcolor{keyword}{auto} f = basic\_fp<typename info::carrier\_uint>(converted\_value);}
\DoxyCodeLine{3098     \textcolor{comment}{// Compute exp, an approximate power of 10, such that}}
\DoxyCodeLine{3099     \textcolor{comment}{//   10\string^(exp -\/ 1) <= value < 10\string^exp or 10\string^exp <= value < 10\string^(exp + 1).}}
\DoxyCodeLine{3100     \textcolor{comment}{// This is based on log10(value) == log2(value) / log2(10) and approximation}}
\DoxyCodeLine{3101     \textcolor{comment}{// of log2(value) by e + num\_fraction\_bits idea from double-\/conversion.}}
\DoxyCodeLine{3102     exp = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(}
\DoxyCodeLine{3103         std::ceil((f.e + count\_digits<1>(f.f) -\/ 1) * inv\_log2\_10 -\/ 1e-\/10));}
\DoxyCodeLine{3104     dragon\_flags = dragon::fixup;}
\DoxyCodeLine{3105   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!is\_constant\_evaluated() \&\& precision < 0) \{}
\DoxyCodeLine{3106     \textcolor{comment}{// Use Dragonbox for the shortest format.}}
\DoxyCodeLine{3107     \textcolor{keywordflow}{if} (specs.binary32) \{}
\DoxyCodeLine{3108       \textcolor{keyword}{auto} dec = dragonbox::to\_decimal(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3109       write<char>(buffer\_appender<char>(buf), dec.significand);}
\DoxyCodeLine{3110       \textcolor{keywordflow}{return} dec.exponent;}
\DoxyCodeLine{3111     \}}
\DoxyCodeLine{3112     \textcolor{keyword}{auto} dec = dragonbox::to\_decimal(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3113     write<char>(buffer\_appender<char>(buf), dec.significand);}
\DoxyCodeLine{3114     \textcolor{keywordflow}{return} dec.exponent;}
\DoxyCodeLine{3115   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3116     \textcolor{comment}{// Use Grisu + Dragon4 for the given precision:}}
\DoxyCodeLine{3117     \textcolor{comment}{// https://www.cs.tufts.edu/\string~nr/cs257/archive/florian-\/loitsch/printf.pdf.}}
\DoxyCodeLine{3118     \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_exp = -\/60;  \textcolor{comment}{// alpha in Grisu.}}
\DoxyCodeLine{3119     \textcolor{keywordtype}{int} cached\_exp10 = 0;     \textcolor{comment}{// K in Grisu.}}
\DoxyCodeLine{3120     fp normalized = normalize(fp(converted\_value));}
\DoxyCodeLine{3121     \textcolor{keyword}{const} \textcolor{keyword}{auto} cached\_pow = get\_cached\_power(}
\DoxyCodeLine{3122         min\_exp -\/ (normalized.e + fp::num\_significand\_bits), cached\_exp10);}
\DoxyCodeLine{3123     normalized = normalized * cached\_pow;}
\DoxyCodeLine{3124     gen\_digits\_handler handler\{buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), 0, precision, -\/cached\_exp10, fixed\};}
\DoxyCodeLine{3125     \textcolor{keywordflow}{if} (grisu\_gen\_digits(normalized, 1, exp, handler) != digits::error \&\&}
\DoxyCodeLine{3126         !is\_constant\_evaluated()) \{}
\DoxyCodeLine{3127       exp += handler.exp10;}
\DoxyCodeLine{3128       buf.try\_resize(to\_unsigned(handler.size));}
\DoxyCodeLine{3129       use\_dragon = \textcolor{keyword}{false};}
\DoxyCodeLine{3130     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3131       exp += handler.size -\/ cached\_exp10 -\/ 1;}
\DoxyCodeLine{3132       precision = handler.precision;}
\DoxyCodeLine{3133     \}}
\DoxyCodeLine{3134   \}}
\DoxyCodeLine{3135   \textcolor{keywordflow}{if} (use\_dragon) \{}
\DoxyCodeLine{3136     \textcolor{keyword}{auto} f = basic\_fp<uint128\_t>();}
\DoxyCodeLine{3137     \textcolor{keywordtype}{bool} is\_predecessor\_closer = specs.binary32}
\DoxyCodeLine{3138                                      ? f.assign(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(value))}
\DoxyCodeLine{3139                                      : f.assign(converted\_value);}
\DoxyCodeLine{3140     \textcolor{keywordflow}{if} (is\_predecessor\_closer) dragon\_flags |= dragon::predecessor\_closer;}
\DoxyCodeLine{3141     \textcolor{keywordflow}{if} (fixed) dragon\_flags |= dragon::fixed;}
\DoxyCodeLine{3142     \textcolor{comment}{// Limit precision to the maximum possible number of significant digits in}}
\DoxyCodeLine{3143     \textcolor{comment}{// an IEEE754 double because we don't need to generate zeros.}}
\DoxyCodeLine{3144     \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_double\_digits = 767;}
\DoxyCodeLine{3145     \textcolor{keywordflow}{if} (precision > max\_double\_digits) precision = max\_double\_digits;}
\DoxyCodeLine{3146     format\_dragon(f, dragon\_flags, precision, buf, exp);}
\DoxyCodeLine{3147   \}}
\DoxyCodeLine{3148   \textcolor{keywordflow}{if} (!fixed \&\& !specs.showpoint) \{}
\DoxyCodeLine{3149     \textcolor{comment}{// Remove trailing zeros.}}
\DoxyCodeLine{3150     \textcolor{keyword}{auto} num\_digits = buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{3151     \textcolor{keywordflow}{while} (num\_digits > 0 \&\& buf[num\_digits -\/ 1] == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{3152       -\/-\/num\_digits;}
\DoxyCodeLine{3153       ++exp;}
\DoxyCodeLine{3154     \}}
\DoxyCodeLine{3155     buf.try\_resize(num\_digits);}
\DoxyCodeLine{3156   \}}
\DoxyCodeLine{3157   \textcolor{keywordflow}{return} exp;}
\DoxyCodeLine{3158 \}}
\DoxyCodeLine{3159 }
\DoxyCodeLine{3160 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3161           FMT\_ENABLE\_IF(is\_floating\_point<T>::value)>}
\DoxyCodeLine{3162 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{3163                            basic\_format\_specs<Char> specs, locale\_ref loc = \{\})}
\DoxyCodeLine{3164     -\/> OutputIt \{}
\DoxyCodeLine{3165   \textcolor{keywordflow}{if} (const\_check(!is\_supported\_floating\_point(value))) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3166   float\_specs fspecs = parse\_float\_type\_spec(specs);}
\DoxyCodeLine{3167   fspecs.sign = specs.sign;}
\DoxyCodeLine{3168   \textcolor{keywordflow}{if} (detail::signbit(value)) \{  \textcolor{comment}{// value < 0 is false for NaN so use signbit.}}
\DoxyCodeLine{3169     fspecs.sign = sign::minus;}
\DoxyCodeLine{3170     value = -\/value;}
\DoxyCodeLine{3171   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fspecs.sign == sign::minus) \{}
\DoxyCodeLine{3172     fspecs.sign = sign::none;}
\DoxyCodeLine{3173   \}}
\DoxyCodeLine{3174 }
\DoxyCodeLine{3175   \textcolor{keywordflow}{if} (!detail::isfinite(value))}
\DoxyCodeLine{3176     \textcolor{keywordflow}{return} write\_nonfinite(out, detail::isnan(value), specs, fspecs);}
\DoxyCodeLine{3177 }
\DoxyCodeLine{3178   \textcolor{keywordflow}{if} (specs.align == align::numeric \&\& fspecs.sign) \{}
\DoxyCodeLine{3179     \textcolor{keyword}{auto} it = reserve(out, 1);}
\DoxyCodeLine{3180     *it++ = detail::sign<Char>(fspecs.sign);}
\DoxyCodeLine{3181     out = base\_iterator(out, it);}
\DoxyCodeLine{3182     fspecs.sign = sign::none;}
\DoxyCodeLine{3183     \textcolor{keywordflow}{if} (specs.width != 0) -\/-\/specs.width;}
\DoxyCodeLine{3184   \}}
\DoxyCodeLine{3185 }
\DoxyCodeLine{3186   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{3187   \textcolor{keywordflow}{if} (fspecs.format == float\_format::hex) \{}
\DoxyCodeLine{3188     \textcolor{keywordflow}{if} (fspecs.sign) \mbox{\hyperlink{classbuffer}{buffer}}.push\_back(detail::sign<char>(fspecs.sign));}
\DoxyCodeLine{3189     snprintf\_float(convert\_float(value), specs.precision, fspecs, \mbox{\hyperlink{classbuffer}{buffer}});}
\DoxyCodeLine{3190     \textcolor{keywordflow}{return} write\_bytes<align::right>(out, \{\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()\},}
\DoxyCodeLine{3191                                      specs);}
\DoxyCodeLine{3192   \}}
\DoxyCodeLine{3193   \textcolor{keywordtype}{int} precision = specs.precision >= 0 || specs.type == presentation\_type::none}
\DoxyCodeLine{3194                       ? specs.precision}
\DoxyCodeLine{3195                       : 6;}
\DoxyCodeLine{3196   \textcolor{keywordflow}{if} (fspecs.format == float\_format::exp) \{}
\DoxyCodeLine{3197     \textcolor{keywordflow}{if} (precision == max\_value<int>())}
\DoxyCodeLine{3198       throw\_format\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{3199     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3200       ++precision;}
\DoxyCodeLine{3201   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fspecs.format != float\_format::fixed \&\& precision == 0) \{}
\DoxyCodeLine{3202     precision = 1;}
\DoxyCodeLine{3203   \}}
\DoxyCodeLine{3204   \textcolor{keywordflow}{if} (const\_check(std::is\_same<T, float>())) fspecs.binary32 = \textcolor{keyword}{true};}
\DoxyCodeLine{3205   \textcolor{keywordtype}{int} exp = format\_float(convert\_float(value), precision, fspecs, \mbox{\hyperlink{classbuffer}{buffer}});}
\DoxyCodeLine{3206   fspecs.precision = precision;}
\DoxyCodeLine{3207   \textcolor{keyword}{auto} f = big\_decimal\_fp\{\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()), exp\};}
\DoxyCodeLine{3208   \textcolor{keywordflow}{return} write\_float(out, f, specs, fspecs, loc);}
\DoxyCodeLine{3209 \}}
\DoxyCodeLine{3210 }
\DoxyCodeLine{3211 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3212           FMT\_ENABLE\_IF(is\_fast\_float<T>::value)>}
\DoxyCodeLine{3213 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{3214   \textcolor{keywordflow}{if} (is\_constant\_evaluated())}
\DoxyCodeLine{3215     \textcolor{keywordflow}{return} write(out, value, basic\_format\_specs<Char>());}
\DoxyCodeLine{3216   \textcolor{keywordflow}{if} (const\_check(!is\_supported\_floating\_point(value))) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3217 }
\DoxyCodeLine{3218   \textcolor{keyword}{auto} fspecs = float\_specs();}
\DoxyCodeLine{3219   \textcolor{keywordflow}{if} (detail::signbit(value)) \{}
\DoxyCodeLine{3220     fspecs.sign = sign::minus;}
\DoxyCodeLine{3221     value = -\/value;}
\DoxyCodeLine{3222   \}}
\DoxyCodeLine{3223 }
\DoxyCodeLine{3224   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} specs = basic\_format\_specs<Char>();}
\DoxyCodeLine{3225   \textcolor{keyword}{using }floaty = conditional\_t<std::is\_same<T, long double>::value, double, T>;}
\DoxyCodeLine{3226   \textcolor{keyword}{using }uint = \textcolor{keyword}{typename} dragonbox::float\_info<floaty>::carrier\_uint;}
\DoxyCodeLine{3227   uint mask = exponent\_mask<floaty>();}
\DoxyCodeLine{3228   \textcolor{keywordflow}{if} ((bit\_cast<uint>(value) \& mask) == mask)}
\DoxyCodeLine{3229     \textcolor{keywordflow}{return} write\_nonfinite(out, std::isnan(value), specs, fspecs);}
\DoxyCodeLine{3230 }
\DoxyCodeLine{3231   \textcolor{keyword}{auto} dec = dragonbox::to\_decimal(\textcolor{keyword}{static\_cast<}floaty\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3232   \textcolor{keywordflow}{return} write\_float(out, dec, specs, fspecs, \{\});}
\DoxyCodeLine{3233 \}}
\DoxyCodeLine{3234 }
\DoxyCodeLine{3235 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3236           FMT\_ENABLE\_IF(is\_floating\_point<T>::value \&\&}
\DoxyCodeLine{3237                         !is\_fast\_float<T>::value)>}
\DoxyCodeLine{3238 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{3239   \textcolor{keywordflow}{return} write(out, value, basic\_format\_specs<Char>());}
\DoxyCodeLine{3240 \}}
\DoxyCodeLine{3241 }
\DoxyCodeLine{3242 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3243 \textcolor{keyword}{auto} write(OutputIt out, monostate, basic\_format\_specs<Char> = \{\},}
\DoxyCodeLine{3244            locale\_ref = \{\}) -\/> OutputIt \{}
\DoxyCodeLine{3245   FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3246   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3247 \}}
\DoxyCodeLine{3248 }
\DoxyCodeLine{3249 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3250 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} value)}
\DoxyCodeLine{3251     -\/> OutputIt \{}
\DoxyCodeLine{3252   \textcolor{keyword}{auto} it = reserve(out, value.size());}
\DoxyCodeLine{3253   it = copy\_str\_noinline<Char>(value.begin(), value.end(), it);}
\DoxyCodeLine{3254   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{3255 \}}
\DoxyCodeLine{3256 }
\DoxyCodeLine{3257 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3258           FMT\_ENABLE\_IF(is\_string<T>::value)>}
\DoxyCodeLine{3259 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T\& value) -\/> OutputIt \{}
\DoxyCodeLine{3260   \textcolor{keywordflow}{return} write<Char>(out, to\_string\_view(value));}
\DoxyCodeLine{3261 \}}
\DoxyCodeLine{3262 }
\DoxyCodeLine{3263 \textcolor{comment}{// FMT\_ENABLE\_IF() condition separated to workaround an MSVC bug.}}
\DoxyCodeLine{3264 \textcolor{keyword}{template} <}
\DoxyCodeLine{3265     \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3266     \textcolor{keywordtype}{bool} check =}
\DoxyCodeLine{3267         std::is\_enum<T>::value \&\& !std::is\_same<T, Char>::value \&\&}
\DoxyCodeLine{3268         mapped\_type\_constant<T, basic\_format\_context<OutputIt, Char>>::value !=}
\DoxyCodeLine{3269             type::custom\_type,}
\DoxyCodeLine{3270     FMT\_ENABLE\_IF(check)>}
\DoxyCodeLine{3271 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{3272   \textcolor{keywordflow}{return} write<Char>(out, \textcolor{keyword}{static\_cast<}underlying\_t<T>\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3273 \}}
\DoxyCodeLine{3274 }
\DoxyCodeLine{3275 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3276           FMT\_ENABLE\_IF(std::is\_same<T, bool>::value)>}
\DoxyCodeLine{3277 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{3278                          \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs = \{\},}
\DoxyCodeLine{3279                          locale\_ref = \{\}) -\/> OutputIt \{}
\DoxyCodeLine{3280   \textcolor{keywordflow}{return} specs.type != presentation\_type::none \&\&}
\DoxyCodeLine{3281                  specs.type != presentation\_type::string}
\DoxyCodeLine{3282              ? write(out, value ? 1 : 0, specs, \{\})}
\DoxyCodeLine{3283              : write\_bytes(out, value ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}}, specs);}
\DoxyCodeLine{3284 \}}
\DoxyCodeLine{3285 }
\DoxyCodeLine{3286 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3287 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, Char value) -\/> OutputIt \{}
\DoxyCodeLine{3288   \textcolor{keyword}{auto} it = reserve(out, 1);}
\DoxyCodeLine{3289   *it++ = value;}
\DoxyCodeLine{3290   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{3291 \}}
\DoxyCodeLine{3292 }
\DoxyCodeLine{3293 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3294 FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} Char* value)}
\DoxyCodeLine{3295     -\/> OutputIt \{}
\DoxyCodeLine{3296   \textcolor{keywordflow}{if} (!value) \{}
\DoxyCodeLine{3297     throw\_format\_error(\textcolor{stringliteral}{"{}string pointer is null"{}});}
\DoxyCodeLine{3298   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3299     out = write(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(value));}
\DoxyCodeLine{3300   \}}
\DoxyCodeLine{3301   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3302 \}}
\DoxyCodeLine{3303 }
\DoxyCodeLine{3304 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3305           FMT\_ENABLE\_IF(std::is\_same<T, void>::value)>}
\DoxyCodeLine{3306 \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T* value,}
\DoxyCodeLine{3307            \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs = \{\}, locale\_ref = \{\})}
\DoxyCodeLine{3308     -\/> OutputIt \{}
\DoxyCodeLine{3309   check\_pointer\_type\_spec(specs.type, error\_handler());}
\DoxyCodeLine{3310   \textcolor{keywordflow}{return} write\_ptr<Char>(out, bit\_cast<uintptr\_t>(value), \&specs);}
\DoxyCodeLine{3311 \}}
\DoxyCodeLine{3312 }
\DoxyCodeLine{3313 \textcolor{comment}{// A write overload that handles implicit conversions.}}
\DoxyCodeLine{3314 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3315           \textcolor{keyword}{typename} Context = basic\_format\_context<OutputIt, Char>>}
\DoxyCodeLine{3316 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T\& value) -\/> enable\_if\_t<}
\DoxyCodeLine{3317     std::is\_class<T>::value \&\& !is\_string<T>::value \&\&}
\DoxyCodeLine{3318         !is\_floating\_point<T>::value \&\& !std::is\_same<T, Char>::value \&\&}
\DoxyCodeLine{3319         !std::is\_same<\textcolor{keyword}{const} T\&,}
\DoxyCodeLine{3320                       \textcolor{keyword}{decltype}(arg\_mapper<Context>().map(value))>::value,}
\DoxyCodeLine{3321     OutputIt> \{}
\DoxyCodeLine{3322   \textcolor{keywordflow}{return} write<Char>(out, arg\_mapper<Context>().map(value));}
\DoxyCodeLine{3323 \}}
\DoxyCodeLine{3324 }
\DoxyCodeLine{3325 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3326           \textcolor{keyword}{typename} Context = basic\_format\_context<OutputIt, Char>>}
\DoxyCodeLine{3327 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T\& value)}
\DoxyCodeLine{3328     -\/> enable\_if\_t<mapped\_type\_constant<T, Context>::value == type::custom\_type,}
\DoxyCodeLine{3329                    OutputIt> \{}
\DoxyCodeLine{3330   \textcolor{keyword}{using }formatter\_type =}
\DoxyCodeLine{3331       conditional\_t<has\_formatter<T, Context>::value,}
\DoxyCodeLine{3332                     \textcolor{keyword}{typename} Context::template formatter\_type<T>,}
\DoxyCodeLine{3333                     fallback\_formatter<T, Char>>;}
\DoxyCodeLine{3334   \textcolor{keyword}{auto} ctx = Context(out, \{\}, \{\});}
\DoxyCodeLine{3335   \textcolor{keywordflow}{return} formatter\_type().format(value, ctx);}
\DoxyCodeLine{3336 \}}
\DoxyCodeLine{3337 }
\DoxyCodeLine{3338 \textcolor{comment}{// An argument visitor that formats the argument and writes it via the output}}
\DoxyCodeLine{3339 \textcolor{comment}{// iterator. It's a class and not a generic lambda for compatibility with C++11.}}
\DoxyCodeLine{3340 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }default\_arg\_formatter \{}
\DoxyCodeLine{3341   \textcolor{keyword}{using }iterator = buffer\_appender<Char>;}
\DoxyCodeLine{3342   \textcolor{keyword}{using }context = buffer\_context<Char>;}
\DoxyCodeLine{3343 }
\DoxyCodeLine{3344   iterator out;}
\DoxyCodeLine{3345   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<context>}} args;}
\DoxyCodeLine{3346   locale\_ref loc;}
\DoxyCodeLine{3347 }
\DoxyCodeLine{3348   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} operator()(T value) -\/> iterator \{}
\DoxyCodeLine{3349     \textcolor{keywordflow}{return} write<Char>(out, value);}
\DoxyCodeLine{3350   \}}
\DoxyCodeLine{3351   \textcolor{keyword}{auto} operator()(\textcolor{keyword}{typename} basic\_format\_arg<context>::handle h) -\/> iterator \{}
\DoxyCodeLine{3352     \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}} parse\_ctx(\{\});}
\DoxyCodeLine{3353     context format\_ctx(out, args, loc);}
\DoxyCodeLine{3354     h.format(parse\_ctx, format\_ctx);}
\DoxyCodeLine{3355     \textcolor{keywordflow}{return} format\_ctx.out();}
\DoxyCodeLine{3356   \}}
\DoxyCodeLine{3357 \};}
\DoxyCodeLine{3358 }
\DoxyCodeLine{3359 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }arg\_formatter \{}
\DoxyCodeLine{3360   \textcolor{keyword}{using }iterator = buffer\_appender<Char>;}
\DoxyCodeLine{3361   \textcolor{keyword}{using }context = buffer\_context<Char>;}
\DoxyCodeLine{3362 }
\DoxyCodeLine{3363   iterator out;}
\DoxyCodeLine{3364   \textcolor{keyword}{const} basic\_format\_specs<Char>\& specs;}
\DoxyCodeLine{3365   locale\_ref locale;}
\DoxyCodeLine{3366 }
\DoxyCodeLine{3367   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3368   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} operator()(T value) -\/> iterator \{}
\DoxyCodeLine{3369     \textcolor{keywordflow}{return} detail::write(out, value, specs, locale);}
\DoxyCodeLine{3370   \}}
\DoxyCodeLine{3371   \textcolor{keyword}{auto} operator()(\textcolor{keyword}{typename} basic\_format\_arg<context>::handle) -\/> iterator \{}
\DoxyCodeLine{3372     \textcolor{comment}{// User-\/defined types are handled separately because they require access}}
\DoxyCodeLine{3373     \textcolor{comment}{// to the parse context.}}
\DoxyCodeLine{3374     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3375   \}}
\DoxyCodeLine{3376 \};}
\DoxyCodeLine{3377 }
\DoxyCodeLine{3378 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }custom\_formatter \{}
\DoxyCodeLine{3379   \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& parse\_ctx;}
\DoxyCodeLine{3380   buffer\_context<Char>\& ctx;}
\DoxyCodeLine{3381 }
\DoxyCodeLine{3382   \textcolor{keywordtype}{void} operator()(}
\DoxyCodeLine{3383       \textcolor{keyword}{typename} basic\_format\_arg<buffer\_context<Char>>::handle h)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3384     h.format(parse\_ctx, ctx);}
\DoxyCodeLine{3385   \}}
\DoxyCodeLine{3386   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} operator()(T)\textcolor{keyword}{ const }\{\}}
\DoxyCodeLine{3387 \};}
\DoxyCodeLine{3388 }
\DoxyCodeLine{3389 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3390 \textcolor{keyword}{using }is\_integer =}
\DoxyCodeLine{3391     bool\_constant<is\_integral<T>::value \&\& !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{3392                   !std::is\_same<T, char>::value \&\&}
\DoxyCodeLine{3393                   !std::is\_same<T, wchar\_t>::value>;}
\DoxyCodeLine{3394 }
\DoxyCodeLine{3395 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler> \textcolor{keyword}{class }width\_checker \{}
\DoxyCodeLine{3396  \textcolor{keyword}{public}:}
\DoxyCodeLine{3397   \textcolor{keyword}{explicit} FMT\_CONSTEXPR width\_checker(ErrorHandler\& eh) : handler\_(eh) \{\}}
\DoxyCodeLine{3398 }
\DoxyCodeLine{3399   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3400   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T value) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3401     \textcolor{keywordflow}{if} (is\_negative(value)) handler\_.on\_error(\textcolor{stringliteral}{"{}negative width"{}});}
\DoxyCodeLine{3402     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3403   \}}
\DoxyCodeLine{3404 }
\DoxyCodeLine{3405   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3406   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3407     handler\_.on\_error(\textcolor{stringliteral}{"{}width is not integer"{}});}
\DoxyCodeLine{3408     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3409   \}}
\DoxyCodeLine{3410 }
\DoxyCodeLine{3411  \textcolor{keyword}{private}:}
\DoxyCodeLine{3412   ErrorHandler\& handler\_;}
\DoxyCodeLine{3413 \};}
\DoxyCodeLine{3414 }
\DoxyCodeLine{3415 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler> \textcolor{keyword}{class }precision\_checker \{}
\DoxyCodeLine{3416  \textcolor{keyword}{public}:}
\DoxyCodeLine{3417   \textcolor{keyword}{explicit} FMT\_CONSTEXPR precision\_checker(ErrorHandler\& eh) : handler\_(eh) \{\}}
\DoxyCodeLine{3418 }
\DoxyCodeLine{3419   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3420   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T value) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3421     \textcolor{keywordflow}{if} (is\_negative(value)) handler\_.on\_error(\textcolor{stringliteral}{"{}negative precision"{}});}
\DoxyCodeLine{3422     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3423   \}}
\DoxyCodeLine{3424 }
\DoxyCodeLine{3425   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3426   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3427     handler\_.on\_error(\textcolor{stringliteral}{"{}precision is not integer"{}});}
\DoxyCodeLine{3428     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3429   \}}
\DoxyCodeLine{3430 }
\DoxyCodeLine{3431  \textcolor{keyword}{private}:}
\DoxyCodeLine{3432   ErrorHandler\& handler\_;}
\DoxyCodeLine{3433 \};}
\DoxyCodeLine{3434 }
\DoxyCodeLine{3435 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }Handler, \textcolor{keyword}{typename} FormatArg,}
\DoxyCodeLine{3436           \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{3437 FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_dynamic\_spec(FormatArg arg, ErrorHandler eh) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{3438   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value = visit\_format\_arg(Handler<ErrorHandler>(eh), arg);}
\DoxyCodeLine{3439   \textcolor{keywordflow}{if} (value > to\_unsigned(max\_value<int>())) eh.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{3440   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3441 \}}
\DoxyCodeLine{3442 }
\DoxyCodeLine{3443 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} ID>}
\DoxyCodeLine{3444 FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg(Context\& ctx, ID \textcolor{keywordtype}{id}) -\/>}
\DoxyCodeLine{3445     \textcolor{keyword}{typename} Context::format\_arg \{}
\DoxyCodeLine{3446   \textcolor{keyword}{auto} arg = ctx.arg(\textcolor{keywordtype}{id});}
\DoxyCodeLine{3447   \textcolor{keywordflow}{if} (!arg) ctx.on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{3448   \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{3449 \}}
\DoxyCodeLine{3450 }
\DoxyCodeLine{3451 \textcolor{comment}{// The standard format specifier handler with checking.}}
\DoxyCodeLine{3452 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }specs\_handler : \textcolor{keyword}{public} specs\_setter<Char> \{}
\DoxyCodeLine{3453  \textcolor{keyword}{private}:}
\DoxyCodeLine{3454   \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& parse\_context\_;}
\DoxyCodeLine{3455   buffer\_context<Char>\& context\_;}
\DoxyCodeLine{3456 }
\DoxyCodeLine{3457   \textcolor{comment}{// This is only needed for compatibility with gcc 4.4.}}
\DoxyCodeLine{3458   \textcolor{keyword}{using }format\_arg = basic\_format\_arg<buffer\_context<Char>>;}
\DoxyCodeLine{3459 }
\DoxyCodeLine{3460   FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg(auto\_id) -\/> format\_arg \{}
\DoxyCodeLine{3461     \textcolor{keywordflow}{return} detail::get\_arg(context\_, parse\_context\_.\mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}}());}
\DoxyCodeLine{3462   \}}
\DoxyCodeLine{3463 }
\DoxyCodeLine{3464   FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg(\textcolor{keywordtype}{int} arg\_id) -\/> format\_arg \{}
\DoxyCodeLine{3465     parse\_context\_.\mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(arg\_id);}
\DoxyCodeLine{3466     \textcolor{keywordflow}{return} detail::get\_arg(context\_, arg\_id);}
\DoxyCodeLine{3467   \}}
\DoxyCodeLine{3468 }
\DoxyCodeLine{3469   FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} arg\_id) -\/> format\_arg \{}
\DoxyCodeLine{3470     parse\_context\_.\mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(arg\_id);}
\DoxyCodeLine{3471     \textcolor{keywordflow}{return} detail::get\_arg(context\_, arg\_id);}
\DoxyCodeLine{3472   \}}
\DoxyCodeLine{3473 }
\DoxyCodeLine{3474  \textcolor{keyword}{public}:}
\DoxyCodeLine{3475   FMT\_CONSTEXPR specs\_handler(basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{3476                               \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& parse\_ctx,}
\DoxyCodeLine{3477                               buffer\_context<Char>\& ctx)}
\DoxyCodeLine{3478       : specs\_setter<Char>(specs), parse\_context\_(parse\_ctx), context\_(ctx) \{\}}
\DoxyCodeLine{3479 }
\DoxyCodeLine{3480   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_width(Id arg\_id) \{}
\DoxyCodeLine{3481     this-\/>specs\_.width = get\_dynamic\_spec<width\_checker>(}
\DoxyCodeLine{3482         get\_arg(arg\_id), context\_.error\_handler());}
\DoxyCodeLine{3483   \}}
\DoxyCodeLine{3484 }
\DoxyCodeLine{3485   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_precision(Id arg\_id) \{}
\DoxyCodeLine{3486     this-\/>specs\_.precision = get\_dynamic\_spec<precision\_checker>(}
\DoxyCodeLine{3487         get\_arg(arg\_id), context\_.error\_handler());}
\DoxyCodeLine{3488   \}}
\DoxyCodeLine{3489 }
\DoxyCodeLine{3490   \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{ context\_.on\_error(message); \}}
\DoxyCodeLine{3491 \};}
\DoxyCodeLine{3492 }
\DoxyCodeLine{3493 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }Handler, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{3494 FMT\_CONSTEXPR \textcolor{keywordtype}{void} handle\_dynamic\_spec(\textcolor{keywordtype}{int}\& value,}
\DoxyCodeLine{3495                                        arg\_ref<typename Context::char\_type> ref,}
\DoxyCodeLine{3496                                        Context\& ctx) \{}
\DoxyCodeLine{3497   \textcolor{keywordflow}{switch} (ref.kind) \{}
\DoxyCodeLine{3498   \textcolor{keywordflow}{case} arg\_id\_kind::none:}
\DoxyCodeLine{3499     \textcolor{keywordflow}{break};}
\DoxyCodeLine{3500   \textcolor{keywordflow}{case} arg\_id\_kind::index:}
\DoxyCodeLine{3501     value = detail::get\_dynamic\_spec<Handler>(ctx.arg(ref.val.index),}
\DoxyCodeLine{3502                                               ctx.error\_handler());}
\DoxyCodeLine{3503     \textcolor{keywordflow}{break};}
\DoxyCodeLine{3504   \textcolor{keywordflow}{case} arg\_id\_kind::name:}
\DoxyCodeLine{3505     value = detail::get\_dynamic\_spec<Handler>(ctx.arg(ref.val.name),}
\DoxyCodeLine{3506                                               ctx.error\_handler());}
\DoxyCodeLine{3507     \textcolor{keywordflow}{break};}
\DoxyCodeLine{3508   \}}
\DoxyCodeLine{3509 \}}
\DoxyCodeLine{3510 }
\DoxyCodeLine{3511 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{3512 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }udl\_formatter \{}
\DoxyCodeLine{3513   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str;}
\DoxyCodeLine{3514 }
\DoxyCodeLine{3515   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3516   \textcolor{keyword}{auto} operator()(T\&\&... args) \textcolor{keyword}{const} -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{3517     \textcolor{keywordflow}{return} vformat(str, fmt::make\_format\_args<buffer\_context<Char>>(args...));}
\DoxyCodeLine{3518   \}}
\DoxyCodeLine{3519 \};}
\DoxyCodeLine{3520 }
\DoxyCodeLine{3521 \textcolor{preprocessor}{\#  if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{3522 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3523           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3524 \textcolor{keyword}{struct }statically\_named\_arg : view \{}
\DoxyCodeLine{3525   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} name = Str.data;}
\DoxyCodeLine{3526 }
\DoxyCodeLine{3527   \textcolor{keyword}{const} T\& value;}
\DoxyCodeLine{3528   statically\_named\_arg(\textcolor{keyword}{const} T\& v) : value(v) \{\}}
\DoxyCodeLine{3529 \};}
\DoxyCodeLine{3530 }
\DoxyCodeLine{3531 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3532           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3533 \textcolor{keyword}{struct }is\_named\_arg<statically\_named\_arg<T, Char, N, Str>> : std::true\_type \{\};}
\DoxyCodeLine{3534 }
\DoxyCodeLine{3535 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3536           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3537 \textcolor{keyword}{struct }is\_statically\_named\_arg<statically\_named\_arg<T, Char, N, Str>>}
\DoxyCodeLine{3538     : std::true\_type \{\};}
\DoxyCodeLine{3539 }
\DoxyCodeLine{3540 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3541           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3542 \textcolor{keyword}{struct }udl\_arg \{}
\DoxyCodeLine{3543   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} operator=(T\&\& value)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3544     \textcolor{keywordflow}{return} statically\_named\_arg<T, Char, N, Str>(std::forward<T>(value));}
\DoxyCodeLine{3545   \}}
\DoxyCodeLine{3546 \};}
\DoxyCodeLine{3547 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{3548 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }udl\_arg \{}
\DoxyCodeLine{3549   \textcolor{keyword}{const} Char* str;}
\DoxyCodeLine{3550 }
\DoxyCodeLine{3551   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} operator=(T\&\& value) \textcolor{keyword}{const} -\/> named\_arg<Char, T> \{}
\DoxyCodeLine{3552     \textcolor{keywordflow}{return} \{str, std::forward<T>(value)\};}
\DoxyCodeLine{3553   \}}
\DoxyCodeLine{3554 \};}
\DoxyCodeLine{3555 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{3556 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{3557 }
\DoxyCodeLine{3558 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3559 \textcolor{keyword}{auto} vformat(\textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str,}
\DoxyCodeLine{3560              \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<buffer\_context<type\_identity\_t<Char>>> args)}
\DoxyCodeLine{3561     -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{3562   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}} \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{3563   detail::vformat\_to(\mbox{\hyperlink{classbuffer}{buffer}}, format\_str, args, detail::locale\_ref(loc));}
\DoxyCodeLine{3564   \textcolor{keywordflow}{return} \{\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()\};}
\DoxyCodeLine{3565 \}}
\DoxyCodeLine{3566 }
\DoxyCodeLine{3567 \textcolor{keyword}{using }format\_func = void (*)(detail::buffer<char>\&, int, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*);}
\DoxyCodeLine{3568 }
\DoxyCodeLine{3569 FMT\_API \textcolor{keywordtype}{void} format\_error\_code(\mbox{\hyperlink{classbuffer}{buffer<char>}}\& out, \textcolor{keywordtype}{int} error\_code,}
\DoxyCodeLine{3570                                \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3571 }
\DoxyCodeLine{3572 FMT\_API \textcolor{keywordtype}{void} report\_error(format\_func func, \textcolor{keywordtype}{int} error\_code,}
\DoxyCodeLine{3573                           \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3574 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{3575 }
\DoxyCodeLine{3576 FMT\_API \textcolor{keyword}{auto} vsystem\_error(\textcolor{keywordtype}{int} error\_code, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{3577                            \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> std::system\_error;}
\DoxyCodeLine{3578 }
\DoxyCodeLine{3596 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3597 \textcolor{keyword}{auto} system\_error(\textcolor{keywordtype}{int} error\_code, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{3598     -\/> std::system\_error \{}
\DoxyCodeLine{3599   \textcolor{keywordflow}{return} vsystem\_error(error\_code, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{3600 \}}
\DoxyCodeLine{3601 }
\DoxyCodeLine{3618 FMT\_API \textcolor{keywordtype}{void} format\_system\_error(detail::buffer<char>\& out, \textcolor{keywordtype}{int} error\_code,}
\DoxyCodeLine{3619                                  \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3620 }
\DoxyCodeLine{3621 \textcolor{comment}{// Reports a system error without throwing an exception.}}
\DoxyCodeLine{3622 \textcolor{comment}{// Can be used to report errors from destructors.}}
\DoxyCodeLine{3623 FMT\_API \textcolor{keywordtype}{void} report\_system\_error(\textcolor{keywordtype}{int} error\_code, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3624 }
\DoxyCodeLine{3626 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__int}{format\_int}} \{}
\DoxyCodeLine{3627  \textcolor{keyword}{private}:}
\DoxyCodeLine{3628   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits10 + 1),}}
\DoxyCodeLine{3629   \textcolor{comment}{// a sign and a null character.}}
\DoxyCodeLine{3630   \textcolor{keyword}{enum} \{ buffer\_size = std::numeric\_limits<unsigned long long>::digits10 + 3 \};}
\DoxyCodeLine{3631   \textcolor{keyword}{mutable} \textcolor{keywordtype}{char} buffer\_[buffer\_size];}
\DoxyCodeLine{3632   \textcolor{keywordtype}{char}* str\_;}
\DoxyCodeLine{3633 }
\DoxyCodeLine{3634   \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt> \textcolor{keyword}{auto} format\_unsigned(UInt value) -\/> \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{3635     \textcolor{keyword}{auto} n = \textcolor{keyword}{static\_cast<}detail::uint32\_or\_64\_or\_128\_t<UInt>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3636     \textcolor{keywordflow}{return} detail::format\_decimal(buffer\_, n, buffer\_size -\/ 1).begin;}
\DoxyCodeLine{3637   \}}
\DoxyCodeLine{3638 }
\DoxyCodeLine{3639   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> \textcolor{keyword}{auto} format\_signed(Int value) -\/> \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{3640     \textcolor{keyword}{auto} abs\_value = \textcolor{keyword}{static\_cast<}detail::uint32\_or\_64\_or\_128\_t<Int>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3641     \textcolor{keywordtype}{bool} negative = value < 0;}
\DoxyCodeLine{3642     \textcolor{keywordflow}{if} (negative) abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{3643     \textcolor{keyword}{auto} begin = format\_unsigned(abs\_value);}
\DoxyCodeLine{3644     \textcolor{keywordflow}{if} (negative) *-\/-\/begin = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{3645     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{3646   \}}
\DoxyCodeLine{3647 }
\DoxyCodeLine{3648  \textcolor{keyword}{public}:}
\DoxyCodeLine{3649   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{int} value) : str\_(format\_signed(value)) \{\}}
\DoxyCodeLine{3650   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{long} value) : str\_(format\_signed(value)) \{\}}
\DoxyCodeLine{3651   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) : str\_(format\_signed(value)) \{\}}
\DoxyCodeLine{3652   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} value) : str\_(format\_unsigned(value)) \{\}}
\DoxyCodeLine{3653   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) : str\_(format\_unsigned(value)) \{\}}
\DoxyCodeLine{3654   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value)}
\DoxyCodeLine{3655       : str\_(format\_unsigned(value)) \{\}}
\DoxyCodeLine{3656 }
\DoxyCodeLine{3658   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_a2f1870d4b535ead8699717fdcb25e997}{size}}() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{3659     \textcolor{keywordflow}{return} detail::to\_unsigned(buffer\_ -\/ str\_ + buffer\_size -\/ 1);}
\DoxyCodeLine{3660   \}}
\DoxyCodeLine{3661 }
\DoxyCodeLine{3666   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_ac8f7ea8ed9a0d5bdfa5cb0661e8851b8}{data}}() const -\/> const \textcolor{keywordtype}{char}* \{ \textcolor{keywordflow}{return} str\_; \}}
\DoxyCodeLine{3667 }
\DoxyCodeLine{3672   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_aadfe4e08e0007018df9c78863ad13d23}{c\_str}}() const -\/> const \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{3673     buffer\_[buffer\_size -\/ 1] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{3674     \textcolor{keywordflow}{return} str\_;}
\DoxyCodeLine{3675   \}}
\DoxyCodeLine{3676 }
\DoxyCodeLine{3682   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_a0f1b5493b06b98edb747737ba864f86f}{str}}() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} std::string(str\_, \mbox{\hyperlink{classformat__int_a2f1870d4b535ead8699717fdcb25e997}{size}}()); \}}
\DoxyCodeLine{3683 \};}
\DoxyCodeLine{3684 }
\DoxyCodeLine{3685 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3686 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3687 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto}}
\DoxyCodeLine{3688 formatter<T, Char,}
\DoxyCodeLine{3689           enable\_if\_t<detail::type\_constant<T, Char>::value !=}
\DoxyCodeLine{3690                       detail::type::custom\_type>>::format(\textcolor{keyword}{const} T\& val,}
\DoxyCodeLine{3691                                                           FormatContext\& ctx)}
\DoxyCodeLine{3692     \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3693   \textcolor{keywordflow}{if} (specs\_.width\_ref.kind != detail::arg\_id\_kind::none ||}
\DoxyCodeLine{3694       specs\_.precision\_ref.kind != detail::arg\_id\_kind::none) \{}
\DoxyCodeLine{3695     \textcolor{keyword}{auto} specs = specs\_;}
\DoxyCodeLine{3696     detail::handle\_dynamic\_spec<detail::width\_checker>(specs.width,}
\DoxyCodeLine{3697                                                        specs.width\_ref, ctx);}
\DoxyCodeLine{3698     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{3699         specs.precision, specs.precision\_ref, ctx);}
\DoxyCodeLine{3700     \textcolor{keywordflow}{return} detail::write<Char>(ctx.out(), val, specs, ctx.locale());}
\DoxyCodeLine{3701   \}}
\DoxyCodeLine{3702   \textcolor{keywordflow}{return} detail::write<Char>(ctx.out(), val, specs\_, ctx.locale());}
\DoxyCodeLine{3703 \}}
\DoxyCodeLine{3704 }
\DoxyCodeLine{3705 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3706 \textcolor{keyword}{struct }formatter<void*, Char> : formatter<const void*, Char> \{}
\DoxyCodeLine{3707   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3708   \textcolor{keyword}{auto} format(\textcolor{keywordtype}{void}* val, FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3709     \textcolor{keywordflow}{return} formatter<const void*, Char>::format(val, ctx);}
\DoxyCodeLine{3710   \}}
\DoxyCodeLine{3711 \};}
\DoxyCodeLine{3712 }
\DoxyCodeLine{3713 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{3714 \textcolor{keyword}{struct }formatter<Char[N], Char> : formatter<basic\_string\_view<Char>, Char> \{}
\DoxyCodeLine{3715   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3716   FMT\_CONSTEXPR \textcolor{keyword}{auto} format(\textcolor{keyword}{const} Char* val, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{3717       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3718     \textcolor{keywordflow}{return} formatter<basic\_string\_view<Char>, Char>::format(val, ctx);}
\DoxyCodeLine{3719   \}}
\DoxyCodeLine{3720 \};}
\DoxyCodeLine{3721 }
\DoxyCodeLine{3722 \textcolor{comment}{// A formatter for types known only at run time such as variant alternatives.}}
\DoxyCodeLine{3723 \textcolor{comment}{//}}
\DoxyCodeLine{3724 \textcolor{comment}{// Usage:}}
\DoxyCodeLine{3725 \textcolor{comment}{//   using variant = std::variant<int, std::string>;}}
\DoxyCodeLine{3726 \textcolor{comment}{//   template <>}}
\DoxyCodeLine{3727 \textcolor{comment}{//   struct formatter<variant>: dynamic\_formatter<> \{}}
\DoxyCodeLine{3728 \textcolor{comment}{//     auto format(const variant\& v, format\_context\& ctx) \{}}
\DoxyCodeLine{3729 \textcolor{comment}{//       return visit([\&](const auto\& val) \{}}
\DoxyCodeLine{3730 \textcolor{comment}{//           return dynamic\_formatter<>::format(val, ctx);}}
\DoxyCodeLine{3731 \textcolor{comment}{//       \}, v);}}
\DoxyCodeLine{3732 \textcolor{comment}{//     \}}}
\DoxyCodeLine{3733 \textcolor{comment}{//   \};}}
\DoxyCodeLine{3734 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}> \textcolor{keyword}{class }dynamic\_formatter \{}
\DoxyCodeLine{3735  \textcolor{keyword}{private}:}
\DoxyCodeLine{3736   detail::dynamic\_format\_specs<Char> specs\_;}
\DoxyCodeLine{3737   \textcolor{keyword}{const} Char* format\_str\_;}
\DoxyCodeLine{3738 }
\DoxyCodeLine{3739   \textcolor{keyword}{struct }null\_handler : detail::error\_handler \{}
\DoxyCodeLine{3740     \textcolor{keywordtype}{void} on\_align(align\_t) \{\}}
\DoxyCodeLine{3741     \textcolor{keywordtype}{void} on\_sign(sign\_t) \{\}}
\DoxyCodeLine{3742     \textcolor{keywordtype}{void} on\_hash() \{\}}
\DoxyCodeLine{3743   \};}
\DoxyCodeLine{3744 }
\DoxyCodeLine{3745   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keywordtype}{void} handle\_specs(Context\& ctx) \{}
\DoxyCodeLine{3746     detail::handle\_dynamic\_spec<detail::width\_checker>(specs\_.width,}
\DoxyCodeLine{3747                                                        specs\_.width\_ref, ctx);}
\DoxyCodeLine{3748     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{3749         specs\_.precision, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{3750   \}}
\DoxyCodeLine{3751 }
\DoxyCodeLine{3752  \textcolor{keyword}{public}:}
\DoxyCodeLine{3753   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3754   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{3755     format\_str\_ = ctx.begin();}
\DoxyCodeLine{3756     \textcolor{comment}{// Checks are deferred to formatting time when the argument type is known.}}
\DoxyCodeLine{3757     detail::dynamic\_specs\_handler<ParseContext> handler(specs\_, ctx);}
\DoxyCodeLine{3758     \textcolor{keywordflow}{return} detail::parse\_format\_specs(ctx.begin(), ctx.end(), handler);}
\DoxyCodeLine{3759   \}}
\DoxyCodeLine{3760 }
\DoxyCodeLine{3761   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3762   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T\& val, FormatContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3763     handle\_specs(ctx);}
\DoxyCodeLine{3764     detail::specs\_checker<null\_handler> checker(}
\DoxyCodeLine{3765         null\_handler(), detail::mapped\_type\_constant<T, FormatContext>::value);}
\DoxyCodeLine{3766     checker.on\_align(specs\_.align);}
\DoxyCodeLine{3767     \textcolor{keywordflow}{if} (specs\_.sign != sign::none) checker.on\_sign(specs\_.sign);}
\DoxyCodeLine{3768     \textcolor{keywordflow}{if} (specs\_.alt) checker.on\_hash();}
\DoxyCodeLine{3769     \textcolor{keywordflow}{if} (specs\_.precision >= 0) checker.end\_precision();}
\DoxyCodeLine{3770     \textcolor{keywordflow}{return} detail::write<Char>(ctx.out(), val, specs\_, ctx.locale());}
\DoxyCodeLine{3771   \}}
\DoxyCodeLine{3772 \};}
\DoxyCodeLine{3773 }
\DoxyCodeLine{3783 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} ptr(T p) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{3784   \textcolor{keyword}{static\_assert}(std::is\_pointer<T>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3785   \textcolor{keywordflow}{return} detail::bit\_cast<const void*>(p);}
\DoxyCodeLine{3786 \}}
\DoxyCodeLine{3787 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} ptr(\textcolor{keyword}{const} std::unique\_ptr<T>\& p) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{3788   \textcolor{keywordflow}{return} p.get();}
\DoxyCodeLine{3789 \}}
\DoxyCodeLine{3790 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} ptr(\textcolor{keyword}{const} std::shared\_ptr<T>\& p) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{3791   \textcolor{keywordflow}{return} p.get();}
\DoxyCodeLine{3792 \}}
\DoxyCodeLine{3793 }
\DoxyCodeLine{3804 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Enum>}
\DoxyCodeLine{3805 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} underlying(Enum e) \textcolor{keyword}{noexcept} -\/> underlying\_t<Enum> \{}
\DoxyCodeLine{3806   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}underlying\_t<Enum>\textcolor{keyword}{>}(e);}
\DoxyCodeLine{3807 \}}
\DoxyCodeLine{3808 }
\DoxyCodeLine{3809 \textcolor{keyword}{namespace }enums \{}
\DoxyCodeLine{3810 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Enum, FMT\_ENABLE\_IF(std::is\_enum<Enum>::value)>}
\DoxyCodeLine{3811 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} format\_as(Enum e) \textcolor{keyword}{noexcept} -\/> underlying\_t<Enum> \{}
\DoxyCodeLine{3812   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}underlying\_t<Enum>\textcolor{keyword}{>}(e);}
\DoxyCodeLine{3813 \}}
\DoxyCodeLine{3814 \}  \textcolor{comment}{// namespace enums}}
\DoxyCodeLine{3815 }
\DoxyCodeLine{3816 \textcolor{keyword}{class }bytes \{}
\DoxyCodeLine{3817  \textcolor{keyword}{private}:}
\DoxyCodeLine{3818   \mbox{\hyperlink{classbasic__string__view}{string\_view}} data\_;}
\DoxyCodeLine{3819   \textcolor{keyword}{friend} \textcolor{keyword}{struct }formatter<bytes>;}
\DoxyCodeLine{3820 }
\DoxyCodeLine{3821  \textcolor{keyword}{public}:}
\DoxyCodeLine{3822   \textcolor{keyword}{explicit} bytes(\mbox{\hyperlink{classbasic__string__view}{string\_view}} data) : data\_(data) \{\}}
\DoxyCodeLine{3823 \};}
\DoxyCodeLine{3824 }
\DoxyCodeLine{3825 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }formatter<bytes> \{}
\DoxyCodeLine{3826  \textcolor{keyword}{private}:}
\DoxyCodeLine{3827   detail::dynamic\_format\_specs<char> specs\_;}
\DoxyCodeLine{3828 }
\DoxyCodeLine{3829  \textcolor{keyword}{public}:}
\DoxyCodeLine{3830   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3831   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{3832     \textcolor{keyword}{using }handler\_type = detail::dynamic\_specs\_handler<ParseContext>;}
\DoxyCodeLine{3833     detail::specs\_checker<handler\_type> handler(handler\_type(specs\_, ctx),}
\DoxyCodeLine{3834                                                 detail::type::string\_type);}
\DoxyCodeLine{3835     \textcolor{keyword}{auto} it = parse\_format\_specs(ctx.begin(), ctx.end(), handler);}
\DoxyCodeLine{3836     detail::check\_string\_type\_spec(specs\_.type, ctx.error\_handler());}
\DoxyCodeLine{3837     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{3838   \}}
\DoxyCodeLine{3839 }
\DoxyCodeLine{3840   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3841   \textcolor{keyword}{auto} format(bytes b, FormatContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3842     detail::handle\_dynamic\_spec<detail::width\_checker>(specs\_.width,}
\DoxyCodeLine{3843                                                        specs\_.width\_ref, ctx);}
\DoxyCodeLine{3844     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{3845         specs\_.precision, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{3846     \textcolor{keywordflow}{return} detail::write\_bytes(ctx.out(), b.data\_, specs\_);}
\DoxyCodeLine{3847   \}}
\DoxyCodeLine{3848 \};}
\DoxyCodeLine{3849 }
\DoxyCodeLine{3850 \textcolor{comment}{// group\_digits\_view is not derived from view because it copies the argument.}}
\DoxyCodeLine{3851 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }group\_digits\_view \{ T value; \};}
\DoxyCodeLine{3852 }
\DoxyCodeLine{3864 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} group\_digits(T value) -\/> group\_digits\_view<T> \{}
\DoxyCodeLine{3865   \textcolor{keywordflow}{return} \{value\};}
\DoxyCodeLine{3866 \}}
\DoxyCodeLine{3867 }
\DoxyCodeLine{3868 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }formatter<group\_digits\_view<T>> : formatter<T> \{}
\DoxyCodeLine{3869  \textcolor{keyword}{private}:}
\DoxyCodeLine{3870   detail::dynamic\_format\_specs<char> specs\_;}
\DoxyCodeLine{3871 }
\DoxyCodeLine{3872  \textcolor{keyword}{public}:}
\DoxyCodeLine{3873   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3874   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{3875     \textcolor{keyword}{using }handler\_type = detail::dynamic\_specs\_handler<ParseContext>;}
\DoxyCodeLine{3876     detail::specs\_checker<handler\_type> handler(handler\_type(specs\_, ctx),}
\DoxyCodeLine{3877                                                 detail::type::int\_type);}
\DoxyCodeLine{3878     \textcolor{keyword}{auto} it = parse\_format\_specs(ctx.begin(), ctx.end(), handler);}
\DoxyCodeLine{3879     detail::check\_string\_type\_spec(specs\_.type, ctx.error\_handler());}
\DoxyCodeLine{3880     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{3881   \}}
\DoxyCodeLine{3882 }
\DoxyCodeLine{3883   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3884   \textcolor{keyword}{auto} format(group\_digits\_view<T> t, FormatContext\& ctx)}
\DoxyCodeLine{3885       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3886     detail::handle\_dynamic\_spec<detail::width\_checker>(specs\_.width,}
\DoxyCodeLine{3887                                                        specs\_.width\_ref, ctx);}
\DoxyCodeLine{3888     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{3889         specs\_.precision, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{3890     \textcolor{keywordflow}{return} detail::write\_int\_localized(}
\DoxyCodeLine{3891         ctx.out(), \textcolor{keyword}{static\_cast<}detail::uint64\_or\_128\_t<T>\textcolor{keyword}{>}(t.value), 0, specs\_,}
\DoxyCodeLine{3892         detail::digit\_grouping<char>(\{\textcolor{stringliteral}{"{}\(\backslash\)3"{}}, \textcolor{stringliteral}{','}\}));}
\DoxyCodeLine{3893   \}}
\DoxyCodeLine{3894 \};}
\DoxyCodeLine{3895 }
\DoxyCodeLine{3896 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Sentinel, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{3897 \textcolor{keyword}{struct }join\_view : detail::view \{}
\DoxyCodeLine{3898   It begin;}
\DoxyCodeLine{3899   Sentinel end;}
\DoxyCodeLine{3900   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep;}
\DoxyCodeLine{3901 }
\DoxyCodeLine{3902   join\_view(It b, Sentinel e, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s)}
\DoxyCodeLine{3903       : begin(b), end(e), sep(s) \{\}}
\DoxyCodeLine{3904 \};}
\DoxyCodeLine{3905 }
\DoxyCodeLine{3906 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Sentinel, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3907 \textcolor{keyword}{struct }formatter<join\_view<It, Sentinel, Char>, Char> \{}
\DoxyCodeLine{3908  \textcolor{keyword}{private}:}
\DoxyCodeLine{3909   \textcolor{keyword}{using }value\_type =}
\DoxyCodeLine{3910 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_ranges}}
\DoxyCodeLine{3911       std::iter\_value\_t<It>;}
\DoxyCodeLine{3912 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3913       \textcolor{keyword}{typename} std::iterator\_traits<It>::value\_type;}
\DoxyCodeLine{3914 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3915   \textcolor{keyword}{using }context = buffer\_context<Char>;}
\DoxyCodeLine{3916   \textcolor{keyword}{using }mapper = detail::arg\_mapper<context>;}
\DoxyCodeLine{3917 }
\DoxyCodeLine{3918   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(has\_formatter<T, context>::value)>}
\DoxyCodeLine{3919   \textcolor{keyword}{static} \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& value) -\/> \textcolor{keyword}{const} T\& \{}
\DoxyCodeLine{3920     \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{3921   \}}
\DoxyCodeLine{3922   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!has\_formatter<T, context>::value)>}
\DoxyCodeLine{3923   \textcolor{keyword}{static} \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& value) -\/> \textcolor{keyword}{decltype}(mapper().map(value)) \{}
\DoxyCodeLine{3924     \textcolor{keywordflow}{return} mapper().map(value);}
\DoxyCodeLine{3925   \}}
\DoxyCodeLine{3926 }
\DoxyCodeLine{3927   \textcolor{keyword}{using }formatter\_type =}
\DoxyCodeLine{3928       conditional\_t<is\_formattable<value\_type, Char>::value,}
\DoxyCodeLine{3929                     formatter<remove\_cvref\_t<\textcolor{keyword}{decltype}(map(}
\DoxyCodeLine{3930                                   std::declval<const value\_type\&>()))>,}
\DoxyCodeLine{3931                               Char>,}
\DoxyCodeLine{3932                     detail::fallback\_formatter<value\_type, Char>>;}
\DoxyCodeLine{3933 }
\DoxyCodeLine{3934   formatter\_type value\_formatter\_;}
\DoxyCodeLine{3935 }
\DoxyCodeLine{3936  \textcolor{keyword}{public}:}
\DoxyCodeLine{3937   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3938   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{3939     \textcolor{keywordflow}{return} value\_formatter\_.parse(ctx);}
\DoxyCodeLine{3940   \}}
\DoxyCodeLine{3941 }
\DoxyCodeLine{3942   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3943   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} join\_view<It, Sentinel, Char>\& value,}
\DoxyCodeLine{3944               FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3945     \textcolor{keyword}{auto} it = value.begin;}
\DoxyCodeLine{3946     \textcolor{keyword}{auto} out = ctx.out();}
\DoxyCodeLine{3947     \textcolor{keywordflow}{if} (it != value.end) \{}
\DoxyCodeLine{3948       out = value\_formatter\_.format(map(*it), ctx);}
\DoxyCodeLine{3949       ++it;}
\DoxyCodeLine{3950       \textcolor{keywordflow}{while} (it != value.end) \{}
\DoxyCodeLine{3951         out = detail::copy\_str<Char>(value.sep.begin(), value.sep.end(), out);}
\DoxyCodeLine{3952         ctx.advance\_to(out);}
\DoxyCodeLine{3953         out = value\_formatter\_.format(map(*it), ctx);}
\DoxyCodeLine{3954         ++it;}
\DoxyCodeLine{3955       \}}
\DoxyCodeLine{3956     \}}
\DoxyCodeLine{3957     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3958   \}}
\DoxyCodeLine{3959 \};}
\DoxyCodeLine{3960 }
\DoxyCodeLine{3965 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Sentinel>}
\DoxyCodeLine{3966 \textcolor{keyword}{auto} join(It begin, Sentinel end, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep) -\/> join\_view<It, Sentinel> \{}
\DoxyCodeLine{3967   \textcolor{keywordflow}{return} \{begin, end, sep\};}
\DoxyCodeLine{3968 \}}
\DoxyCodeLine{3969 }
\DoxyCodeLine{3986 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{3987 \textcolor{keyword}{auto} join(Range\&\& range, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep)}
\DoxyCodeLine{3988     -\/> join\_view<detail::iterator\_t<Range>, detail::sentinel\_t<Range>> \{}
\DoxyCodeLine{3989   \textcolor{keywordflow}{return} join(std::begin(range), std::end(range), sep);}
\DoxyCodeLine{3990 \}}
\DoxyCodeLine{3991 }
\DoxyCodeLine{4003 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{4004 \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string(\textcolor{keyword}{const} T\& value) -\/> std::string \{}
\DoxyCodeLine{4005   \textcolor{keyword}{auto} result = std::string();}
\DoxyCodeLine{4006   detail::write<char>(std::back\_inserter(result), value);}
\DoxyCodeLine{4007   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{4008 \}}
\DoxyCodeLine{4009 }
\DoxyCodeLine{4010 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{4011 FMT\_NODISCARD \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string(T value) -\/> std::string \{}
\DoxyCodeLine{4012   \textcolor{comment}{// The buffer should be large enough to store the number including the sign}}
\DoxyCodeLine{4013   \textcolor{comment}{// or "{}false"{} for bool.}}
\DoxyCodeLine{4014   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} max\_size = detail::digits10<T>() + 2;}
\DoxyCodeLine{4015   \textcolor{keywordtype}{char} \mbox{\hyperlink{classbuffer}{buffer}}[max\_size > 5 ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(max\_size) : 5];}
\DoxyCodeLine{4016   \textcolor{keywordtype}{char}* begin = \mbox{\hyperlink{classbuffer}{buffer}};}
\DoxyCodeLine{4017   \textcolor{keywordflow}{return} std::string(begin, detail::write<char>(begin, value));}
\DoxyCodeLine{4018 \}}
\DoxyCodeLine{4019 }
\DoxyCodeLine{4020 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} SIZE>}
\DoxyCodeLine{4021 FMT\_NODISCARD \textcolor{keyword}{auto} to\_string(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char, SIZE>}}\& buf)}
\DoxyCodeLine{4022     -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{4023   \textcolor{keyword}{auto} size = buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{4024   detail::assume(size < std::basic\_string<Char>().max\_size());}
\DoxyCodeLine{4025   \textcolor{keywordflow}{return} std::basic\_string<Char>(buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), size);}
\DoxyCodeLine{4026 \}}
\DoxyCodeLine{4027 }
\DoxyCodeLine{4028 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{4029 }
\DoxyCodeLine{4030 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{4031 \textcolor{keywordtype}{void} vformat\_to(}
\DoxyCodeLine{4032     \mbox{\hyperlink{classbuffer}{buffer<Char>}}\& buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fmt,}
\DoxyCodeLine{4033     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<FMT\_BUFFER\_CONTEXT(type\_identity\_t<Char>)> args,}
\DoxyCodeLine{4034     locale\_ref loc) \{}
\DoxyCodeLine{4035   \textcolor{comment}{// workaround for msvc bug regarding name-\/lookup in module}}
\DoxyCodeLine{4036   \textcolor{comment}{// link names into function scope}}
\DoxyCodeLine{4037   \textcolor{keyword}{using }detail::arg\_formatter;}
\DoxyCodeLine{4038   \textcolor{keyword}{using }detail::buffer\_appender;}
\DoxyCodeLine{4039   \textcolor{keyword}{using }detail::custom\_formatter;}
\DoxyCodeLine{4040   \textcolor{keyword}{using }detail::default\_arg\_formatter;}
\DoxyCodeLine{4041   \textcolor{keyword}{using }detail::get\_arg;}
\DoxyCodeLine{4042   \textcolor{keyword}{using }detail::locale\_ref;}
\DoxyCodeLine{4043   \textcolor{keyword}{using }detail::parse\_format\_specs;}
\DoxyCodeLine{4044   \textcolor{keyword}{using }detail::specs\_checker;}
\DoxyCodeLine{4045   \textcolor{keyword}{using }detail::specs\_handler;}
\DoxyCodeLine{4046   \textcolor{keyword}{using }detail::to\_unsigned;}
\DoxyCodeLine{4047   \textcolor{keyword}{using }detail::type;}
\DoxyCodeLine{4048   \textcolor{keyword}{using }detail::write;}
\DoxyCodeLine{4049   \textcolor{keyword}{auto} out = buffer\_appender<Char>(buf);}
\DoxyCodeLine{4050   \textcolor{keywordflow}{if} (fmt.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() == 2 \&\& equal2(fmt.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}(), \textcolor{stringliteral}{"{}\{\}"{}})) \{}
\DoxyCodeLine{4051     \textcolor{keyword}{auto} arg = args.\mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(0);}
\DoxyCodeLine{4052     \textcolor{keywordflow}{if} (!arg) error\_handler().on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{4053     visit\_format\_arg(default\_arg\_formatter<Char>\{out, args, loc\}, arg);}
\DoxyCodeLine{4054     \textcolor{keywordflow}{return};}
\DoxyCodeLine{4055   \}}
\DoxyCodeLine{4056 }
\DoxyCodeLine{4057   \textcolor{keyword}{struct }format\_handler : error\_handler \{}
\DoxyCodeLine{4058     \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}} parse\_context;}
\DoxyCodeLine{4059     buffer\_context<Char> context;}
\DoxyCodeLine{4060 }
\DoxyCodeLine{4061     format\_handler(buffer\_appender<Char> p\_out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str,}
\DoxyCodeLine{4062                    \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<buffer\_context<Char>> p\_args,}
\DoxyCodeLine{4063                    locale\_ref p\_loc)}
\DoxyCodeLine{4064         : parse\_context(str), context(p\_out, p\_args, p\_loc) \{\}}
\DoxyCodeLine{4065 }
\DoxyCodeLine{4066     \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end) \{}
\DoxyCodeLine{4067       \textcolor{keyword}{auto} text = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(begin, to\_unsigned(end -\/ begin));}
\DoxyCodeLine{4068       context.advance\_to(write<Char>(context.out(), text));}
\DoxyCodeLine{4069     \}}
\DoxyCodeLine{4070 }
\DoxyCodeLine{4071     FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{4072       \textcolor{keywordflow}{return} parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}}();}
\DoxyCodeLine{4073     \}}
\DoxyCodeLine{4074     FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{4075       \textcolor{keywordflow}{return} parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(\textcolor{keywordtype}{id}), id;}
\DoxyCodeLine{4076     \}}
\DoxyCodeLine{4077     FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{4078       \textcolor{keywordtype}{int} arg\_id = context.arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{4079       \textcolor{keywordflow}{if} (arg\_id < 0) on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{4080       \textcolor{keywordflow}{return} arg\_id;}
\DoxyCodeLine{4081     \}}
\DoxyCodeLine{4082 }
\DoxyCodeLine{4083     FMT\_INLINE \textcolor{keywordtype}{void} on\_replacement\_field(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char*) \{}
\DoxyCodeLine{4084       \textcolor{keyword}{auto} arg = get\_arg(context, \textcolor{keywordtype}{id});}
\DoxyCodeLine{4085       context.advance\_to(visit\_format\_arg(}
\DoxyCodeLine{4086           default\_arg\_formatter<Char>\{context.out(), context.args(),}
\DoxyCodeLine{4087                                       context.locale()\},}
\DoxyCodeLine{4088           arg));}
\DoxyCodeLine{4089     \}}
\DoxyCodeLine{4090 }
\DoxyCodeLine{4091     \textcolor{keyword}{auto} on\_format\_specs(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end)}
\DoxyCodeLine{4092         -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{4093       \textcolor{keyword}{auto} arg = get\_arg(context, \textcolor{keywordtype}{id});}
\DoxyCodeLine{4094       \textcolor{keywordflow}{if} (arg.type() == type::custom\_type) \{}
\DoxyCodeLine{4095         parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_ac123ab6c1c6e58db3ab0a917def4add8}{advance\_to}}(parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}() +}
\DoxyCodeLine{4096                                  (begin -\/ \&*parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}()));}
\DoxyCodeLine{4097         visit\_format\_arg(custom\_formatter<Char>\{parse\_context, context\}, arg);}
\DoxyCodeLine{4098         \textcolor{keywordflow}{return} parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}();}
\DoxyCodeLine{4099       \}}
\DoxyCodeLine{4100       \textcolor{keyword}{auto} specs = basic\_format\_specs<Char>();}
\DoxyCodeLine{4101       specs\_checker<specs\_handler<Char>> handler(}
\DoxyCodeLine{4102           specs\_handler<Char>(specs, parse\_context, context), arg.type());}
\DoxyCodeLine{4103       begin = parse\_format\_specs(begin, end, handler);}
\DoxyCodeLine{4104       \textcolor{keywordflow}{if} (begin == end || *begin != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{4105         on\_error(\textcolor{stringliteral}{"{}missing '\}' in format string"{}});}
\DoxyCodeLine{4106       \textcolor{keyword}{auto} f = arg\_formatter<Char>\{context.out(), specs, context.locale()\};}
\DoxyCodeLine{4107       context.advance\_to(visit\_format\_arg(f, arg));}
\DoxyCodeLine{4108       \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{4109     \}}
\DoxyCodeLine{4110   \};}
\DoxyCodeLine{4111   detail::parse\_format\_string<false>(fmt, format\_handler(out, fmt, args, loc));}
\DoxyCodeLine{4112 \}}
\DoxyCodeLine{4113 }
\DoxyCodeLine{4114 \textcolor{preprocessor}{\#ifndef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{4115 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} thousands\_sep\_impl<char>(locale\_ref)}
\DoxyCodeLine{4116     -\/> thousands\_sep\_result<char>;}
\DoxyCodeLine{4117 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} thousands\_sep\_impl<wchar\_t>(locale\_ref)}
\DoxyCodeLine{4118     -\/> thousands\_sep\_result<wchar\_t>;}
\DoxyCodeLine{4119 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} decimal\_point\_impl(locale\_ref) -\/> char;}
\DoxyCodeLine{4120 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} decimal\_point\_impl(locale\_ref) -\/> wchar\_t;}
\DoxyCodeLine{4121 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_HEADER\_ONLY}}
\DoxyCodeLine{4122 }
\DoxyCodeLine{4123 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{4124 }
\DoxyCodeLine{4125 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{4126 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{4137 \textcolor{preprocessor}{\#  if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{4138 \textcolor{keyword}{template} <detail\_exported::fixed\_\textcolor{keywordtype}{string} Str> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_a() \{}
\DoxyCodeLine{4139   \textcolor{keyword}{using }char\_t = remove\_cvref\_t<\textcolor{keyword}{decltype}(Str.data[0])>;}
\DoxyCodeLine{4140   \textcolor{keywordflow}{return} detail::udl\_arg<char\_t, \textcolor{keyword}{sizeof}(Str.data) / \textcolor{keyword}{sizeof}(char\_t), Str>();}
\DoxyCodeLine{4141 \}}
\DoxyCodeLine{4142 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{4143 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{size\_t}) -\/> detail::udl\_arg<char> \{}
\DoxyCodeLine{4144   \textcolor{keywordflow}{return} \{s\};}
\DoxyCodeLine{4145 \}}
\DoxyCodeLine{4146 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{4147 \}  \textcolor{comment}{// namespace literals}}
\DoxyCodeLine{4148 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{4149 }
\DoxyCodeLine{4150 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, FMT\_ENABLE\_IF(detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4151 \textcolor{keyword}{inline} \textcolor{keyword}{auto} vformat(\textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args)}
\DoxyCodeLine{4152     -\/> std::string \{}
\DoxyCodeLine{4153   \textcolor{keywordflow}{return} detail::vformat(loc, fmt, args);}
\DoxyCodeLine{4154 \}}
\DoxyCodeLine{4155 }
\DoxyCodeLine{4156 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{4157           FMT\_ENABLE\_IF(detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4158 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format(\textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{4159     -\/> std::string \{}
\DoxyCodeLine{4160   \textcolor{keywordflow}{return} vformat(loc, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(fmt), fmt::make\_format\_args(args...));}
\DoxyCodeLine{4161 \}}
\DoxyCodeLine{4162 }
\DoxyCodeLine{4163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Locale,}
\DoxyCodeLine{4164           FMT\_ENABLE\_IF(detail::is\_output\_iterator<OutputIt, char>::value\&\&}
\DoxyCodeLine{4165                             detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4166 \textcolor{keyword}{auto} vformat\_to(OutputIt out, \textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt,}
\DoxyCodeLine{4167                 \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> OutputIt \{}
\DoxyCodeLine{4168   \textcolor{keyword}{using }detail::get\_buffer;}
\DoxyCodeLine{4169   \textcolor{keyword}{auto}\&\& buf = get\_buffer<char>(out);}
\DoxyCodeLine{4170   detail::vformat\_to(buf, fmt, args, detail::locale\_ref(loc));}
\DoxyCodeLine{4171   \textcolor{keywordflow}{return} detail::get\_iterator(buf);}
\DoxyCodeLine{4172 \}}
\DoxyCodeLine{4173 }
\DoxyCodeLine{4174 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{4175           FMT\_ENABLE\_IF(detail::is\_output\_iterator<OutputIt, char>::value\&\&}
\DoxyCodeLine{4176                             detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4177 FMT\_INLINE \textcolor{keyword}{auto} format\_to(OutputIt out, \textcolor{keyword}{const} Locale\& loc,}
\DoxyCodeLine{4178                           \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) -\/> OutputIt \{}
\DoxyCodeLine{4179   \textcolor{keywordflow}{return} vformat\_to(out, loc, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{4180 \}}
\DoxyCodeLine{4181 }
\DoxyCodeLine{4182 FMT\_MODULE\_EXPORT\_END}
\DoxyCodeLine{4183 FMT\_END\_NAMESPACE}
\DoxyCodeLine{4184 }
\DoxyCodeLine{4185 \textcolor{preprocessor}{\#ifdef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{4186 \textcolor{preprocessor}{\#  define FMT\_FUNC inline}}
\DoxyCodeLine{4187 \textcolor{preprocessor}{\#  include "{}format-\/inl.h"{}}}
\DoxyCodeLine{4188 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4189 \textcolor{preprocessor}{\#  define FMT\_FUNC}}
\DoxyCodeLine{4190 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4191 }
\DoxyCodeLine{4192 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_FORMAT\_H\_}}

\end{DoxyCode}

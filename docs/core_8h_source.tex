\hypertarget{core_8h_source}{}\doxysection{core.\+h}
\label{core_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/core.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/core.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ the core API for char/UTF-\/8}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_CORE\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_CORE\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <cstddef>}  \textcolor{comment}{// std::byte}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <cstdio>}   \textcolor{comment}{// std::FILE}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cstring>}  \textcolor{comment}{// std::strlen}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{comment}{// The fmt library version in the form major * 10000 + minor * 100 + patch.}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#define FMT\_VERSION 90000}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_) \&\& !defined(\_\_ibmxl\_\_)}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#  define FMT\_CLANG\_VERSION (\_\_clang\_major\_\_ * 100 + \_\_clang\_minor\_\_)}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#  define FMT\_CLANG\_VERSION 0}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_) \&\& !defined(\_\_INTEL\_COMPILER) \&\& \(\backslash\)}}
\DoxyCodeLine{29 \textcolor{preprocessor}{    !defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#  define FMT\_GCC\_VERSION (\_\_GNUC\_\_ * 100 + \_\_GNUC\_MINOR\_\_)}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#  define FMT\_GCC\_VERSION 0}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{preprocessor}{\#ifndef FMT\_GCC\_PRAGMA}}
\DoxyCodeLine{36 \textcolor{comment}{// Workaround \_Pragma bug https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=59884.}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#  if FMT\_GCC\_VERSION >= 504}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#    define FMT\_GCC\_PRAGMA(arg) \_Pragma(arg)}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#    define FMT\_GCC\_PRAGMA(arg)}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#ifdef \_\_ICL}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#  define FMT\_ICC\_VERSION \_\_ICL}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#elif defined(\_\_INTEL\_COMPILER)}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#  define FMT\_ICC\_VERSION \_\_INTEL\_COMPILER}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#  define FMT\_ICC\_VERSION 0}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#  define FMT\_MSC\_VERSION \_MSC\_VER}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#  define FMT\_MSC\_WARNING(...) \_\_pragma(warning(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#  define FMT\_MSC\_VERSION 0}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#  define FMT\_MSC\_WARNING(...)}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60 \textcolor{preprocessor}{\#ifdef \_MSVC\_LANG}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#  define FMT\_CPLUSPLUS \_MSVC\_LANG}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  define FMT\_CPLUSPLUS \_\_cplusplus}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#  define FMT\_HAS\_FEATURE(x) \_\_has\_feature(x)}}
\DoxyCodeLine{68 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\#  define FMT\_HAS\_FEATURE(x) 0}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \textcolor{preprocessor}{\#if (defined(\_\_has\_include) || FMT\_ICC\_VERSION >= 1600 || \(\backslash\)}}
\DoxyCodeLine{73 \textcolor{preprocessor}{     FMT\_MSC\_VERSION > 1900) \&\&                           \(\backslash\)}}
\DoxyCodeLine{74 \textcolor{preprocessor}{    !defined(\_\_INTELLISENSE\_\_)}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#  define FMT\_HAS\_INCLUDE(x) \_\_has\_include(x)}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#  define FMT\_HAS\_INCLUDE(x) 0}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{preprocessor}{\#ifdef \_\_has\_cpp\_attribute}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#  define FMT\_HAS\_CPP\_ATTRIBUTE(x) \_\_has\_cpp\_attribute(x)}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{83 \textcolor{preprocessor}{\#  define FMT\_HAS\_CPP\_ATTRIBUTE(x) 0}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{85 }
\DoxyCodeLine{86 \textcolor{preprocessor}{\#define FMT\_HAS\_CPP14\_ATTRIBUTE(attribute) \(\backslash\)}}
\DoxyCodeLine{87 \textcolor{preprocessor}{  (FMT\_CPLUSPLUS >= 201402L \&\& FMT\_HAS\_CPP\_ATTRIBUTE(attribute))}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{preprocessor}{\#define FMT\_HAS\_CPP17\_ATTRIBUTE(attribute) \(\backslash\)}}
\DoxyCodeLine{90 \textcolor{preprocessor}{  (FMT\_CPLUSPLUS >= 201703L \&\& FMT\_HAS\_CPP\_ATTRIBUTE(attribute))}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92 \textcolor{comment}{// Check if relaxed C++14 constexpr is supported.}}
\DoxyCodeLine{93 \textcolor{comment}{// GCC doesn't allow throw in constexpr until version 6 (bug 67371).}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#ifndef FMT\_USE\_CONSTEXPR}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\#  if (FMT\_HAS\_FEATURE(cxx\_relaxed\_constexpr) || FMT\_MSC\_VERSION >= 1912 || \(\backslash\)}}
\DoxyCodeLine{96 \textcolor{preprocessor}{       (FMT\_GCC\_VERSION >= 600 \&\& FMT\_CPLUSPLUS >= 201402L)) \&\&             \(\backslash\)}}
\DoxyCodeLine{97 \textcolor{preprocessor}{      !FMT\_ICC\_VERSION \&\& !defined(\_\_NVCC\_\_)}}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#    define FMT\_USE\_CONSTEXPR 1}}
\DoxyCodeLine{99 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{100 \textcolor{preprocessor}{\#    define FMT\_USE\_CONSTEXPR 0}}
\DoxyCodeLine{101 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{103 \textcolor{preprocessor}{\#if FMT\_USE\_CONSTEXPR}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR constexpr}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{106 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR}}
\DoxyCodeLine{107 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{preprocessor}{\#if ((FMT\_CPLUSPLUS >= 202002L) \&\&                            \(\backslash\)}}
\DoxyCodeLine{110 \textcolor{preprocessor}{     (!defined(\_GLIBCXX\_RELEASE) || \_GLIBCXX\_RELEASE > 9)) || \(\backslash\)}}
\DoxyCodeLine{111 \textcolor{preprocessor}{    (FMT\_CPLUSPLUS >= 201709L \&\& FMT\_GCC\_VERSION >= 1002)}}
\DoxyCodeLine{112 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR20 constexpr}}
\DoxyCodeLine{113 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR20}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117 \textcolor{comment}{// Check if constexpr std::char\_traits<>::\{compare,length\} are supported.}}
\DoxyCodeLine{118 \textcolor{preprocessor}{\#if defined(\_\_GLIBCXX\_\_)}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#  if FMT\_CPLUSPLUS >= 201703L \&\& defined(\_GLIBCXX\_RELEASE) \&\& \(\backslash\)}}
\DoxyCodeLine{120 \textcolor{preprocessor}{      \_GLIBCXX\_RELEASE >= 7  }\textcolor{comment}{// GCC 7+ libstdc++ has \_GLIBCXX\_RELEASE.}}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#    define FMT\_CONSTEXPR\_CHAR\_TRAITS constexpr}}
\DoxyCodeLine{122 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#elif defined(\_LIBCPP\_VERSION) \&\& FMT\_CPLUSPLUS >= 201703L \&\& \(\backslash\)}}
\DoxyCodeLine{124 \textcolor{preprocessor}{    \_LIBCPP\_VERSION >= 4000}}
\DoxyCodeLine{125 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR\_CHAR\_TRAITS constexpr}}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#elif FMT\_MSC\_VERSION >= 1914 \&\& FMT\_CPLUSPLUS >= 201703L}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR\_CHAR\_TRAITS constexpr}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#ifndef FMT\_CONSTEXPR\_CHAR\_TRAITS}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR\_CHAR\_TRAITS}}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{comment}{// Check if exceptions are disabled.}}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#ifndef FMT\_EXCEPTIONS}}
\DoxyCodeLine{135 \textcolor{preprocessor}{\#  if (defined(\_\_GNUC\_\_) \&\& !defined(\_\_EXCEPTIONS)) || \(\backslash\)}}
\DoxyCodeLine{136 \textcolor{preprocessor}{      (FMT\_MSC\_VERSION \&\& !\_HAS\_EXCEPTIONS)}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#    define FMT\_EXCEPTIONS 0}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#    define FMT\_EXCEPTIONS 1}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{141 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{preprocessor}{\#ifndef FMT\_DEPRECATED}}
\DoxyCodeLine{144 \textcolor{preprocessor}{\#  if FMT\_HAS\_CPP14\_ATTRIBUTE(deprecated) || FMT\_MSC\_VERSION >= 1900}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#    define FMT\_DEPRECATED [[deprecated]]}}
\DoxyCodeLine{146 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#    if (defined(\_\_GNUC\_\_) \&\& !defined(\_\_LCC\_\_)) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#      define FMT\_DEPRECATED \_\_attribute\_\_((deprecated))}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#    elif FMT\_MSC\_VERSION}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#      define FMT\_DEPRECATED \_\_declspec(deprecated)}}
\DoxyCodeLine{151 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{152 \textcolor{preprocessor}{\#      define FMT\_DEPRECATED }\textcolor{comment}{/* deprecated */}\textcolor{preprocessor}{}}
\DoxyCodeLine{153 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{154 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{155 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{comment}{// [[noreturn]] is disabled on MSVC and NVCC because of bogus unreachable code}}
\DoxyCodeLine{158 \textcolor{comment}{// warnings.}}
\DoxyCodeLine{159 \textcolor{preprocessor}{\#if FMT\_EXCEPTIONS \&\& FMT\_HAS\_CPP\_ATTRIBUTE(noreturn) \&\& !FMT\_MSC\_VERSION \&\& \(\backslash\)}}
\DoxyCodeLine{160 \textcolor{preprocessor}{    !defined(\_\_NVCC\_\_)}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#  define FMT\_NORETURN [[noreturn]]}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{163 \textcolor{preprocessor}{\#  define FMT\_NORETURN}}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 \textcolor{preprocessor}{\#if FMT\_HAS\_CPP17\_ATTRIBUTE(fallthrough)}}
\DoxyCodeLine{167 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH [[fallthrough]]}}
\DoxyCodeLine{168 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_)}}
\DoxyCodeLine{169 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH [[clang::fallthrough]]}}
\DoxyCodeLine{170 \textcolor{preprocessor}{\#elif FMT\_GCC\_VERSION >= 700 \&\& \(\backslash\)}}
\DoxyCodeLine{171 \textcolor{preprocessor}{    (!defined(\_\_EDG\_VERSION\_\_) || \_\_EDG\_VERSION\_\_ >= 520)}}
\DoxyCodeLine{172 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH [[gnu::fallthrough]]}}
\DoxyCodeLine{173 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{174 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH}}
\DoxyCodeLine{175 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177 \textcolor{preprocessor}{\#ifndef FMT\_NODISCARD}}
\DoxyCodeLine{178 \textcolor{preprocessor}{\#  if FMT\_HAS\_CPP17\_ATTRIBUTE(nodiscard)}}
\DoxyCodeLine{179 \textcolor{preprocessor}{\#    define FMT\_NODISCARD [[nodiscard]]}}
\DoxyCodeLine{180 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{181 \textcolor{preprocessor}{\#    define FMT\_NODISCARD}}
\DoxyCodeLine{182 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{preprocessor}{\#ifndef FMT\_USE\_FLOAT}}
\DoxyCodeLine{186 \textcolor{preprocessor}{\#  define FMT\_USE\_FLOAT 1}}
\DoxyCodeLine{187 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{188 \textcolor{preprocessor}{\#ifndef FMT\_USE\_DOUBLE}}
\DoxyCodeLine{189 \textcolor{preprocessor}{\#  define FMT\_USE\_DOUBLE 1}}
\DoxyCodeLine{190 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{191 \textcolor{preprocessor}{\#ifndef FMT\_USE\_LONG\_DOUBLE}}
\DoxyCodeLine{192 \textcolor{preprocessor}{\#  define FMT\_USE\_LONG\_DOUBLE 1}}
\DoxyCodeLine{193 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{preprocessor}{\#ifndef FMT\_INLINE}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#  if FMT\_GCC\_VERSION || FMT\_CLANG\_VERSION}}
\DoxyCodeLine{197 \textcolor{preprocessor}{\#    define FMT\_INLINE inline \_\_attribute\_\_((always\_inline))}}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#    define FMT\_INLINE inline}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{202 }
\DoxyCodeLine{203 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{204 \textcolor{preprocessor}{\#  define FMT\_UNCHECKED\_ITERATOR(It) \(\backslash\)}}
\DoxyCodeLine{205 \textcolor{preprocessor}{    using \_Unchecked\_type = It  }\textcolor{comment}{// Mark iterator as checked.}}
\DoxyCodeLine{206 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#  define FMT\_UNCHECKED\_ITERATOR(It) using unchecked\_type = It}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 \textcolor{preprocessor}{\#ifndef FMT\_BEGIN\_NAMESPACE}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#  define FMT\_BEGIN\_NAMESPACE \(\backslash\)}}
\DoxyCodeLine{212 \textcolor{preprocessor}{    namespace fmt \{           \(\backslash\)}}
\DoxyCodeLine{213 \textcolor{preprocessor}{    inline namespace v9 \{}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#  define FMT\_END\_NAMESPACE \(\backslash\)}}
\DoxyCodeLine{215 \textcolor{preprocessor}{    \}                       \(\backslash\)}}
\DoxyCodeLine{216 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{217 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{218 }
\DoxyCodeLine{219 \textcolor{preprocessor}{\#ifndef FMT\_MODULE\_EXPORT}}
\DoxyCodeLine{220 \textcolor{preprocessor}{\#  define FMT\_MODULE\_EXPORT}}
\DoxyCodeLine{221 \textcolor{preprocessor}{\#  define FMT\_MODULE\_EXPORT\_BEGIN}}
\DoxyCodeLine{222 \textcolor{preprocessor}{\#  define FMT\_MODULE\_EXPORT\_END}}
\DoxyCodeLine{223 \textcolor{preprocessor}{\#  define FMT\_BEGIN\_DETAIL\_NAMESPACE namespace detail \{}}
\DoxyCodeLine{224 \textcolor{preprocessor}{\#  define FMT\_END\_DETAIL\_NAMESPACE \}}}
\DoxyCodeLine{225 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 \textcolor{preprocessor}{\#if !defined(FMT\_HEADER\_ONLY) \&\& defined(\_WIN32)}}
\DoxyCodeLine{228 \textcolor{preprocessor}{\#  define FMT\_CLASS\_API FMT\_MSC\_WARNING(suppress : 4275)}}
\DoxyCodeLine{229 \textcolor{preprocessor}{\#  ifdef FMT\_EXPORT}}
\DoxyCodeLine{230 \textcolor{preprocessor}{\#    define FMT\_API \_\_declspec(dllexport)}}
\DoxyCodeLine{231 \textcolor{preprocessor}{\#  elif 1}}
\DoxyCodeLine{232 \textcolor{preprocessor}{\#    define FMT\_API \_\_declspec(dllimport)}}
\DoxyCodeLine{233 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{235 \textcolor{preprocessor}{\#  define FMT\_CLASS\_API}}
\DoxyCodeLine{236 \textcolor{preprocessor}{\#  if defined(FMT\_EXPORT) || 1}}
\DoxyCodeLine{237 \textcolor{preprocessor}{\#    if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{238 \textcolor{preprocessor}{\#      define FMT\_API \_\_attribute\_\_((visibility("{}default"{}})))}
\DoxyCodeLine{239 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{241 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{242 \textcolor{preprocessor}{\#ifndef FMT\_API}}
\DoxyCodeLine{243 \textcolor{preprocessor}{\#  define FMT\_API}}
\DoxyCodeLine{244 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{245 }
\DoxyCodeLine{246 \textcolor{comment}{// libc++ supports string\_view in pre-\/c++17.}}
\DoxyCodeLine{247 \textcolor{preprocessor}{\#if FMT\_HAS\_INCLUDE(<string\_view>) \&\& \(\backslash\)}}
\DoxyCodeLine{248 \textcolor{preprocessor}{    (FMT\_CPLUSPLUS >= 201703L || defined(\_LIBCPP\_VERSION))}}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#  include <string\_view>}}
\DoxyCodeLine{250 \textcolor{preprocessor}{\#  define FMT\_USE\_STRING\_VIEW}}
\DoxyCodeLine{251 \textcolor{preprocessor}{\#elif FMT\_HAS\_INCLUDE("{}experimental/string\_view"{}}) \&\& FMT\_CPLUSPLUS >= 201402L}
\DoxyCodeLine{252 \textcolor{preprocessor}{\#  include <experimental/string\_view>}}
\DoxyCodeLine{253 \textcolor{preprocessor}{\#  define FMT\_USE\_EXPERIMENTAL\_STRING\_VIEW}}
\DoxyCodeLine{254 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 \textcolor{preprocessor}{\#ifndef FMT\_UNICODE}}
\DoxyCodeLine{257 \textcolor{preprocessor}{\#  define FMT\_UNICODE !FMT\_MSC\_VERSION}}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \textcolor{preprocessor}{\#ifndef FMT\_CONSTEVAL}}
\DoxyCodeLine{261 \textcolor{preprocessor}{\#  if ((FMT\_GCC\_VERSION >= 1000 || FMT\_CLANG\_VERSION >= 1101) \&\&         \(\backslash\)}}
\DoxyCodeLine{262 \textcolor{preprocessor}{       FMT\_CPLUSPLUS >= 202002L \&\& !defined(\_\_apple\_build\_version\_\_)) || \(\backslash\)}}
\DoxyCodeLine{263 \textcolor{preprocessor}{      (defined(\_\_cpp\_consteval) \&\&                                       \(\backslash\)}}
\DoxyCodeLine{264 \textcolor{preprocessor}{       (!FMT\_MSC\_VERSION || \_MSC\_FULL\_VER >= 193030704))}}
\DoxyCodeLine{265 \textcolor{comment}{// consteval is broken in MSVC before VS2022 and Apple clang 13.}}
\DoxyCodeLine{266 \textcolor{preprocessor}{\#    define FMT\_CONSTEVAL consteval}}
\DoxyCodeLine{267 \textcolor{preprocessor}{\#    define FMT\_HAS\_CONSTEVAL}}
\DoxyCodeLine{268 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{269 \textcolor{preprocessor}{\#    define FMT\_CONSTEVAL}}
\DoxyCodeLine{270 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{271 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{272 }
\DoxyCodeLine{273 \textcolor{preprocessor}{\#ifndef FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{274 \textcolor{preprocessor}{\#  if defined(\_\_cpp\_nontype\_template\_args) \&\&                  \(\backslash\)}}
\DoxyCodeLine{275 \textcolor{preprocessor}{      ((FMT\_GCC\_VERSION >= 903 \&\& FMT\_CPLUSPLUS >= 201709L) || \(\backslash\)}}
\DoxyCodeLine{276 \textcolor{preprocessor}{       \_\_cpp\_nontype\_template\_args >= 201911L)}}
\DoxyCodeLine{277 \textcolor{preprocessor}{\#    define FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS 1}}
\DoxyCodeLine{278 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{279 \textcolor{preprocessor}{\#    define FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS 0}}
\DoxyCodeLine{280 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{281 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 \textcolor{comment}{// Enable minimal optimizations for more compact code in debug mode.}}
\DoxyCodeLine{284 FMT\_GCC\_PRAGMA(\textcolor{stringliteral}{"{}GCC push\_options"{}})}
\DoxyCodeLine{285 \textcolor{preprocessor}{\#if !defined(\_\_OPTIMIZE\_\_) \&\& !defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{286 FMT\_GCC\_PRAGMA(\textcolor{stringliteral}{"{}GCC optimize(\(\backslash\)"{}Og\(\backslash\)"{})"{}})}
\DoxyCodeLine{287 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{288 }
\DoxyCodeLine{289 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{290 FMT\_MODULE\_EXPORT\_BEGIN}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{comment}{// Implementations of enable\_if\_t and other metafunctions for older systems.}}
\DoxyCodeLine{293 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B, \textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{294 \textcolor{keyword}{using }enable\_if\_t = \textcolor{keyword}{typename} std::enable\_if<B, T>::type;}
\DoxyCodeLine{295 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{296 \textcolor{keyword}{using }conditional\_t = \textcolor{keyword}{typename} std::conditional<B, T, F>::type;}
\DoxyCodeLine{297 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B> \textcolor{keyword}{using }bool\_constant = std::integral\_constant<bool, B>;}
\DoxyCodeLine{298 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{299 \textcolor{keyword}{using }remove\_reference\_t = \textcolor{keyword}{typename} std::remove\_reference<T>::type;}
\DoxyCodeLine{300 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{301 \textcolor{keyword}{using }remove\_const\_t = \textcolor{keyword}{typename} std::remove\_const<T>::type;}
\DoxyCodeLine{302 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{303 \textcolor{keyword}{using }remove\_cvref\_t = \textcolor{keyword}{typename} std::remove\_cv<remove\_reference\_t<T>>::type;}
\DoxyCodeLine{304 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }type\_identity \{ \textcolor{keyword}{using }type = T; \};}
\DoxyCodeLine{305 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }type\_identity\_t = \textcolor{keyword}{typename} type\_identity<T>::type;}
\DoxyCodeLine{306 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{307 \textcolor{keyword}{using }underlying\_t = \textcolor{keyword}{typename} std::underlying\_type<T>::type;}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{struct }disjunction : std::false\_type \{\};}
\DoxyCodeLine{310 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P> \textcolor{keyword}{struct }disjunction<P> : P \{\};}
\DoxyCodeLine{311 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1, \textcolor{keyword}{typename}... Pn>}
\DoxyCodeLine{312 \textcolor{keyword}{struct }disjunction<P1, Pn...>}
\DoxyCodeLine{313     : conditional\_t<bool(P1::value), P1, disjunction<Pn...>> \{\};}
\DoxyCodeLine{314 }
\DoxyCodeLine{315 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{struct }conjunction : std::true\_type \{\};}
\DoxyCodeLine{316 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P> \textcolor{keyword}{struct }conjunction<P> : P \{\};}
\DoxyCodeLine{317 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1, \textcolor{keyword}{typename}... Pn>}
\DoxyCodeLine{318 \textcolor{keyword}{struct }conjunction<P1, Pn...>}
\DoxyCodeLine{319     : conditional\_t<bool(P1::value), conjunction<Pn...>, P1> \{\};}
\DoxyCodeLine{320 }
\DoxyCodeLine{321 \textcolor{keyword}{struct }monostate \{}
\DoxyCodeLine{322   \textcolor{keyword}{constexpr} monostate() \{\}}
\DoxyCodeLine{323 \};}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 \textcolor{comment}{// An enable\_if helper to be used in template parameters which results in much}}
\DoxyCodeLine{326 \textcolor{comment}{// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed}}
\DoxyCodeLine{327 \textcolor{comment}{// to workaround a bug in MSVC 2019 (see \#1140 and \#1186).}}
\DoxyCodeLine{328 \textcolor{preprocessor}{\#ifdef FMT\_DOC}}
\DoxyCodeLine{329 \textcolor{preprocessor}{\#  define FMT\_ENABLE\_IF(...)}}
\DoxyCodeLine{330 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{331 \textcolor{preprocessor}{\#  define FMT\_ENABLE\_IF(...) enable\_if\_t<(\_\_VA\_ARGS\_\_), int> = 0}}
\DoxyCodeLine{332 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{335 }
\DoxyCodeLine{336 \textcolor{comment}{// Suppresses "{}unused variable"{} warnings with the method described in}}
\DoxyCodeLine{337 \textcolor{comment}{// https://herbsutter.com/2009/10/18/mailbag-\/shutting-\/up-\/compiler-\/warnings/.}}
\DoxyCodeLine{338 \textcolor{comment}{// (void)var does not work on many Intel compilers.}}
\DoxyCodeLine{339 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T> FMT\_CONSTEXPR \textcolor{keywordtype}{void} ignore\_unused(\textcolor{keyword}{const} T\&...) \{\}}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 \textcolor{keyword}{constexpr} FMT\_INLINE \textcolor{keyword}{auto} is\_constant\_evaluated(}
\DoxyCodeLine{342     \textcolor{keywordtype}{bool} default\_value = \textcolor{keyword}{false}) noexcept -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{343 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_is\_constant\_evaluated}}
\DoxyCodeLine{344   ignore\_unused(default\_value);}
\DoxyCodeLine{345   \textcolor{keywordflow}{return} std::is\_constant\_evaluated();}
\DoxyCodeLine{346 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{347   \textcolor{keywordflow}{return} default\_value;}
\DoxyCodeLine{348 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{349 \}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 \textcolor{comment}{// Suppresses "{}conditional expression is constant"{} warnings.}}
\DoxyCodeLine{352 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} FMT\_INLINE \textcolor{keyword}{auto} const\_check(T value) -\/> T \{}
\DoxyCodeLine{353   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{354 \}}
\DoxyCodeLine{355 }
\DoxyCodeLine{356 FMT\_NORETURN FMT\_API \textcolor{keywordtype}{void} assert\_fail(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{357                                       \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message);}
\DoxyCodeLine{358 }
\DoxyCodeLine{359 \textcolor{preprocessor}{\#ifndef FMT\_ASSERT}}
\DoxyCodeLine{360 \textcolor{preprocessor}{\#  ifdef NDEBUG}}
\DoxyCodeLine{361 \textcolor{comment}{// FMT\_ASSERT is not empty to avoid -\/Wempty-\/body.}}
\DoxyCodeLine{362 \textcolor{preprocessor}{\#    define FMT\_ASSERT(condition, message) \(\backslash\)}}
\DoxyCodeLine{363 \textcolor{preprocessor}{      ::fmt::detail::ignore\_unused((condition), (message))}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{365 \textcolor{preprocessor}{\#    define FMT\_ASSERT(condition, message)                                    \(\backslash\)}}
\DoxyCodeLine{366 \textcolor{preprocessor}{      ((condition) }\textcolor{comment}{/* void() fails with -\/Winvalid-\/constexpr on clang 4.0.1 */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{367 \textcolor{preprocessor}{           ? (void)0                                                          \(\backslash\)}}
\DoxyCodeLine{368 \textcolor{preprocessor}{           : ::fmt::detail::assert\_fail(\_\_FILE\_\_, \_\_LINE\_\_, (message)))}}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{370 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{371 }
\DoxyCodeLine{372 \textcolor{preprocessor}{\#if defined(FMT\_USE\_STRING\_VIEW)}}
\DoxyCodeLine{373 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{using }std\_string\_view = std::basic\_string\_view<Char>;}
\DoxyCodeLine{374 \textcolor{preprocessor}{\#elif defined(FMT\_USE\_EXPERIMENTAL\_STRING\_VIEW)}}
\DoxyCodeLine{375 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{376 \textcolor{keyword}{using }std\_string\_view = std::experimental::basic\_string\_view<Char>;}
\DoxyCodeLine{377 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{378 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }std\_string\_view \{\};}
\DoxyCodeLine{379 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381 \textcolor{preprocessor}{\#ifdef FMT\_USE\_INT128}}
\DoxyCodeLine{382 \textcolor{comment}{// Do nothing.}}
\DoxyCodeLine{383 \textcolor{preprocessor}{\#elif defined(\_\_SIZEOF\_INT128\_\_) \&\& !defined(\_\_NVCC\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{384 \textcolor{preprocessor}{    !(FMT\_CLANG\_VERSION \&\& FMT\_MSC\_VERSION)}}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#  define FMT\_USE\_INT128 1}}
\DoxyCodeLine{386 \textcolor{keyword}{using }int128\_opt = \_\_int128\_t;  \textcolor{comment}{// An optional native 128-\/bit integer.}}
\DoxyCodeLine{387 \textcolor{keyword}{using }uint128\_opt = \_\_uint128\_t;}
\DoxyCodeLine{388 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} \textcolor{keyword}{auto} convert\_for\_visit(T value) -\/> T \{}
\DoxyCodeLine{389   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{390 \}}
\DoxyCodeLine{391 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{392 \textcolor{preprocessor}{\#  define FMT\_USE\_INT128 0}}
\DoxyCodeLine{393 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{394 \textcolor{preprocessor}{\#if !FMT\_USE\_INT128}}
\DoxyCodeLine{395 \textcolor{keyword}{enum class} int128\_opt \{\};}
\DoxyCodeLine{396 \textcolor{keyword}{enum class} uint128\_opt \{\};}
\DoxyCodeLine{397 \textcolor{comment}{// Reduce template instantiations.}}
\DoxyCodeLine{398 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} convert\_for\_visit(T) -\/> monostate \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{399 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 \textcolor{comment}{// Casts a nonnegative integer to unsigned.}}
\DoxyCodeLine{402 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int>}
\DoxyCodeLine{403 FMT\_CONSTEXPR \textcolor{keyword}{auto} to\_unsigned(Int value) -\/>}
\DoxyCodeLine{404     \textcolor{keyword}{typename} std::make\_unsigned<Int>::type \{}
\DoxyCodeLine{405   FMT\_ASSERT(value >= 0, \textcolor{stringliteral}{"{}negative value"{}});}
\DoxyCodeLine{406   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}typename std::make\_unsigned<Int>::type\textcolor{keyword}{>}(value);}
\DoxyCodeLine{407 \}}
\DoxyCodeLine{408 }
\DoxyCodeLine{409 FMT\_MSC\_WARNING(suppress : 4566) \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} micro[] = \textcolor{stringliteral}{"{}\(\backslash\)u00B5"{}};}
\DoxyCodeLine{410 }
\DoxyCodeLine{411 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_utf8() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{412   \textcolor{comment}{// Avoid buggy sign extensions in MSVC's constant evaluation mode (\#2297).}}
\DoxyCodeLine{413   \textcolor{keyword}{using }uchar = \textcolor{keywordtype}{unsigned} char;}
\DoxyCodeLine{414   \textcolor{keywordflow}{return} FMT\_UNICODE || (\textcolor{keyword}{sizeof}(micro) == 3 \&\& uchar(micro[0]) == 0xC2 \&\&}
\DoxyCodeLine{415                          uchar(micro[1]) == 0xB5);}
\DoxyCodeLine{416 \}}
\DoxyCodeLine{417 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{418 }
\DoxyCodeLine{426 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} \{}
\DoxyCodeLine{427  \textcolor{keyword}{private}:}
\DoxyCodeLine{428   \textcolor{keyword}{const} Char* data\_;}
\DoxyCodeLine{429   \textcolor{keywordtype}{size\_t} size\_;}
\DoxyCodeLine{430 }
\DoxyCodeLine{431  \textcolor{keyword}{public}:}
\DoxyCodeLine{432   \textcolor{keyword}{using }value\_type = Char;}
\DoxyCodeLine{433   \textcolor{keyword}{using }iterator = \textcolor{keyword}{const} Char*;}
\DoxyCodeLine{434 }
\DoxyCodeLine{435   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}() noexcept : data\_(\textcolor{keyword}{nullptr}), size\_(0) \{\}}
\DoxyCodeLine{436 }
\DoxyCodeLine{438   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__string__view_aae708273ca864680a424c10441799605}{basic\_string\_view}}(\textcolor{keyword}{const} Char* s, \textcolor{keywordtype}{size\_t} count) noexcept}
\DoxyCodeLine{439       : data\_(s), size\_(count) \{\}}
\DoxyCodeLine{440 }
\DoxyCodeLine{447   FMT\_CONSTEXPR\_CHAR\_TRAITS}
\DoxyCodeLine{448   FMT\_INLINE}
\DoxyCodeLine{449   \mbox{\hyperlink{classbasic__string__view_a961254412253f97e1273cdaacb1af1a3}{basic\_string\_view}}(\textcolor{keyword}{const} Char* s)}
\DoxyCodeLine{450       : data\_(s),}
\DoxyCodeLine{451         size\_(detail::const\_check(std::is\_same<Char, char>::value \&\&}
\DoxyCodeLine{452                                   !detail::is\_constant\_evaluated(true))}
\DoxyCodeLine{453                   ? std::strlen(reinterpret\_cast<const char*>(s))}
\DoxyCodeLine{454                   : std::char\_traits<Char>::length(s)) \{\}}
\DoxyCodeLine{455 }
\DoxyCodeLine{457   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Traits, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{458   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view_a05e308de94ccd7f6203ba3ea94f68ebd}{basic\_string\_view}}(}
\DoxyCodeLine{459       \textcolor{keyword}{const} std::basic\_string<Char, Traits, Alloc>\& s) noexcept}
\DoxyCodeLine{460       : data\_(s.data()), size\_(s.size()) \{\}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, FMT\_ENABLE\_IF(std::is\_same<}
\DoxyCodeLine{463                                       S, detail::std\_string\_view<Char>>::value)>}
\DoxyCodeLine{464   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}(S s) noexcept}
\DoxyCodeLine{465       : data\_(s.data()), size\_(s.size()) \{\}}
\DoxyCodeLine{466 }
\DoxyCodeLine{468   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}() const noexcept -\/> const Char* \{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{469 }
\DoxyCodeLine{471   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() const noexcept -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} begin() const noexcept -\/> iterator \{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{474   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} end() const noexcept -\/> iterator \{ \textcolor{keywordflow}{return} data\_ + size\_; \}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator[](\textcolor{keywordtype}{size\_t} pos) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keyword}{const} Char\& \{}
\DoxyCodeLine{477     \textcolor{keywordflow}{return} data\_[pos];}
\DoxyCodeLine{478   \}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480   FMT\_CONSTEXPR \textcolor{keywordtype}{void} remove\_prefix(\textcolor{keywordtype}{size\_t} n) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{481     data\_ += n;}
\DoxyCodeLine{482     size\_ -\/= n;}
\DoxyCodeLine{483   \}}
\DoxyCodeLine{484 }
\DoxyCodeLine{485   \textcolor{comment}{// Lexicographically compare this string reference to other.}}
\DoxyCodeLine{486   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keyword}{auto} compare(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{487     \textcolor{keywordtype}{size\_t} str\_size = size\_ < other.size\_ ? size\_ : other.size\_;}
\DoxyCodeLine{488     \textcolor{keywordtype}{int} result = std::char\_traits<Char>::compare(data\_, other.data\_, str\_size);}
\DoxyCodeLine{489     \textcolor{keywordflow}{if} (result == 0)}
\DoxyCodeLine{490       result = size\_ == other.size\_ ? 0 : (size\_ < other.size\_ ? -\/1 : 1);}
\DoxyCodeLine{491     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{492   \}}
\DoxyCodeLine{493 }
\DoxyCodeLine{494   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator==(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs,}
\DoxyCodeLine{495                                                    \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs)}
\DoxyCodeLine{496       -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{497     \textcolor{keywordflow}{return} lhs.compare(rhs) == 0;}
\DoxyCodeLine{498   \}}
\DoxyCodeLine{499   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator!=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{500     \textcolor{keywordflow}{return} lhs.compare(rhs) != 0;}
\DoxyCodeLine{501   \}}
\DoxyCodeLine{502   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{503     \textcolor{keywordflow}{return} lhs.compare(rhs) < 0;}
\DoxyCodeLine{504   \}}
\DoxyCodeLine{505   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{506     \textcolor{keywordflow}{return} lhs.compare(rhs) <= 0;}
\DoxyCodeLine{507   \}}
\DoxyCodeLine{508   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator>(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{509     \textcolor{keywordflow}{return} lhs.compare(rhs) > 0;}
\DoxyCodeLine{510   \}}
\DoxyCodeLine{511   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator>=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{512     \textcolor{keywordflow}{return} lhs.compare(rhs) >= 0;}
\DoxyCodeLine{513   \}}
\DoxyCodeLine{514 \};}
\DoxyCodeLine{515 }
\DoxyCodeLine{516 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__string__view}{string\_view}} = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char>}};}
\DoxyCodeLine{517 }
\DoxyCodeLine{519 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structis__char}{is\_char}} : std::false\_type \{\};}
\DoxyCodeLine{520 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structis__char}{is\_char}}<char> : std::true\_type \{\};}
\DoxyCodeLine{521 }
\DoxyCodeLine{522 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{523 }
\DoxyCodeLine{524 \textcolor{comment}{// A base class for compile-\/time strings.}}
\DoxyCodeLine{525 \textcolor{keyword}{struct }compile\_string \{\};}
\DoxyCodeLine{526 }
\DoxyCodeLine{527 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{528 \textcolor{keyword}{struct }is\_compile\_string : std::is\_base\_of<compile\_string, S> \{\};}
\DoxyCodeLine{529 }
\DoxyCodeLine{530 \textcolor{comment}{// Returns a string view of `s`.}}
\DoxyCodeLine{531 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{char}<Char>::value)>}
\DoxyCodeLine{532 FMT\_INLINE \textcolor{keyword}{auto} to\_string\_view(\textcolor{keyword}{const} Char* s) -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{533   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{534 \}}
\DoxyCodeLine{535 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Traits, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{536 \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string\_view(\textcolor{keyword}{const} std::basic\_string<Char, Traits, Alloc>\& s)}
\DoxyCodeLine{537     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{538   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{539 \}}
\DoxyCodeLine{540 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{541 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_string\_view(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s)}
\DoxyCodeLine{542     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{543   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{544 \}}
\DoxyCodeLine{545 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char,}
\DoxyCodeLine{546           FMT\_ENABLE\_IF(!std::is\_empty<std\_string\_view<Char>>::value)>}
\DoxyCodeLine{547 \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string\_view(std\_string\_view<Char> s) -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{548   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{549 \}}
\DoxyCodeLine{550 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, FMT\_ENABLE\_IF(is\_compile\_\textcolor{keywordtype}{string}<S>::value)>}
\DoxyCodeLine{551 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_string\_view(\textcolor{keyword}{const} S\& s)}
\DoxyCodeLine{552     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}} \{}
\DoxyCodeLine{553   \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(s);}
\DoxyCodeLine{554 \}}
\DoxyCodeLine{555 \textcolor{keywordtype}{void} to\_string\_view(...);}
\DoxyCodeLine{556 }
\DoxyCodeLine{557 \textcolor{comment}{// Specifies whether S is a string type convertible to fmt::basic\_string\_view.}}
\DoxyCodeLine{558 \textcolor{comment}{// It should be a constexpr function but MSVC 2017 fails to compile it in}}
\DoxyCodeLine{559 \textcolor{comment}{// enable\_if and MSVC 2015 fails to compile it as an alias template.}}
\DoxyCodeLine{560 \textcolor{comment}{// ADL invocation of to\_string\_view is DEPRECATED!}}
\DoxyCodeLine{561 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{562 \textcolor{keyword}{struct }is\_string : std::is\_class<decltype(to\_string\_view(std::declval<S>()))> \{}
\DoxyCodeLine{563 \};}
\DoxyCodeLine{564 }
\DoxyCodeLine{565 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }char\_t\_impl \{\};}
\DoxyCodeLine{566 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S> \textcolor{keyword}{struct }char\_t\_impl<S, enable\_if\_t<is\_string<S>::value>> \{}
\DoxyCodeLine{567   \textcolor{keyword}{using }result = \textcolor{keyword}{decltype}(to\_string\_view(std::declval<S>()));}
\DoxyCodeLine{568   \textcolor{keyword}{using }type = \textcolor{keyword}{typename} result::value\_type;}
\DoxyCodeLine{569 \};}
\DoxyCodeLine{570 }
\DoxyCodeLine{571 \textcolor{keyword}{enum class} type \{}
\DoxyCodeLine{572   none\_type,}
\DoxyCodeLine{573   \textcolor{comment}{// Integer types should go first,}}
\DoxyCodeLine{574   int\_type,}
\DoxyCodeLine{575   uint\_type,}
\DoxyCodeLine{576   long\_long\_type,}
\DoxyCodeLine{577   ulong\_long\_type,}
\DoxyCodeLine{578   int128\_type,}
\DoxyCodeLine{579   uint128\_type,}
\DoxyCodeLine{580   bool\_type,}
\DoxyCodeLine{581   char\_type,}
\DoxyCodeLine{582   last\_integer\_type = char\_type,}
\DoxyCodeLine{583   \textcolor{comment}{// followed by floating-\/point types.}}
\DoxyCodeLine{584   float\_type,}
\DoxyCodeLine{585   double\_type,}
\DoxyCodeLine{586   long\_double\_type,}
\DoxyCodeLine{587   last\_numeric\_type = long\_double\_type,}
\DoxyCodeLine{588   cstring\_type,}
\DoxyCodeLine{589   string\_type,}
\DoxyCodeLine{590   pointer\_type,}
\DoxyCodeLine{591   custom\_type}
\DoxyCodeLine{592 \};}
\DoxyCodeLine{593 }
\DoxyCodeLine{594 \textcolor{comment}{// Maps core type T to the corresponding type enum constant.}}
\DoxyCodeLine{595 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{596 \textcolor{keyword}{struct }type\_constant : std::integral\_constant<type, type::custom\_type> \{\};}
\DoxyCodeLine{597 }
\DoxyCodeLine{598 \textcolor{preprocessor}{\#define FMT\_TYPE\_CONSTANT(Type, constant) \(\backslash\)}}
\DoxyCodeLine{599 \textcolor{preprocessor}{  template <typename Char>                \(\backslash\)}}
\DoxyCodeLine{600 \textcolor{preprocessor}{  struct type\_constant<Type, Char>        \(\backslash\)}}
\DoxyCodeLine{601 \textcolor{preprocessor}{      : std::integral\_constant<type, type::constant> \{\}}}
\DoxyCodeLine{602 }
\DoxyCodeLine{603 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{int}, int\_type);}
\DoxyCodeLine{604 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{unsigned}, uint\_type);}
\DoxyCodeLine{605 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, long\_long\_type);}
\DoxyCodeLine{606 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, ulong\_long\_type);}
\DoxyCodeLine{607 FMT\_TYPE\_CONSTANT(int128\_opt, int128\_type);}
\DoxyCodeLine{608 FMT\_TYPE\_CONSTANT(uint128\_opt, uint128\_type);}
\DoxyCodeLine{609 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{bool}, bool\_type);}
\DoxyCodeLine{610 FMT\_TYPE\_CONSTANT(Char, char\_type);}
\DoxyCodeLine{611 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{float}, float\_type);}
\DoxyCodeLine{612 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{double}, double\_type);}
\DoxyCodeLine{613 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double}, long\_double\_type);}
\DoxyCodeLine{614 FMT\_TYPE\_CONSTANT(\textcolor{keyword}{const} Char*, cstring\_type);}
\DoxyCodeLine{615 FMT\_TYPE\_CONSTANT(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}, string\_type);}
\DoxyCodeLine{616 FMT\_TYPE\_CONSTANT(\textcolor{keyword}{const} \textcolor{keywordtype}{void}*, pointer\_type);}
\DoxyCodeLine{617 }
\DoxyCodeLine{618 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_integral\_type(type t) \{}
\DoxyCodeLine{619   \textcolor{keywordflow}{return} t > type::none\_type \&\& t <= type::last\_integer\_type;}
\DoxyCodeLine{620 \}}
\DoxyCodeLine{621 }
\DoxyCodeLine{622 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_arithmetic\_type(type t) \{}
\DoxyCodeLine{623   \textcolor{keywordflow}{return} t > type::none\_type \&\& t <= type::last\_numeric\_type;}
\DoxyCodeLine{624 \}}
\DoxyCodeLine{625 }
\DoxyCodeLine{626 FMT\_NORETURN FMT\_API \textcolor{keywordtype}{void} throw\_format\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message);}
\DoxyCodeLine{627 }
\DoxyCodeLine{628 \textcolor{keyword}{struct }error\_handler \{}
\DoxyCodeLine{629   \textcolor{keyword}{constexpr} error\_handler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{630   \textcolor{keyword}{constexpr} error\_handler(\textcolor{keyword}{const} error\_handler\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{631 }
\DoxyCodeLine{632   \textcolor{comment}{// This function is intentionally not constexpr to give a compile-\/time error.}}
\DoxyCodeLine{633   FMT\_NORETURN \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{634     throw\_format\_error(message);}
\DoxyCodeLine{635   \}}
\DoxyCodeLine{636 \};}
\DoxyCodeLine{637 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{638 }
\DoxyCodeLine{640 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S> \textcolor{keyword}{using }char\_t = \textcolor{keyword}{typename} detail::char\_t\_impl<S>::type;}
\DoxyCodeLine{641 }
\DoxyCodeLine{649 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler = detail::error\_handler>}
\DoxyCodeLine{650 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}} : \textcolor{keyword}{private} ErrorHandler \{}
\DoxyCodeLine{651  \textcolor{keyword}{private}:}
\DoxyCodeLine{652   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str\_;}
\DoxyCodeLine{653   \textcolor{keywordtype}{int} next\_arg\_id\_;}
\DoxyCodeLine{654 }
\DoxyCodeLine{655   FMT\_CONSTEXPR \textcolor{keywordtype}{void} do\_check\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id});}
\DoxyCodeLine{656 }
\DoxyCodeLine{657  \textcolor{keyword}{public}:}
\DoxyCodeLine{658   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{659   \textcolor{keyword}{using }iterator = \textcolor{keyword}{typename} basic\_string\_view<Char>::iterator;}
\DoxyCodeLine{660 }
\DoxyCodeLine{661   \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}}(}
\DoxyCodeLine{662       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, ErrorHandler eh = \{\},}
\DoxyCodeLine{663       \textcolor{keywordtype}{int} \mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}} = 0)}
\DoxyCodeLine{664       : ErrorHandler(eh), format\_str\_(format\_str), next\_arg\_id\_(\mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}}) \{\}}
\DoxyCodeLine{665 }
\DoxyCodeLine{670   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}() const noexcept -\/> iterator \{}
\DoxyCodeLine{671     \textcolor{keywordflow}{return} format\_str\_.begin();}
\DoxyCodeLine{672   \}}
\DoxyCodeLine{673 }
\DoxyCodeLine{677   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_a624461a9a7da10bd63bb596fb988fc0f}{end}}() const noexcept -\/> iterator \{ \textcolor{keywordflow}{return} format\_str\_.end(); \}}
\DoxyCodeLine{678 }
\DoxyCodeLine{680   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_ac123ab6c1c6e58db3ab0a917def4add8}{advance\_to}}(iterator it) \{}
\DoxyCodeLine{681     format\_str\_.remove\_prefix(detail::to\_unsigned(it -\/ \mbox{\hyperlink{classbasic__format__parse__context_acacc81561f6136973796f6b1ec4bdd5d}{begin}}()));}
\DoxyCodeLine{682   \}}
\DoxyCodeLine{683 }
\DoxyCodeLine{688   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}}() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{689     \textcolor{keywordflow}{if} (next\_arg\_id\_ < 0) \{}
\DoxyCodeLine{690       on\_error(\textcolor{stringliteral}{"{}cannot switch from manual to automatic argument indexing"{}});}
\DoxyCodeLine{691       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{692     \}}
\DoxyCodeLine{693     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = next\_arg\_id\_++;}
\DoxyCodeLine{694     do\_check\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{695     \textcolor{keywordflow}{return} id;}
\DoxyCodeLine{696   \}}
\DoxyCodeLine{697 }
\DoxyCodeLine{702   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{703     \textcolor{keywordflow}{if} (next\_arg\_id\_ > 0) \{}
\DoxyCodeLine{704       on\_error(\textcolor{stringliteral}{"{}cannot switch from automatic to manual argument indexing"{}});}
\DoxyCodeLine{705       \textcolor{keywordflow}{return};}
\DoxyCodeLine{706     \}}
\DoxyCodeLine{707     next\_arg\_id\_ = -\/1;}
\DoxyCodeLine{708     do\_check\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{709   \}}
\DoxyCodeLine{710 }
\DoxyCodeLine{711   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}) \{\}}
\DoxyCodeLine{712 }
\DoxyCodeLine{713   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{714     ErrorHandler::on\_error(message);}
\DoxyCodeLine{715   \}}
\DoxyCodeLine{716 }
\DoxyCodeLine{717   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} error\_handler() const -\/> ErrorHandler \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{718 \};}
\DoxyCodeLine{719 }
\DoxyCodeLine{720 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context}{format\_parse\_context}} = \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<char>}};}
\DoxyCodeLine{721 }
\DoxyCodeLine{722 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{723 \textcolor{comment}{// A parse context with extra data used only in compile-\/time checks.}}
\DoxyCodeLine{724 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler = detail::error\_handler>}
\DoxyCodeLine{725 \textcolor{keyword}{class }compile\_parse\_context}
\DoxyCodeLine{726     : \textcolor{keyword}{public} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}}<Char, ErrorHandler> \{}
\DoxyCodeLine{727  \textcolor{keyword}{private}:}
\DoxyCodeLine{728   \textcolor{keywordtype}{int} num\_args\_;}
\DoxyCodeLine{729   \textcolor{keyword}{const} type* types\_;}
\DoxyCodeLine{730   \textcolor{keyword}{using }base = \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char, ErrorHandler>}};}
\DoxyCodeLine{731 }
\DoxyCodeLine{732  \textcolor{keyword}{public}:}
\DoxyCodeLine{733   \textcolor{keyword}{explicit} FMT\_CONSTEXPR compile\_parse\_context(}
\DoxyCodeLine{734       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, \textcolor{keywordtype}{int} num\_args, \textcolor{keyword}{const} type* types,}
\DoxyCodeLine{735       ErrorHandler eh = \{\}, \textcolor{keywordtype}{int} next\_arg\_id = 0)}
\DoxyCodeLine{736       : base(format\_str, eh, next\_arg\_id), num\_args\_(num\_args), types\_(types) \{\}}
\DoxyCodeLine{737 }
\DoxyCodeLine{738   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} num\_args()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} num\_args\_; \}}
\DoxyCodeLine{739 }
\DoxyCodeLine{740   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{next\_arg\_id}}() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{741     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = \mbox{\hyperlink{classbasic__format__parse__context_a9eb66391da04f3f435cb4664fc9d9170}{base::next\_arg\_id}}();}
\DoxyCodeLine{742     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= num\_args\_) this-\/>on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{743     \textcolor{keywordflow}{return} id;}
\DoxyCodeLine{744   \}}
\DoxyCodeLine{745 }
\DoxyCodeLine{746   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{check\_arg\_id}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{747     \mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{base::check\_arg\_id}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{748     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= num\_args\_) this-\/>on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{749   \}}
\DoxyCodeLine{750   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context_a5dc605ebf44606770789dc6059235130}{base::check\_arg\_id}};}
\DoxyCodeLine{751 \};}
\DoxyCodeLine{752 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{753 }
\DoxyCodeLine{754 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{755 FMT\_CONSTEXPR \textcolor{keywordtype}{void}}
\DoxyCodeLine{756 \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char, ErrorHandler>::do\_check\_arg\_id}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{757   \textcolor{comment}{// Argument id is only checked at compile-\/time during parsing because}}
\DoxyCodeLine{758   \textcolor{comment}{// formatting has its own validation.}}
\DoxyCodeLine{759   \textcolor{keywordflow}{if} (detail::is\_constant\_evaluated() \&\& FMT\_GCC\_VERSION >= 1200) \{}
\DoxyCodeLine{760     \textcolor{keyword}{using }context = detail::compile\_parse\_context<Char, ErrorHandler>;}
\DoxyCodeLine{761     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= \textcolor{keyword}{static\_cast<}context*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>num\_args())}
\DoxyCodeLine{762       on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{763   \}}
\DoxyCodeLine{764 \}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }basic\_format\_arg;}
\DoxyCodeLine{767 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}};}
\DoxyCodeLine{768 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classdynamic__format__arg__store}{dynamic\_format\_arg\_store}};}
\DoxyCodeLine{769 }
\DoxyCodeLine{770 \textcolor{comment}{// A formatter for objects of type T.}}
\DoxyCodeLine{771 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{772 \textcolor{keyword}{struct }formatter \{}
\DoxyCodeLine{773   \textcolor{comment}{// A deleted default constructor indicates a disabled formatter.}}
\DoxyCodeLine{774   formatter() = \textcolor{keyword}{delete};}
\DoxyCodeLine{775 \};}
\DoxyCodeLine{776 }
\DoxyCodeLine{777 \textcolor{comment}{// Specifies if T has an enabled formatter specialization. A type can be}}
\DoxyCodeLine{778 \textcolor{comment}{// formattable even if it doesn't have a formatter e.g. via a conversion.}}
\DoxyCodeLine{779 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{780 \textcolor{keyword}{using }has\_formatter =}
\DoxyCodeLine{781     std::is\_constructible<typename Context::template formatter\_type<T>>;}
\DoxyCodeLine{782 }
\DoxyCodeLine{783 \textcolor{comment}{// Checks whether T is a container with contiguous storage.}}
\DoxyCodeLine{784 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_contiguous : std::false\_type \{\};}
\DoxyCodeLine{785 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{786 \textcolor{keyword}{struct }is\_contiguous<std::basic\_string<Char>> : std::true\_type \{\};}
\DoxyCodeLine{787 }
\DoxyCodeLine{788 \textcolor{keyword}{class }appender;}
\DoxyCodeLine{789 }
\DoxyCodeLine{790 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{791 }
\DoxyCodeLine{792 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{793 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} has\_const\_formatter\_impl(T*)}
\DoxyCodeLine{794     -\/> \textcolor{keyword}{decltype}(\textcolor{keyword}{typename} Context::template formatter\_type<T>().format(}
\DoxyCodeLine{795                     std::declval<const T\&>(), std::declval<Context\&>()),}
\DoxyCodeLine{796                 \textcolor{keyword}{true}) \{}
\DoxyCodeLine{797   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{798 \}}
\DoxyCodeLine{799 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{800 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} has\_const\_formatter\_impl(...) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{801   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{802 \}}
\DoxyCodeLine{803 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{804 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} has\_const\_formatter() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{805   \textcolor{keywordflow}{return} has\_const\_formatter\_impl<Context>(\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{806 \}}
\DoxyCodeLine{807 }
\DoxyCodeLine{808 \textcolor{comment}{// Extracts a reference to the container from back\_insert\_iterator.}}
\DoxyCodeLine{809 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{810 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_container(std::back\_insert\_iterator<Container> it)}
\DoxyCodeLine{811     -\/> Container\& \{}
\DoxyCodeLine{812   \textcolor{keyword}{using }base = std::back\_insert\_iterator<Container>;}
\DoxyCodeLine{813   \textcolor{keyword}{struct }accessor : base \{}
\DoxyCodeLine{814     accessor(base b) : base(b) \{\}}
\DoxyCodeLine{815     \textcolor{keyword}{using }base::container;}
\DoxyCodeLine{816   \};}
\DoxyCodeLine{817   \textcolor{keywordflow}{return} *accessor(it).container;}
\DoxyCodeLine{818 \}}
\DoxyCodeLine{819 }
\DoxyCodeLine{820 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{821 FMT\_CONSTEXPR \textcolor{keyword}{auto} copy\_str(InputIt begin, InputIt end, OutputIt out)}
\DoxyCodeLine{822     -\/> OutputIt \{}
\DoxyCodeLine{823   \textcolor{keywordflow}{while} (begin != end) *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(*begin++);}
\DoxyCodeLine{824   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{825 \}}
\DoxyCodeLine{826 }
\DoxyCodeLine{827 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U,}
\DoxyCodeLine{828           FMT\_ENABLE\_IF(}
\DoxyCodeLine{829               std::is\_same<remove\_const\_t<T>, U>::value\&\& \mbox{\hyperlink{structis__char}{is\_char<U>::value}})>}
\DoxyCodeLine{830 FMT\_CONSTEXPR \textcolor{keyword}{auto} copy\_str(T* begin, T* end, U* out) -\/> U* \{}
\DoxyCodeLine{831   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordflow}{return} copy\_str<Char, T*, U*>(begin, end, out);}
\DoxyCodeLine{832   \textcolor{keyword}{auto} size = to\_unsigned(end -\/ begin);}
\DoxyCodeLine{833   memcpy(out, begin, size * \textcolor{keyword}{sizeof}(U));}
\DoxyCodeLine{834   \textcolor{keywordflow}{return} out + size;}
\DoxyCodeLine{835 \}}
\DoxyCodeLine{836 }
\DoxyCodeLine{843 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{classbuffer}{buffer}} \{}
\DoxyCodeLine{844  \textcolor{keyword}{private}:}
\DoxyCodeLine{845   T* ptr\_;}
\DoxyCodeLine{846   \textcolor{keywordtype}{size\_t} size\_;}
\DoxyCodeLine{847   \textcolor{keywordtype}{size\_t} capacity\_;}
\DoxyCodeLine{848 }
\DoxyCodeLine{849  \textcolor{keyword}{protected}:}
\DoxyCodeLine{850   \textcolor{comment}{// Don't initialize ptr\_ since it is not accessed to save a few cycles.}}
\DoxyCodeLine{851   FMT\_MSC\_WARNING(suppress : 26495)}
\DoxyCodeLine{852   \mbox{\hyperlink{classbuffer}{buffer}}(\textcolor{keywordtype}{size\_t} sz) noexcept : size\_(sz), capacity\_(sz) \{\}}
\DoxyCodeLine{853 }
\DoxyCodeLine{854   FMT\_CONSTEXPR20 \mbox{\hyperlink{classbuffer}{buffer}}(T* p = \textcolor{keyword}{nullptr}, \textcolor{keywordtype}{size\_t} sz = 0, \textcolor{keywordtype}{size\_t} cap = 0) noexcept}
\DoxyCodeLine{855       : ptr\_(p), size\_(sz), capacity\_(cap) \{\}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857   FMT\_CONSTEXPR20 \mbox{\hyperlink{classbuffer}{\string~buffer}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{858   \mbox{\hyperlink{classbuffer}{buffer}}(\mbox{\hyperlink{classbuffer}{buffer}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{859 }
\DoxyCodeLine{861   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbuffer_ad6a278000af66f748420780f341c138a}{set}}(T* buf\_data, \textcolor{keywordtype}{size\_t} buf\_capacity) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{862     ptr\_ = buf\_data;}
\DoxyCodeLine{863     capacity\_ = buf\_capacity;}
\DoxyCodeLine{864   \}}
\DoxyCodeLine{865 }
\DoxyCodeLine{867   \textcolor{keyword}{virtual} FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbuffer_a98dcf71107dcb329422606c9ff0b3369}{grow}}(\textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classbuffer_a025ed14a3e24705aaacf82f013b7d5c4}{capacity}}) = 0;}
\DoxyCodeLine{868 }
\DoxyCodeLine{869  \textcolor{keyword}{public}:}
\DoxyCodeLine{870   \textcolor{keyword}{using }value\_type = T;}
\DoxyCodeLine{871   \textcolor{keyword}{using }const\_reference = \textcolor{keyword}{const} T\&;}
\DoxyCodeLine{872 }
\DoxyCodeLine{873   \mbox{\hyperlink{classbuffer}{buffer}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbuffer}{buffer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{874   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classbuffer}{buffer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{875 }
\DoxyCodeLine{876   \textcolor{keyword}{auto} begin() noexcept -\/> T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{877   \textcolor{keyword}{auto} end() noexcept -\/> T* \{ \textcolor{keywordflow}{return} ptr\_ + size\_; \}}
\DoxyCodeLine{878 }
\DoxyCodeLine{879   \textcolor{keyword}{auto} begin() const noexcept -\/> const T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{880   \textcolor{keyword}{auto} end() const noexcept -\/> const T* \{ \textcolor{keywordflow}{return} ptr\_ + size\_; \}}
\DoxyCodeLine{881 }
\DoxyCodeLine{883   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}() const noexcept -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{884 }
\DoxyCodeLine{886   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer_a025ed14a3e24705aaacf82f013b7d5c4}{capacity}}() const noexcept -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} capacity\_; \}}
\DoxyCodeLine{887 }
\DoxyCodeLine{889   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}() noexcept -\/> T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{890 }
\DoxyCodeLine{892   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer_ad1cb22bbae86d71c27cd8c5fe11346f9}{data}}() const noexcept -\/> const T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{893 }
\DoxyCodeLine{895   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbuffer_a46672f0d8544fc2b27544928cd6408df}{clear}}() \{ size\_ = 0; \}}
\DoxyCodeLine{896 }
\DoxyCodeLine{897   \textcolor{comment}{// Tries resizing the buffer to contain *count* elements. If T is a POD type}}
\DoxyCodeLine{898   \textcolor{comment}{// the new elements may not be initialized.}}
\DoxyCodeLine{899   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} try\_resize(\textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{900     try\_reserve(count);}
\DoxyCodeLine{901     size\_ = count <= capacity\_ ? count : capacity\_;}
\DoxyCodeLine{902   \}}
\DoxyCodeLine{903 }
\DoxyCodeLine{904   \textcolor{comment}{// Tries increasing the buffer capacity to *new\_capacity*. It can increase the}}
\DoxyCodeLine{905   \textcolor{comment}{// capacity by a smaller amount than requested but guarantees there is space}}
\DoxyCodeLine{906   \textcolor{comment}{// for at least one additional element either by increasing the capacity or by}}
\DoxyCodeLine{907   \textcolor{comment}{// flushing the buffer if it is full.}}
\DoxyCodeLine{908   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} try\_reserve(\textcolor{keywordtype}{size\_t} new\_capacity) \{}
\DoxyCodeLine{909     \textcolor{keywordflow}{if} (new\_capacity > capacity\_) \mbox{\hyperlink{classbuffer_a98dcf71107dcb329422606c9ff0b3369}{grow}}(new\_capacity);}
\DoxyCodeLine{910   \}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} T\& value) \{}
\DoxyCodeLine{913     try\_reserve(size\_ + 1);}
\DoxyCodeLine{914     ptr\_[size\_++] = value;}
\DoxyCodeLine{915   \}}
\DoxyCodeLine{916 }
\DoxyCodeLine{918   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U> \textcolor{keywordtype}{void} \mbox{\hyperlink{classbuffer_a144ad707b324a714fbe334896f90ba28}{append}}(\textcolor{keyword}{const} U* begin, \textcolor{keyword}{const} U* end);}
\DoxyCodeLine{919 }
\DoxyCodeLine{920   \textcolor{keyword}{template} <\textcolor{keyword}{typename} I> FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](I index) -\/> T\& \{}
\DoxyCodeLine{921     \textcolor{keywordflow}{return} ptr\_[index];}
\DoxyCodeLine{922   \}}
\DoxyCodeLine{923   \textcolor{keyword}{template} <\textcolor{keyword}{typename} I>}
\DoxyCodeLine{924   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](I index) \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} T\& \{}
\DoxyCodeLine{925     \textcolor{keywordflow}{return} ptr\_[index];}
\DoxyCodeLine{926   \}}
\DoxyCodeLine{927 \};}
\DoxyCodeLine{928 }
\DoxyCodeLine{929 \textcolor{keyword}{struct }buffer\_traits \{}
\DoxyCodeLine{930   \textcolor{keyword}{explicit} buffer\_traits(\textcolor{keywordtype}{size\_t}) \{\}}
\DoxyCodeLine{931   \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{932   \textcolor{keyword}{auto} limit(\textcolor{keywordtype}{size\_t} size) -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size; \}}
\DoxyCodeLine{933 \};}
\DoxyCodeLine{934 }
\DoxyCodeLine{935 \textcolor{keyword}{class }fixed\_buffer\_traits \{}
\DoxyCodeLine{936  \textcolor{keyword}{private}:}
\DoxyCodeLine{937   \textcolor{keywordtype}{size\_t} count\_ = 0;}
\DoxyCodeLine{938   \textcolor{keywordtype}{size\_t} limit\_;}
\DoxyCodeLine{939 }
\DoxyCodeLine{940  \textcolor{keyword}{public}:}
\DoxyCodeLine{941   \textcolor{keyword}{explicit} fixed\_buffer\_traits(\textcolor{keywordtype}{size\_t} limit) : limit\_(limit) \{\}}
\DoxyCodeLine{942   \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{943   \textcolor{keyword}{auto} limit(\textcolor{keywordtype}{size\_t} size) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{944     \textcolor{keywordtype}{size\_t} n = limit\_ > count\_ ? limit\_ -\/ count\_ : 0;}
\DoxyCodeLine{945     count\_ += size;}
\DoxyCodeLine{946     \textcolor{keywordflow}{return} size < n ? size : n;}
\DoxyCodeLine{947   \}}
\DoxyCodeLine{948 \};}
\DoxyCodeLine{949 }
\DoxyCodeLine{950 \textcolor{comment}{// A buffer that writes to an output iterator when flushed.}}
\DoxyCodeLine{951 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Traits = buffer\_traits>}
\DoxyCodeLine{952 \textcolor{keyword}{class }iterator\_buffer final : \textcolor{keyword}{public} Traits, \textcolor{keyword}{public} \mbox{\hyperlink{classbuffer}{buffer}}<T> \{}
\DoxyCodeLine{953  \textcolor{keyword}{private}:}
\DoxyCodeLine{954   OutputIt out\_;}
\DoxyCodeLine{955   \textcolor{keyword}{enum} \{ buffer\_size = 256 \};}
\DoxyCodeLine{956   T data\_[buffer\_size];}
\DoxyCodeLine{957 }
\DoxyCodeLine{958  \textcolor{keyword}{protected}:}
\DoxyCodeLine{959   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbuffer_a98dcf71107dcb329422606c9ff0b3369}{grow}}(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{960     \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}() == buffer\_size) flush();}
\DoxyCodeLine{961   \}}
\DoxyCodeLine{962 }
\DoxyCodeLine{963   \textcolor{keywordtype}{void} flush() \{}
\DoxyCodeLine{964     \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}} = this-\/>\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{965     this-\/>\mbox{\hyperlink{classbuffer_a46672f0d8544fc2b27544928cd6408df}{clear}}();}
\DoxyCodeLine{966     out\_ = copy\_str<T>(data\_, data\_ + this-\/>limit(size), out\_);}
\DoxyCodeLine{967   \}}
\DoxyCodeLine{968 }
\DoxyCodeLine{969  \textcolor{keyword}{public}:}
\DoxyCodeLine{970   \textcolor{keyword}{explicit} iterator\_buffer(OutputIt out, \textcolor{keywordtype}{size\_t} n = buffer\_size)}
\DoxyCodeLine{971       : Traits(n), \mbox{\hyperlink{classbuffer}{buffer}}<T>(data\_, 0, buffer\_size), out\_(out) \{\}}
\DoxyCodeLine{972   iterator\_buffer(iterator\_buffer\&\& other)}
\DoxyCodeLine{973       : Traits(other), \mbox{\hyperlink{classbuffer}{buffer}}<T>(data\_, 0, buffer\_size), out\_(other.out\_) \{\}}
\DoxyCodeLine{974   \string~iterator\_buffer() \{ flush(); \}}
\DoxyCodeLine{975 }
\DoxyCodeLine{976   \textcolor{keyword}{auto} out() -\/> OutputIt \{}
\DoxyCodeLine{977     flush();}
\DoxyCodeLine{978     \textcolor{keywordflow}{return} out\_;}
\DoxyCodeLine{979   \}}
\DoxyCodeLine{980   \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} Traits::count() + this-\/>\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}(); \}}
\DoxyCodeLine{981 \};}
\DoxyCodeLine{982 }
\DoxyCodeLine{983 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{984 \textcolor{keyword}{class }iterator\_buffer<T*, T, fixed\_buffer\_traits> final}
\DoxyCodeLine{985     : \textcolor{keyword}{public} fixed\_buffer\_traits,}
\DoxyCodeLine{986       \textcolor{keyword}{public} \mbox{\hyperlink{classbuffer}{buffer<T>}} \{}
\DoxyCodeLine{987  \textcolor{keyword}{private}:}
\DoxyCodeLine{988   T* out\_;}
\DoxyCodeLine{989   \textcolor{keyword}{enum} \{ buffer\_size = 256 \};}
\DoxyCodeLine{990   T data\_[buffer\_size];}
\DoxyCodeLine{991 }
\DoxyCodeLine{992  \textcolor{keyword}{protected}:}
\DoxyCodeLine{993   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} grow(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{994     \textcolor{keywordflow}{if} (this-\/>size() == this-\/>capacity()) flush();}
\DoxyCodeLine{995   \}}
\DoxyCodeLine{996 }
\DoxyCodeLine{997   \textcolor{keywordtype}{void} flush() \{}
\DoxyCodeLine{998     \textcolor{keywordtype}{size\_t} n = this-\/>limit(this-\/>size());}
\DoxyCodeLine{999     \textcolor{keywordflow}{if} (this-\/>data() == out\_) \{}
\DoxyCodeLine{1000       out\_ += n;}
\DoxyCodeLine{1001       this-\/>set(data\_, buffer\_size);}
\DoxyCodeLine{1002     \}}
\DoxyCodeLine{1003     this-\/>clear();}
\DoxyCodeLine{1004   \}}
\DoxyCodeLine{1005 }
\DoxyCodeLine{1006  \textcolor{keyword}{public}:}
\DoxyCodeLine{1007   \textcolor{keyword}{explicit} iterator\_buffer(T* out, \textcolor{keywordtype}{size\_t} n = buffer\_size)}
\DoxyCodeLine{1008       : fixed\_buffer\_traits(n), \mbox{\hyperlink{classbuffer}{buffer}}<T>(out, 0, n), out\_(out) \{\}}
\DoxyCodeLine{1009   iterator\_buffer(iterator\_buffer\&\& other)}
\DoxyCodeLine{1010       : fixed\_buffer\_traits(other),}
\DoxyCodeLine{1011         \mbox{\hyperlink{classbuffer}{buffer}}<T>(std::move(other)),}
\DoxyCodeLine{1012         out\_(other.out\_) \{}
\DoxyCodeLine{1013     \textcolor{keywordflow}{if} (this-\/>data() != out\_) \{}
\DoxyCodeLine{1014       this-\/>set(data\_, buffer\_size);}
\DoxyCodeLine{1015       this-\/>clear();}
\DoxyCodeLine{1016     \}}
\DoxyCodeLine{1017   \}}
\DoxyCodeLine{1018   \string~iterator\_buffer() \{ flush(); \}}
\DoxyCodeLine{1019 }
\DoxyCodeLine{1020   \textcolor{keyword}{auto} out() -\/> T* \{}
\DoxyCodeLine{1021     flush();}
\DoxyCodeLine{1022     \textcolor{keywordflow}{return} out\_;}
\DoxyCodeLine{1023   \}}
\DoxyCodeLine{1024   \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1025     \textcolor{keywordflow}{return} fixed\_buffer\_traits::count() + this-\/>size();}
\DoxyCodeLine{1026   \}}
\DoxyCodeLine{1027 \};}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }iterator\_buffer<T*, T> final : \textcolor{keyword}{public} \mbox{\hyperlink{classbuffer}{buffer<T>}} \{}
\DoxyCodeLine{1030  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1031   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} grow(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{1032 }
\DoxyCodeLine{1033  \textcolor{keyword}{public}:}
\DoxyCodeLine{1034   \textcolor{keyword}{explicit} iterator\_buffer(T* out, \textcolor{keywordtype}{size\_t} = 0) : \mbox{\hyperlink{classbuffer}{buffer}}<T>(out, 0, \string~size\_t()) \{\}}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036   \textcolor{keyword}{auto} out() -\/> T* \{ \textcolor{keywordflow}{return} \&*this-\/>end(); \}}
\DoxyCodeLine{1037 \};}
\DoxyCodeLine{1038 }
\DoxyCodeLine{1039 \textcolor{comment}{// A buffer that writes to a container with the contiguous storage.}}
\DoxyCodeLine{1040 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1041 \textcolor{keyword}{class }iterator\_buffer<std::back\_insert\_iterator<Container>,}
\DoxyCodeLine{1042                       enable\_if\_t<is\_contiguous<Container>::value,}
\DoxyCodeLine{1043                                   typename Container::value\_type>>}
\DoxyCodeLine{1044     final : \textcolor{keyword}{public} \mbox{\hyperlink{classbuffer}{buffer}}<typename Container::value\_type> \{}
\DoxyCodeLine{1045  \textcolor{keyword}{private}:}
\DoxyCodeLine{1046   Container\& container\_;}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1048  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1049   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} grow(\textcolor{keywordtype}{size\_t} capacity)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{1050     container\_.resize(capacity);}
\DoxyCodeLine{1051     this-\/>\mbox{\hyperlink{classbuffer_ad6a278000af66f748420780f341c138a}{set}}(\&container\_[0], capacity);}
\DoxyCodeLine{1052   \}}
\DoxyCodeLine{1053 }
\DoxyCodeLine{1054  \textcolor{keyword}{public}:}
\DoxyCodeLine{1055   \textcolor{keyword}{explicit} iterator\_buffer(Container\& c)}
\DoxyCodeLine{1056       : \mbox{\hyperlink{classbuffer}{buffer}}<typename Container::value\_type>(c.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()), container\_(c) \{\}}
\DoxyCodeLine{1057   \textcolor{keyword}{explicit} iterator\_buffer(std::back\_insert\_iterator<Container> out, \textcolor{keywordtype}{size\_t} = 0)}
\DoxyCodeLine{1058       : iterator\_buffer(get\_container(out)) \{\}}
\DoxyCodeLine{1059 }
\DoxyCodeLine{1060   \textcolor{keyword}{auto} out() -\/> std::back\_insert\_iterator<Container> \{}
\DoxyCodeLine{1061     \textcolor{keywordflow}{return} std::back\_inserter(container\_);}
\DoxyCodeLine{1062   \}}
\DoxyCodeLine{1063 \};}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065 \textcolor{comment}{// A buffer that counts the number of code units written discarding the output.}}
\DoxyCodeLine{1066 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{char}> \textcolor{keyword}{class }counting\_buffer final : \textcolor{keyword}{public} \mbox{\hyperlink{classbuffer}{buffer}}<T> \{}
\DoxyCodeLine{1067  \textcolor{keyword}{private}:}
\DoxyCodeLine{1068   \textcolor{keyword}{enum} \{ buffer\_size = 256 \};}
\DoxyCodeLine{1069   T data\_[buffer\_size];}
\DoxyCodeLine{1070   \textcolor{keywordtype}{size\_t} count\_ = 0;}
\DoxyCodeLine{1071 }
\DoxyCodeLine{1072  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1073   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbuffer_a98dcf71107dcb329422606c9ff0b3369}{grow}}(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{1074     \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}() != buffer\_size) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1075     count\_ += this-\/>\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{1076     this-\/>\mbox{\hyperlink{classbuffer_a46672f0d8544fc2b27544928cd6408df}{clear}}();}
\DoxyCodeLine{1077   \}}
\DoxyCodeLine{1078 }
\DoxyCodeLine{1079  \textcolor{keyword}{public}:}
\DoxyCodeLine{1080   counting\_buffer() : \mbox{\hyperlink{classbuffer}{buffer}}<T>(data\_, 0, buffer\_size) \{\}}
\DoxyCodeLine{1081 }
\DoxyCodeLine{1082   \textcolor{keyword}{auto} count() -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} count\_ + this-\/>\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}(); \}}
\DoxyCodeLine{1083 \};}
\DoxyCodeLine{1084 }
\DoxyCodeLine{1085 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1086 \textcolor{keyword}{using }buffer\_appender = conditional\_t<std::is\_same<T, char>::value, appender,}
\DoxyCodeLine{1087                                       std::back\_insert\_iterator<buffer<T>>>;}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089 \textcolor{comment}{// Maps an output iterator to a buffer.}}
\DoxyCodeLine{1090 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1091 \textcolor{keyword}{auto} get\_buffer(OutputIt out) -\/> iterator\_buffer<OutputIt, T> \{}
\DoxyCodeLine{1092   \textcolor{keywordflow}{return} iterator\_buffer<OutputIt, T>(out);}
\DoxyCodeLine{1093 \}}
\DoxyCodeLine{1094 }
\DoxyCodeLine{1095 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Buffer>}
\DoxyCodeLine{1096 \textcolor{keyword}{auto} get\_iterator(Buffer\& buf) -\/> \textcolor{keyword}{decltype}(buf.out()) \{}
\DoxyCodeLine{1097   \textcolor{keywordflow}{return} buf.out();}
\DoxyCodeLine{1098 \}}
\DoxyCodeLine{1099 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} get\_iterator(\mbox{\hyperlink{classbuffer}{buffer<T>}}\& buf) -\/> buffer\_appender<T> \{}
\DoxyCodeLine{1100   \textcolor{keywordflow}{return} buffer\_appender<T>(buf);}
\DoxyCodeLine{1101 \}}
\DoxyCodeLine{1102 }
\DoxyCodeLine{1103 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1104 \textcolor{keyword}{struct }fallback\_formatter \{}
\DoxyCodeLine{1105   fallback\_formatter() = \textcolor{keyword}{delete};}
\DoxyCodeLine{1106 \};}
\DoxyCodeLine{1107 }
\DoxyCodeLine{1108 \textcolor{comment}{// Specifies if T has an enabled fallback\_formatter specialization.}}
\DoxyCodeLine{1109 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1110 \textcolor{keyword}{using }has\_fallback\_formatter =}
\DoxyCodeLine{1111 \textcolor{preprocessor}{\#ifdef FMT\_DEPRECATED\_OSTREAM}}
\DoxyCodeLine{1112     std::is\_constructible<fallback\_formatter<T, Char>>;}
\DoxyCodeLine{1113 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1114     std::false\_type;}
\DoxyCodeLine{1115 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1116 }
\DoxyCodeLine{1117 \textcolor{keyword}{struct }view \{\};}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T> \textcolor{keyword}{struct }named\_arg : view \{}
\DoxyCodeLine{1120   \textcolor{keyword}{const} Char* name;}
\DoxyCodeLine{1121   \textcolor{keyword}{const} T\& value;}
\DoxyCodeLine{1122   named\_arg(\textcolor{keyword}{const} Char* n, \textcolor{keyword}{const} T\& v) : name(n), value(v) \{\}}
\DoxyCodeLine{1123 \};}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }named\_arg\_info \{}
\DoxyCodeLine{1126   \textcolor{keyword}{const} Char* name;}
\DoxyCodeLine{1127   \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{1128 \};}
\DoxyCodeLine{1129 }
\DoxyCodeLine{1130 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} NUM\_ARGS, \textcolor{keywordtype}{size\_t} NUM\_NAMED\_ARGS>}
\DoxyCodeLine{1131 \textcolor{keyword}{struct }arg\_data \{}
\DoxyCodeLine{1132   \textcolor{comment}{// args\_[0].named\_args points to named\_args\_ to avoid bloating format\_args.}}
\DoxyCodeLine{1133   \textcolor{comment}{// +1 to workaround a bug in gcc 7.5 that causes duplicated-\/branches warning.}}
\DoxyCodeLine{1134   T args\_[1 + (NUM\_ARGS != 0 ? NUM\_ARGS : +1)];}
\DoxyCodeLine{1135   named\_arg\_info<Char> named\_args\_[NUM\_NAMED\_ARGS];}
\DoxyCodeLine{1136 }
\DoxyCodeLine{1137   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... U>}
\DoxyCodeLine{1138   arg\_data(\textcolor{keyword}{const} U\&... init) : args\_\{T(named\_args\_, NUM\_NAMED\_ARGS), init...\} \{\}}
\DoxyCodeLine{1139   arg\_data(\textcolor{keyword}{const} arg\_data\& other) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1140   \textcolor{keyword}{auto} args() const -\/> const T* \{ \textcolor{keywordflow}{return} args\_ + 1; \}}
\DoxyCodeLine{1141   \textcolor{keyword}{auto} named\_args() -\/> named\_arg\_info<Char>* \{ \textcolor{keywordflow}{return} named\_args\_; \}}
\DoxyCodeLine{1142 \};}
\DoxyCodeLine{1143 }
\DoxyCodeLine{1144 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} NUM\_ARGS>}
\DoxyCodeLine{1145 \textcolor{keyword}{struct }arg\_data<T, Char, NUM\_ARGS, 0> \{}
\DoxyCodeLine{1146   \textcolor{comment}{// +1 to workaround a bug in gcc 7.5 that causes duplicated-\/branches warning.}}
\DoxyCodeLine{1147   T args\_[NUM\_ARGS != 0 ? NUM\_ARGS : +1];}
\DoxyCodeLine{1148 }
\DoxyCodeLine{1149   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... U>}
\DoxyCodeLine{1150   FMT\_CONSTEXPR FMT\_INLINE arg\_data(\textcolor{keyword}{const} U\&... init) : args\_\{init...\} \{\}}
\DoxyCodeLine{1151   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} args() const -\/> const T* \{ \textcolor{keywordflow}{return} args\_; \}}
\DoxyCodeLine{1152   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} named\_args() -\/> std::nullptr\_t \{}
\DoxyCodeLine{1153     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1154   \}}
\DoxyCodeLine{1155 \};}
\DoxyCodeLine{1156 }
\DoxyCodeLine{1157 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1158 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} init\_named\_args(named\_arg\_info<Char>*, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int}) \{\}}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_named\_arg : std::false\_type \{\};}
\DoxyCodeLine{1161 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_statically\_named\_arg : std::false\_type \{\};}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1164 \textcolor{keyword}{struct }is\_named\_arg<named\_arg<Char, T>> : std::true\_type \{\};}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Tail,}
\DoxyCodeLine{1167           FMT\_ENABLE\_IF(!is\_named\_arg<T>::value)>}
\DoxyCodeLine{1168 \textcolor{keywordtype}{void} init\_named\_args(named\_arg\_info<Char>* named\_args, \textcolor{keywordtype}{int} arg\_count,}
\DoxyCodeLine{1169                      \textcolor{keywordtype}{int} named\_arg\_count, \textcolor{keyword}{const} T\&, \textcolor{keyword}{const} Tail\&... args) \{}
\DoxyCodeLine{1170   init\_named\_args(named\_args, arg\_count + 1, named\_arg\_count, args...);}
\DoxyCodeLine{1171 \}}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Tail,}
\DoxyCodeLine{1174           FMT\_ENABLE\_IF(is\_named\_arg<T>::value)>}
\DoxyCodeLine{1175 \textcolor{keywordtype}{void} init\_named\_args(named\_arg\_info<Char>* named\_args, \textcolor{keywordtype}{int} arg\_count,}
\DoxyCodeLine{1176                      \textcolor{keywordtype}{int} named\_arg\_count, \textcolor{keyword}{const} T\& arg, \textcolor{keyword}{const} Tail\&... args) \{}
\DoxyCodeLine{1177   named\_args[named\_arg\_count++] = \{arg.name, arg\_count\};}
\DoxyCodeLine{1178   init\_named\_args(named\_args, arg\_count + 1, named\_arg\_count, args...);}
\DoxyCodeLine{1179 \}}
\DoxyCodeLine{1180 }
\DoxyCodeLine{1181 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1182 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keywordtype}{void} init\_named\_args(std::nullptr\_t, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int},}
\DoxyCodeLine{1183                                               \textcolor{keyword}{const} Args\&...) \{\}}
\DoxyCodeLine{1184 }
\DoxyCodeLine{1185 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B = false> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count() -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} B ? 1 : 0; \}}
\DoxyCodeLine{1186 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B1, \textcolor{keywordtype}{bool} B2, \textcolor{keywordtype}{bool}... Tail> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count() -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1187   \textcolor{keywordflow}{return} (B1 ? 1 : 0) + count<B2, Tail...>();}
\DoxyCodeLine{1188 \}}
\DoxyCodeLine{1189 }
\DoxyCodeLine{1190 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count\_named\_args() -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1191   \textcolor{keywordflow}{return} count<is\_named\_arg<Args>::value...>();}
\DoxyCodeLine{1192 \}}
\DoxyCodeLine{1193 }
\DoxyCodeLine{1194 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1195 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count\_statically\_named\_args() -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1196   \textcolor{keywordflow}{return} count<is\_statically\_named\_arg<Args>::value...>();}
\DoxyCodeLine{1197 \}}
\DoxyCodeLine{1198 }
\DoxyCodeLine{1199 \textcolor{keyword}{struct }unformattable \{\};}
\DoxyCodeLine{1200 \textcolor{keyword}{struct }unformattable\_char : unformattable \{\};}
\DoxyCodeLine{1201 \textcolor{keyword}{struct }unformattable\_const : unformattable \{\};}
\DoxyCodeLine{1202 \textcolor{keyword}{struct }unformattable\_pointer : unformattable \{\};}
\DoxyCodeLine{1203 }
\DoxyCodeLine{1204 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }string\_value \{}
\DoxyCodeLine{1205   \textcolor{keyword}{const} Char* data;}
\DoxyCodeLine{1206   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{1207 \};}
\DoxyCodeLine{1208 }
\DoxyCodeLine{1209 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }named\_arg\_value \{}
\DoxyCodeLine{1210   \textcolor{keyword}{const} named\_arg\_info<Char>* data;}
\DoxyCodeLine{1211   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{1212 \};}
\DoxyCodeLine{1213 }
\DoxyCodeLine{1214 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{struct }custom\_value \{}
\DoxyCodeLine{1215   \textcolor{keyword}{using }parse\_context = \textcolor{keyword}{typename} Context::parse\_context\_type;}
\DoxyCodeLine{1216   \textcolor{keywordtype}{void}* value;}
\DoxyCodeLine{1217   void (*format)(\textcolor{keywordtype}{void}* arg, parse\_context\& parse\_ctx, Context\& ctx);}
\DoxyCodeLine{1218 \};}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{comment}{// A formatting argument value.}}
\DoxyCodeLine{1221 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }value \{}
\DoxyCodeLine{1222  \textcolor{keyword}{public}:}
\DoxyCodeLine{1223   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{1224 }
\DoxyCodeLine{1225   \textcolor{keyword}{union }\{}
\DoxyCodeLine{1226     monostate no\_value;}
\DoxyCodeLine{1227     \textcolor{keywordtype}{int} int\_value;}
\DoxyCodeLine{1228     \textcolor{keywordtype}{unsigned} uint\_value;}
\DoxyCodeLine{1229     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} long\_long\_value;}
\DoxyCodeLine{1230     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ulong\_long\_value;}
\DoxyCodeLine{1231     int128\_opt int128\_value;}
\DoxyCodeLine{1232     uint128\_opt uint128\_value;}
\DoxyCodeLine{1233     \textcolor{keywordtype}{bool} bool\_value;}
\DoxyCodeLine{1234     char\_type char\_value;}
\DoxyCodeLine{1235     \textcolor{keywordtype}{float} float\_value;}
\DoxyCodeLine{1236     \textcolor{keywordtype}{double} double\_value;}
\DoxyCodeLine{1237     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} long\_double\_value;}
\DoxyCodeLine{1238     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pointer;}
\DoxyCodeLine{1239     string\_value<char\_type> string;}
\DoxyCodeLine{1240     custom\_value<Context> custom;}
\DoxyCodeLine{1241     named\_arg\_value<char\_type> named\_args;}
\DoxyCodeLine{1242   \};}
\DoxyCodeLine{1243 }
\DoxyCodeLine{1244   \textcolor{keyword}{constexpr} FMT\_INLINE value() : no\_value() \{\}}
\DoxyCodeLine{1245   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{int} val) : int\_value(val) \{\}}
\DoxyCodeLine{1246   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{unsigned} val) : uint\_value(val) \{\}}
\DoxyCodeLine{1247   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) : long\_long\_value(val) \{\}}
\DoxyCodeLine{1248   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) : ulong\_long\_value(val) \{\}}
\DoxyCodeLine{1249   FMT\_INLINE value(int128\_opt val) : int128\_value(val) \{\}}
\DoxyCodeLine{1250   FMT\_INLINE value(uint128\_opt val) : uint128\_value(val) \{\}}
\DoxyCodeLine{1251   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{float} val) : float\_value(val) \{\}}
\DoxyCodeLine{1252   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{double} val) : double\_value(val) \{\}}
\DoxyCodeLine{1253   FMT\_INLINE value(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) : long\_double\_value(val) \{\}}
\DoxyCodeLine{1254   \textcolor{keyword}{constexpr} FMT\_INLINE value(\textcolor{keywordtype}{bool} val) : bool\_value(val) \{\}}
\DoxyCodeLine{1255   \textcolor{keyword}{constexpr} FMT\_INLINE value(char\_type val) : char\_value(val) \{\}}
\DoxyCodeLine{1256   FMT\_CONSTEXPR FMT\_INLINE value(\textcolor{keyword}{const} char\_type* val) \{}
\DoxyCodeLine{1257     \textcolor{keywordtype}{string}.data = val;}
\DoxyCodeLine{1258     \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordtype}{string}.size = \{\};}
\DoxyCodeLine{1259   \}}
\DoxyCodeLine{1260   FMT\_CONSTEXPR FMT\_INLINE value(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} val) \{}
\DoxyCodeLine{1261     \textcolor{keywordtype}{string}.data = val.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{1262     \textcolor{keywordtype}{string}.size = val.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{1263   \}}
\DoxyCodeLine{1264   FMT\_INLINE value(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* val) : pointer(val) \{\}}
\DoxyCodeLine{1265   FMT\_INLINE value(\textcolor{keyword}{const} named\_arg\_info<char\_type>* args, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{1266       : named\_args\{args, size\} \{\}}
\DoxyCodeLine{1267 }
\DoxyCodeLine{1268   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_CONSTEXPR FMT\_INLINE value(T\& val) \{}
\DoxyCodeLine{1269     \textcolor{keyword}{using }value\_type = remove\_cvref\_t<T>;}
\DoxyCodeLine{1270     custom.value = \textcolor{keyword}{const\_cast<}value\_type*\textcolor{keyword}{>}(\&val);}
\DoxyCodeLine{1271     \textcolor{comment}{// Get the formatter type through the context to allow different contexts}}
\DoxyCodeLine{1272     \textcolor{comment}{// have different extension points, e.g. `formatter<T>` for `format` and}}
\DoxyCodeLine{1273     \textcolor{comment}{// `printf\_formatter<T>` for `printf`.}}
\DoxyCodeLine{1274     custom.format = format\_custom\_arg<}
\DoxyCodeLine{1275         value\_type,}
\DoxyCodeLine{1276         conditional\_t<has\_formatter<value\_type, Context>::value,}
\DoxyCodeLine{1277                       \textcolor{keyword}{typename} Context::template formatter\_type<value\_type>,}
\DoxyCodeLine{1278                       fallback\_formatter<value\_type, char\_type>>>;}
\DoxyCodeLine{1279   \}}
\DoxyCodeLine{1280   value(unformattable);}
\DoxyCodeLine{1281   value(unformattable\_char);}
\DoxyCodeLine{1282   value(unformattable\_const);}
\DoxyCodeLine{1283   value(unformattable\_pointer);}
\DoxyCodeLine{1284 }
\DoxyCodeLine{1285  \textcolor{keyword}{private}:}
\DoxyCodeLine{1286   \textcolor{comment}{// Formats an argument of a custom type, such as a user-\/defined class.}}
\DoxyCodeLine{1287   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Formatter>}
\DoxyCodeLine{1288   \textcolor{keyword}{static} \textcolor{keywordtype}{void} format\_custom\_arg(\textcolor{keywordtype}{void}* arg,}
\DoxyCodeLine{1289                                 \textcolor{keyword}{typename} Context::parse\_context\_type\& parse\_ctx,}
\DoxyCodeLine{1290                                 Context\& ctx) \{}
\DoxyCodeLine{1291     \textcolor{keyword}{auto} f = Formatter();}
\DoxyCodeLine{1292     parse\_ctx.advance\_to(f.parse(parse\_ctx));}
\DoxyCodeLine{1293     \textcolor{keyword}{using }qualified\_type =}
\DoxyCodeLine{1294         conditional\_t<has\_const\_formatter<T, Context>(), \textcolor{keyword}{const} T, T>;}
\DoxyCodeLine{1295     ctx.advance\_to(f.format(*\textcolor{keyword}{static\_cast<}qualified\_type*\textcolor{keyword}{>}(arg), ctx));}
\DoxyCodeLine{1296   \}}
\DoxyCodeLine{1297 \};}
\DoxyCodeLine{1298 }
\DoxyCodeLine{1299 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1300 FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_arg(T\&\& value) -\/> basic\_format\_arg<Context>;}
\DoxyCodeLine{1301 }
\DoxyCodeLine{1302 \textcolor{comment}{// To minimize the number of types we need to deal with, long is translated}}
\DoxyCodeLine{1303 \textcolor{comment}{// either to int or to long long depending on its size.}}
\DoxyCodeLine{1304 \textcolor{keyword}{enum} \{ long\_short = \textcolor{keyword}{sizeof}(long) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) \};}
\DoxyCodeLine{1305 \textcolor{keyword}{using }long\_type = conditional\_t<long\_short, int, long long>;}
\DoxyCodeLine{1306 \textcolor{keyword}{using }ulong\_type = conditional\_t<long\_short, unsigned, unsigned long long>;}
\DoxyCodeLine{1307 }
\DoxyCodeLine{1308 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_byte}}
\DoxyCodeLine{1309 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format\_as(std::byte b) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{1310   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(b);}
\DoxyCodeLine{1311 \}}
\DoxyCodeLine{1312 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1313 }
\DoxyCodeLine{1314 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }has\_format\_as \{}
\DoxyCodeLine{1315   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U, \textcolor{keyword}{typename} V = \textcolor{keyword}{decltype}(format\_as(U())),}
\DoxyCodeLine{1316             FMT\_ENABLE\_IF(std::is\_enum<U>::value\&\& std::is\_integral<V>::value)>}
\DoxyCodeLine{1317   \textcolor{keyword}{static} \textcolor{keyword}{auto} check(U*) -\/> std::true\_type;}
\DoxyCodeLine{1318   \textcolor{keyword}{static} \textcolor{keyword}{auto} check(...) -\/> std::false\_type;}
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320   \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{decltype}(check(\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})))::value \};}
\DoxyCodeLine{1321 \};}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323 \textcolor{comment}{// Maps formatting arguments to core types.}}
\DoxyCodeLine{1324 \textcolor{comment}{// arg\_mapper reports errors by returning unformattable instead of using}}
\DoxyCodeLine{1325 \textcolor{comment}{// static\_assert because it's used in the is\_formattable trait.}}
\DoxyCodeLine{1326 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{struct }arg\_mapper \{}
\DoxyCodeLine{1327   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{1328 }
\DoxyCodeLine{1329   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} val) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1330   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} val) -\/> \textcolor{keywordtype}{unsigned} \{}
\DoxyCodeLine{1331     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1332   \}}
\DoxyCodeLine{1333   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{short} val) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1334   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} val) -\/> \textcolor{keywordtype}{unsigned} \{}
\DoxyCodeLine{1335     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1336   \}}
\DoxyCodeLine{1337   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{int} val) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1338   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} val) -\/> \textcolor{keywordtype}{unsigned} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1339   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{long} val) -\/> long\_type \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1340   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} val) -\/> ulong\_type \{}
\DoxyCodeLine{1341     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1342   \}}
\DoxyCodeLine{1343   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) -\/> \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1344   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val)}
\DoxyCodeLine{1345       -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1346     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1347   \}}
\DoxyCodeLine{1348   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(int128\_opt val) -\/> int128\_opt \{}
\DoxyCodeLine{1349     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1350   \}}
\DoxyCodeLine{1351   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(uint128\_opt val) -\/> uint128\_opt \{}
\DoxyCodeLine{1352     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1353   \}}
\DoxyCodeLine{1354   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{bool} val) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1355 }
\DoxyCodeLine{1356   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_same<T, \textcolor{keywordtype}{char}>::value ||}
\DoxyCodeLine{1357                                       std::is\_same<T, \textcolor{keywordtype}{char}\_type>::value)>}
\DoxyCodeLine{1358   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(T val) -\/> char\_type \{}
\DoxyCodeLine{1359     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1360   \}}
\DoxyCodeLine{1361   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, enable\_if\_t<(std::is\_same<T, \textcolor{keywordtype}{wchar\_t}>::value ||}
\DoxyCodeLine{1362 \#ifdef \_\_cpp\_\textcolor{keywordtype}{char8\_t}}
\DoxyCodeLine{1363                                      std::is\_same<T, \textcolor{keywordtype}{char8\_t}>::value ||}
\DoxyCodeLine{1364 \#endif}
\DoxyCodeLine{1365                                      std::is\_same<T, \textcolor{keywordtype}{char16\_t}>::value ||}
\DoxyCodeLine{1366                                      std::is\_same<T, \textcolor{keywordtype}{char32\_t}>::value) \&\&}
\DoxyCodeLine{1367                                         !std::is\_same<T, \textcolor{keywordtype}{char}\_type>::value,}
\DoxyCodeLine{1368                                     \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{1369   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(T) -\/> unformattable\_char \{}
\DoxyCodeLine{1370     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1371   \}}
\DoxyCodeLine{1372 }
\DoxyCodeLine{1373   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{float} val) -\/> \textcolor{keywordtype}{float} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1374   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{double} val) -\/> \textcolor{keywordtype}{double} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1375   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) -\/> \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{1376     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1377   \}}
\DoxyCodeLine{1378 }
\DoxyCodeLine{1379   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(char\_type* val) -\/> \textcolor{keyword}{const} char\_type* \{}
\DoxyCodeLine{1380     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1381   \}}
\DoxyCodeLine{1382   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} char\_type* val) -\/> \textcolor{keyword}{const} char\_type* \{}
\DoxyCodeLine{1383     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1384   \}}
\DoxyCodeLine{1385   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1386             FMT\_ENABLE\_IF(is\_string<T>::value \&\& !std::is\_pointer<T>::value \&\&}
\DoxyCodeLine{1387                           std::is\_same<char\_type, char\_t<T>>::value)>}
\DoxyCodeLine{1388   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val)}
\DoxyCodeLine{1389       -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} \{}
\DoxyCodeLine{1390     \textcolor{keywordflow}{return} to\_string\_view(val);}
\DoxyCodeLine{1391   \}}
\DoxyCodeLine{1392   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1393             FMT\_ENABLE\_IF(is\_string<T>::value \&\& !std::is\_pointer<T>::value \&\&}
\DoxyCodeLine{1394                           !std::is\_same<char\_type, char\_t<T>>::value)>}
\DoxyCodeLine{1395   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\&) -\/> unformattable\_char \{}
\DoxyCodeLine{1396     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1397   \}}
\DoxyCodeLine{1398   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1399             FMT\_ENABLE\_IF(}
\DoxyCodeLine{1400                 std::is\_convertible<T, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}>::value \&\&}
\DoxyCodeLine{1401                 !is\_string<T>::value \&\& !has\_formatter<T, Context>::value \&\&}
\DoxyCodeLine{1402                 !has\_fallback\_formatter<T, char\_type>::value)>}
\DoxyCodeLine{1403   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val)}
\DoxyCodeLine{1404       -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} \{}
\DoxyCodeLine{1405     \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(val);}
\DoxyCodeLine{1406   \}}
\DoxyCodeLine{1407   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1408             FMT\_ENABLE\_IF(}
\DoxyCodeLine{1409                 std::is\_convertible<T, std\_string\_view<char\_type>>::value \&\&}
\DoxyCodeLine{1410                 !std::is\_convertible<T, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}>::value \&\&}
\DoxyCodeLine{1411                 !is\_string<T>::value \&\& !has\_formatter<T, Context>::value \&\&}
\DoxyCodeLine{1412                 !has\_fallback\_formatter<T, char\_type>::value)>}
\DoxyCodeLine{1413   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val)}
\DoxyCodeLine{1414       -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} \{}
\DoxyCodeLine{1415     \textcolor{keywordflow}{return} std\_string\_view<char\_type>(val);}
\DoxyCodeLine{1416   \}}
\DoxyCodeLine{1417 }
\DoxyCodeLine{1418   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{void}* val) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1419   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* val) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{1420     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1421   \}}
\DoxyCodeLine{1422   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(std::nullptr\_t val) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{1423     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1424   \}}
\DoxyCodeLine{1425 }
\DoxyCodeLine{1426   \textcolor{comment}{// We use SFINAE instead of a const T* parameter to avoid conflicting with}}
\DoxyCodeLine{1427   \textcolor{comment}{// the C array overload.}}
\DoxyCodeLine{1428   \textcolor{keyword}{template} <}
\DoxyCodeLine{1429       \textcolor{keyword}{typename} T,}
\DoxyCodeLine{1430       FMT\_ENABLE\_IF(}
\DoxyCodeLine{1431           std::is\_pointer<T>::value || std::is\_member\_pointer<T>::value ||}
\DoxyCodeLine{1432           std::is\_function<\textcolor{keyword}{typename} std::remove\_pointer<T>::type>::value ||}
\DoxyCodeLine{1433           (std::is\_convertible<const T\&, const void*>::value \&\&}
\DoxyCodeLine{1434            !std::is\_convertible<const T\&, const char\_type*>::value \&\&}
\DoxyCodeLine{1435            !has\_formatter<T, Context>::value))>}
\DoxyCodeLine{1436   FMT\_CONSTEXPR \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\&) -\/> unformattable\_pointer \{}
\DoxyCodeLine{1437     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1438   \}}
\DoxyCodeLine{1439 }
\DoxyCodeLine{1440   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::size\_t N,}
\DoxyCodeLine{1441             FMT\_ENABLE\_IF(!std::is\_same<T, wchar\_t>::value)>}
\DoxyCodeLine{1442   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T (\&values)[N]) -\/> \textcolor{keyword}{const} T (\&)[N] \{}
\DoxyCodeLine{1443     \textcolor{keywordflow}{return} values;}
\DoxyCodeLine{1444   \}}
\DoxyCodeLine{1445 }
\DoxyCodeLine{1446   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1447             FMT\_ENABLE\_IF(}
\DoxyCodeLine{1448                 std::is\_enum<T>::value\&\& std::is\_convertible<T, int>::value \&\&}
\DoxyCodeLine{1449                 !has\_format\_as<T>::value \&\& !has\_formatter<T, Context>::value \&\&}
\DoxyCodeLine{1450                 !has\_fallback\_formatter<T, char\_type>::value)>}
\DoxyCodeLine{1451   FMT\_DEPRECATED FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val)}
\DoxyCodeLine{1452       -\/> \textcolor{keyword}{decltype}(std::declval<arg\_mapper>().map(}
\DoxyCodeLine{1453           \textcolor{keyword}{static\_cast<}underlying\_t<T>\textcolor{keyword}{>}(val))) \{}
\DoxyCodeLine{1454     \textcolor{keywordflow}{return} map(\textcolor{keyword}{static\_cast<}underlying\_t<T>\textcolor{keyword}{>}(val));}
\DoxyCodeLine{1455   \}}
\DoxyCodeLine{1456 }
\DoxyCodeLine{1457   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(has\_format\_as<T>::value \&\&}
\DoxyCodeLine{1458                                       !has\_formatter<T, Context>::value)>}
\DoxyCodeLine{1459   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val)}
\DoxyCodeLine{1460       -\/> \textcolor{keyword}{decltype}(std::declval<arg\_mapper>().map(format\_as(T()))) \{}
\DoxyCodeLine{1461     \textcolor{keywordflow}{return} map(format\_as(val));}
\DoxyCodeLine{1462   \}}
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U = remove\_cvref\_t<T>>}
\DoxyCodeLine{1465   \textcolor{keyword}{struct }formattable}
\DoxyCodeLine{1466       : bool\_constant<has\_const\_formatter<U, Context>() ||}
\DoxyCodeLine{1467                       !std::is\_const<remove\_reference\_t<T>>::value ||}
\DoxyCodeLine{1468                       has\_fallback\_formatter<U, char\_type>::value> \{\};}
\DoxyCodeLine{1469 }
\DoxyCodeLine{1470 \textcolor{preprocessor}{\#if (FMT\_MSC\_VERSION != 0 \&\& FMT\_MSC\_VERSION < 1910) || \(\backslash\)}}
\DoxyCodeLine{1471 \textcolor{preprocessor}{    FMT\_ICC\_VERSION != 0 || defined(\_\_NVCC\_\_)}}
\DoxyCodeLine{1472   \textcolor{comment}{// Workaround a bug in MSVC and Intel (Issue 2746).}}
\DoxyCodeLine{1473   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} do\_map(T\&\& val) -\/> T\& \{}
\DoxyCodeLine{1474     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1475   \}}
\DoxyCodeLine{1476 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1477   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(formattable<T>::value)>}
\DoxyCodeLine{1478   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} do\_map(T\&\& val) -\/> T\& \{}
\DoxyCodeLine{1479     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1480   \}}
\DoxyCodeLine{1481   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!formattable<T>::value)>}
\DoxyCodeLine{1482   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} do\_map(T\&\&) -\/> unformattable\_const \{}
\DoxyCodeLine{1483     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1484   \}}
\DoxyCodeLine{1485 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1486 }
\DoxyCodeLine{1487   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U = remove\_cvref\_t<T>,}
\DoxyCodeLine{1488             FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{string}<U>::value \&\& !is\_\textcolor{keywordtype}{char}<U>::value \&\&}
\DoxyCodeLine{1489                           !std::is\_array<U>::value \&\&}
\DoxyCodeLine{1490                           !std::is\_po\textcolor{keywordtype}{int}er<U>::value \&\&}
\DoxyCodeLine{1491                           !has\_format\_as<U>::value \&\&}
\DoxyCodeLine{1492                           (has\_formatter<U, Context>::value ||}
\DoxyCodeLine{1493                            has\_fallback\_formatter<U, \textcolor{keywordtype}{char}\_type>::value))>}
\DoxyCodeLine{1494   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(T\&\& val)}
\DoxyCodeLine{1495       -\/> \textcolor{keyword}{decltype}(this-\/>do\_map(std::forward<T>(val))) \{}
\DoxyCodeLine{1496     \textcolor{keywordflow}{return} do\_map(std::forward<T>(val));}
\DoxyCodeLine{1497   \}}
\DoxyCodeLine{1498 }
\DoxyCodeLine{1499   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_named\_arg<T>::value)>}
\DoxyCodeLine{1500   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& named\_arg)}
\DoxyCodeLine{1501       -\/> \textcolor{keyword}{decltype}(std::declval<arg\_mapper>().map(named\_arg.value)) \{}
\DoxyCodeLine{1502     \textcolor{keywordflow}{return} map(named\_arg.value);}
\DoxyCodeLine{1503   \}}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505   \textcolor{keyword}{auto} map(...) -\/> unformattable \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{1506 \};}
\DoxyCodeLine{1507 }
\DoxyCodeLine{1508 \textcolor{comment}{// A type constant after applying arg\_mapper<Context>.}}
\DoxyCodeLine{1509 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1510 \textcolor{keyword}{using }mapped\_type\_constant =}
\DoxyCodeLine{1511     type\_constant<decltype(arg\_mapper<Context>().map(std::declval<const T\&>())),}
\DoxyCodeLine{1512                   \textcolor{keyword}{typename} Context::char\_type>;}
\DoxyCodeLine{1513 }
\DoxyCodeLine{1514 \textcolor{keyword}{enum} \{ packed\_arg\_bits = 4 \};}
\DoxyCodeLine{1515 \textcolor{comment}{// Maximum number of arguments with packed types.}}
\DoxyCodeLine{1516 \textcolor{keyword}{enum} \{ max\_packed\_args = 62 / packed\_arg\_bits \};}
\DoxyCodeLine{1517 enum : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ is\_unpacked\_bit = 1ULL << 63 \};}
\DoxyCodeLine{1518 enum : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ has\_named\_args\_bit = 1ULL << 62 \};}
\DoxyCodeLine{1519 }
\DoxyCodeLine{1520 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{1521 }
\DoxyCodeLine{1522 \textcolor{comment}{// An output iterator that appends to a buffer.}}
\DoxyCodeLine{1523 \textcolor{comment}{// It is used to reduce symbol sizes for the common case.}}
\DoxyCodeLine{1524 \textcolor{keyword}{class }appender : \textcolor{keyword}{public} std::back\_insert\_iterator<detail::buffer<char>> \{}
\DoxyCodeLine{1525   \textcolor{keyword}{using }base = std::back\_insert\_iterator<detail::buffer<char>>;}
\DoxyCodeLine{1526 }
\DoxyCodeLine{1527   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1528   \textcolor{keyword}{friend} \textcolor{keyword}{auto} get\_buffer(appender out) -\/> detail::buffer<char>\& \{}
\DoxyCodeLine{1529     \textcolor{keywordflow}{return} detail::get\_container(out);}
\DoxyCodeLine{1530   \}}
\DoxyCodeLine{1531 }
\DoxyCodeLine{1532  \textcolor{keyword}{public}:}
\DoxyCodeLine{1533   \textcolor{keyword}{using }std::back\_insert\_iterator<detail::buffer<char>>::back\_insert\_iterator;}
\DoxyCodeLine{1534   appender(base it) noexcept : base(it) \{\}}
\DoxyCodeLine{1535   FMT\_UNCHECKED\_ITERATOR(appender);}
\DoxyCodeLine{1536 }
\DoxyCodeLine{1537   \textcolor{keyword}{auto} operator++() noexcept -\/> appender\& \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{1538   \textcolor{keyword}{auto} operator++(\textcolor{keywordtype}{int}) \textcolor{keyword}{noexcept} -\/> appender \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{1539 \};}
\DoxyCodeLine{1540 }
\DoxyCodeLine{1541 \textcolor{comment}{// A formatting argument. It is a trivially copyable/constructible type to}}
\DoxyCodeLine{1542 \textcolor{comment}{// allow storage in basic\_memory\_buffer.}}
\DoxyCodeLine{1543 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }basic\_format\_arg \{}
\DoxyCodeLine{1544  \textcolor{keyword}{private}:}
\DoxyCodeLine{1545   detail::value<Context> value\_;}
\DoxyCodeLine{1546   detail::type type\_;}
\DoxyCodeLine{1547 }
\DoxyCodeLine{1548   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContextType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1549   \textcolor{keyword}{friend} FMT\_CONSTEXPR \textcolor{keyword}{auto} detail::make\_arg(T\&\& value)}
\DoxyCodeLine{1550       -\/> basic\_format\_arg<ContextType>;}
\DoxyCodeLine{1551 }
\DoxyCodeLine{1552   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor, \textcolor{keyword}{typename} Ctx>}
\DoxyCodeLine{1553   \textcolor{keyword}{friend} FMT\_CONSTEXPR \textcolor{keyword}{auto} visit\_format\_arg(Visitor\&\& vis,}
\DoxyCodeLine{1554                                              \textcolor{keyword}{const} basic\_format\_arg<Ctx>\& arg)}
\DoxyCodeLine{1555       -\/> \textcolor{keyword}{decltype}(vis(0));}
\DoxyCodeLine{1556 }
\DoxyCodeLine{1557   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<Context>;}
\DoxyCodeLine{1558   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classdynamic__format__arg__store}{dynamic\_format\_arg\_store}}<Context>;}
\DoxyCodeLine{1559 }
\DoxyCodeLine{1560   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{1561 }
\DoxyCodeLine{1562   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} NUM\_ARGS, \textcolor{keywordtype}{size\_t} NUM\_NAMED\_ARGS>}
\DoxyCodeLine{1563   \textcolor{keyword}{friend} \textcolor{keyword}{struct }detail::arg\_data;}
\DoxyCodeLine{1564 }
\DoxyCodeLine{1565   basic\_format\_arg(\textcolor{keyword}{const} detail::named\_arg\_info<char\_type>* args, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{1566       : value\_(args, size) \{\}}
\DoxyCodeLine{1567 }
\DoxyCodeLine{1568  \textcolor{keyword}{public}:}
\DoxyCodeLine{1569   \textcolor{keyword}{class }handle \{}
\DoxyCodeLine{1570    \textcolor{keyword}{public}:}
\DoxyCodeLine{1571     \textcolor{keyword}{explicit} handle(detail::custom\_value<Context> custom) : custom\_(custom) \{\}}
\DoxyCodeLine{1572 }
\DoxyCodeLine{1573     \textcolor{keywordtype}{void} format(\textcolor{keyword}{typename} Context::parse\_context\_type\& parse\_ctx,}
\DoxyCodeLine{1574                 Context\& ctx)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1575       custom\_.format(custom\_.value, parse\_ctx, ctx);}
\DoxyCodeLine{1576     \}}
\DoxyCodeLine{1577 }
\DoxyCodeLine{1578    \textcolor{keyword}{private}:}
\DoxyCodeLine{1579     detail::custom\_value<Context> custom\_;}
\DoxyCodeLine{1580   \};}
\DoxyCodeLine{1581 }
\DoxyCodeLine{1582   \textcolor{keyword}{constexpr} basic\_format\_arg() : type\_(detail::type::none\_type) \{\}}
\DoxyCodeLine{1583 }
\DoxyCodeLine{1584   \textcolor{keyword}{constexpr} \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() const noexcept \{}
\DoxyCodeLine{1585     \textcolor{keywordflow}{return} type\_ != detail::type::none\_type;}
\DoxyCodeLine{1586   \}}
\DoxyCodeLine{1587 }
\DoxyCodeLine{1588   \textcolor{keyword}{auto} type() const -\/> detail::type \{ \textcolor{keywordflow}{return} type\_; \}}
\DoxyCodeLine{1589 }
\DoxyCodeLine{1590   \textcolor{keyword}{auto} is\_integral() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} detail::is\_integral\_type(type\_); \}}
\DoxyCodeLine{1591   \textcolor{keyword}{auto} is\_arithmetic() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1592     \textcolor{keywordflow}{return} detail::is\_arithmetic\_type(type\_);}
\DoxyCodeLine{1593   \}}
\DoxyCodeLine{1594 \};}
\DoxyCodeLine{1595 }
\DoxyCodeLine{1603 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1604 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} visit\_format\_arg(}
\DoxyCodeLine{1605     Visitor\&\& vis, \textcolor{keyword}{const} basic\_format\_arg<Context>\& arg) -\/> \textcolor{keyword}{decltype}(vis(0)) \{}
\DoxyCodeLine{1606   \textcolor{keywordflow}{switch} (arg.type\_) \{}
\DoxyCodeLine{1607   \textcolor{keywordflow}{case} detail::type::none\_type:}
\DoxyCodeLine{1608     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1609   \textcolor{keywordflow}{case} detail::type::int\_type:}
\DoxyCodeLine{1610     \textcolor{keywordflow}{return} vis(arg.value\_.int\_value);}
\DoxyCodeLine{1611   \textcolor{keywordflow}{case} detail::type::uint\_type:}
\DoxyCodeLine{1612     \textcolor{keywordflow}{return} vis(arg.value\_.uint\_value);}
\DoxyCodeLine{1613   \textcolor{keywordflow}{case} detail::type::long\_long\_type:}
\DoxyCodeLine{1614     \textcolor{keywordflow}{return} vis(arg.value\_.long\_long\_value);}
\DoxyCodeLine{1615   \textcolor{keywordflow}{case} detail::type::ulong\_long\_type:}
\DoxyCodeLine{1616     \textcolor{keywordflow}{return} vis(arg.value\_.ulong\_long\_value);}
\DoxyCodeLine{1617   \textcolor{keywordflow}{case} detail::type::int128\_type:}
\DoxyCodeLine{1618     \textcolor{keywordflow}{return} vis(detail::convert\_for\_visit(arg.value\_.int128\_value));}
\DoxyCodeLine{1619   \textcolor{keywordflow}{case} detail::type::uint128\_type:}
\DoxyCodeLine{1620     \textcolor{keywordflow}{return} vis(detail::convert\_for\_visit(arg.value\_.uint128\_value));}
\DoxyCodeLine{1621   \textcolor{keywordflow}{case} detail::type::bool\_type:}
\DoxyCodeLine{1622     \textcolor{keywordflow}{return} vis(arg.value\_.bool\_value);}
\DoxyCodeLine{1623   \textcolor{keywordflow}{case} detail::type::char\_type:}
\DoxyCodeLine{1624     \textcolor{keywordflow}{return} vis(arg.value\_.char\_value);}
\DoxyCodeLine{1625   \textcolor{keywordflow}{case} detail::type::float\_type:}
\DoxyCodeLine{1626     \textcolor{keywordflow}{return} vis(arg.value\_.float\_value);}
\DoxyCodeLine{1627   \textcolor{keywordflow}{case} detail::type::double\_type:}
\DoxyCodeLine{1628     \textcolor{keywordflow}{return} vis(arg.value\_.double\_value);}
\DoxyCodeLine{1629   \textcolor{keywordflow}{case} detail::type::long\_double\_type:}
\DoxyCodeLine{1630     \textcolor{keywordflow}{return} vis(arg.value\_.long\_double\_value);}
\DoxyCodeLine{1631   \textcolor{keywordflow}{case} detail::type::cstring\_type:}
\DoxyCodeLine{1632     \textcolor{keywordflow}{return} vis(arg.value\_.string.data);}
\DoxyCodeLine{1633   \textcolor{keywordflow}{case} detail::type::string\_type:}
\DoxyCodeLine{1634     \textcolor{keyword}{using }sv = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename Context::char\_type>}};}
\DoxyCodeLine{1635     \textcolor{keywordflow}{return} vis(sv(arg.value\_.string.data, arg.value\_.string.size));}
\DoxyCodeLine{1636   \textcolor{keywordflow}{case} detail::type::pointer\_type:}
\DoxyCodeLine{1637     \textcolor{keywordflow}{return} vis(arg.value\_.pointer);}
\DoxyCodeLine{1638   \textcolor{keywordflow}{case} detail::type::custom\_type:}
\DoxyCodeLine{1639     \textcolor{keywordflow}{return} vis(\textcolor{keyword}{typename} basic\_format\_arg<Context>::handle(arg.value\_.custom));}
\DoxyCodeLine{1640   \}}
\DoxyCodeLine{1641   \textcolor{keywordflow}{return} vis(monostate());}
\DoxyCodeLine{1642 \}}
\DoxyCodeLine{1643 }
\DoxyCodeLine{1644 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{1645 }
\DoxyCodeLine{1646 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{1647 \textcolor{keyword}{auto} copy\_str(InputIt begin, InputIt end, appender out) -\/> appender \{}
\DoxyCodeLine{1648   get\_container(out).append(begin, end);}
\DoxyCodeLine{1649   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1650 \}}
\DoxyCodeLine{1651 }
\DoxyCodeLine{1652 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 500}}
\DoxyCodeLine{1653 \textcolor{comment}{// A workaround for gcc 4.8 to make void\_t work in a SFINAE context.}}
\DoxyCodeLine{1654 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts> \textcolor{keyword}{struct }void\_t\_impl \{ \textcolor{keyword}{using }type = void; \};}
\DoxyCodeLine{1655 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{1656 \textcolor{keyword}{using }void\_t = \textcolor{keyword}{typename} detail::void\_t\_impl<Ts...>::type;}
\DoxyCodeLine{1657 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1658 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{using }void\_t = void;}
\DoxyCodeLine{1659 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1660 }
\DoxyCodeLine{1661 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1662 \textcolor{keyword}{struct }is\_output\_iterator : std::false\_type \{\};}
\DoxyCodeLine{1663 }
\DoxyCodeLine{1664 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1665 \textcolor{keyword}{struct }is\_output\_iterator<}
\DoxyCodeLine{1666     It, T,}
\DoxyCodeLine{1667     void\_t<typename std::iterator\_traits<It>::iterator\_category,}
\DoxyCodeLine{1668            \textcolor{keyword}{decltype}(*std::declval<It>() = std::declval<T>())>>}
\DoxyCodeLine{1669     : std::true\_type \{\};}
\DoxyCodeLine{1670 }
\DoxyCodeLine{1671 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1672 \textcolor{keyword}{struct }is\_back\_insert\_iterator : std::false\_type \{\};}
\DoxyCodeLine{1673 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1674 \textcolor{keyword}{struct }is\_back\_insert\_iterator<std::back\_insert\_iterator<Container>>}
\DoxyCodeLine{1675     : std::true\_type \{\};}
\DoxyCodeLine{1676 }
\DoxyCodeLine{1677 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1678 \textcolor{keyword}{struct }is\_contiguous\_back\_insert\_iterator : std::false\_type \{\};}
\DoxyCodeLine{1679 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1680 \textcolor{keyword}{struct }is\_contiguous\_back\_insert\_iterator<std::back\_insert\_iterator<Container>>}
\DoxyCodeLine{1681     : is\_contiguous<Container> \{\};}
\DoxyCodeLine{1682 \textcolor{keyword}{template} <>}
\DoxyCodeLine{1683 \textcolor{keyword}{struct }is\_contiguous\_back\_insert\_iterator<appender> : std::true\_type \{\};}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685 \textcolor{comment}{// A type-\/erased reference to an std::locale to avoid a heavy <locale> include.}}
\DoxyCodeLine{1686 \textcolor{keyword}{class }locale\_ref \{}
\DoxyCodeLine{1687  \textcolor{keyword}{private}:}
\DoxyCodeLine{1688   \textcolor{keyword}{const} \textcolor{keywordtype}{void}* locale\_;  \textcolor{comment}{// A type-\/erased pointer to std::locale.}}
\DoxyCodeLine{1689 }
\DoxyCodeLine{1690  \textcolor{keyword}{public}:}
\DoxyCodeLine{1691   \textcolor{keyword}{constexpr} locale\_ref() : locale\_(nullptr) \{\}}
\DoxyCodeLine{1692   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale> \textcolor{keyword}{explicit} locale\_ref(\textcolor{keyword}{const} Locale\& loc);}
\DoxyCodeLine{1693 }
\DoxyCodeLine{1694   \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() const noexcept \{ \textcolor{keywordflow}{return} locale\_ != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{1695 }
\DoxyCodeLine{1696   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale> \textcolor{keyword}{auto} get() const -\/> Locale;}
\DoxyCodeLine{1697 \};}
\DoxyCodeLine{1698 }
\DoxyCodeLine{1699 template <typename> constexpr auto encode\_types() -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1700   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1701 \}}
\DoxyCodeLine{1702 }
\DoxyCodeLine{1703 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1704 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} encode\_types() -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1705   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(mapped\_type\_constant<Arg, Context>::value) |}
\DoxyCodeLine{1706          (encode\_types<Context, Args...>() << packed\_arg\_bits);}
\DoxyCodeLine{1707 \}}
\DoxyCodeLine{1708 }
\DoxyCodeLine{1709 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1710 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} make\_value(T\&\& val) -\/> value<Context> \{}
\DoxyCodeLine{1711   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& arg = arg\_mapper<Context>().map(std::forward<T>(val));}
\DoxyCodeLine{1712 }
\DoxyCodeLine{1713   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable\_char =}
\DoxyCodeLine{1714       !std::is\_same<\textcolor{keyword}{decltype}(arg), \textcolor{keyword}{const} unformattable\_char\&>::value;}
\DoxyCodeLine{1715   \textcolor{keyword}{static\_assert}(formattable\_char, \textcolor{stringliteral}{"{}Mixing character types is disallowed."{}});}
\DoxyCodeLine{1716 }
\DoxyCodeLine{1717   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable\_const =}
\DoxyCodeLine{1718       !std::is\_same<\textcolor{keyword}{decltype}(arg), \textcolor{keyword}{const} unformattable\_const\&>::value;}
\DoxyCodeLine{1719   \textcolor{keyword}{static\_assert}(formattable\_const, \textcolor{stringliteral}{"{}Cannot format a const argument."{}});}
\DoxyCodeLine{1720 }
\DoxyCodeLine{1721   \textcolor{comment}{// Formatting of arbitrary pointers is disallowed. If you want to output}}
\DoxyCodeLine{1722   \textcolor{comment}{// a pointer cast it to "{}void *"{} or "{}const void *"{}. In particular, this}}
\DoxyCodeLine{1723   \textcolor{comment}{// forbids formatting of "{}[const] volatile char *"{} which is printed as bool}}
\DoxyCodeLine{1724   \textcolor{comment}{// by iostreams.}}
\DoxyCodeLine{1725   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable\_pointer =}
\DoxyCodeLine{1726       !std::is\_same<\textcolor{keyword}{decltype}(arg), \textcolor{keyword}{const} unformattable\_pointer\&>::value;}
\DoxyCodeLine{1727   \textcolor{keyword}{static\_assert}(formattable\_pointer,}
\DoxyCodeLine{1728                 \textcolor{stringliteral}{"{}Formatting of non-\/void pointers is disallowed."{}});}
\DoxyCodeLine{1729 }
\DoxyCodeLine{1730   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable =}
\DoxyCodeLine{1731       !std::is\_same<\textcolor{keyword}{decltype}(arg), \textcolor{keyword}{const} unformattable\&>::value;}
\DoxyCodeLine{1732   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{1733       formattable,}
\DoxyCodeLine{1734       \textcolor{stringliteral}{"{}Cannot format an argument. To make type T formattable provide a "{}}}
\DoxyCodeLine{1735       \textcolor{stringliteral}{"{}formatter<T> specialization: https://fmt.dev/latest/api.html\#udt"{}});}
\DoxyCodeLine{1736   \textcolor{keywordflow}{return} \{arg\};}
\DoxyCodeLine{1737 \}}
\DoxyCodeLine{1738 }
\DoxyCodeLine{1739 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1740 FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_arg(T\&\& value) -\/> basic\_format\_arg<Context> \{}
\DoxyCodeLine{1741   basic\_format\_arg<Context> arg;}
\DoxyCodeLine{1742   arg.type\_ = mapped\_type\_constant<T, Context>::value;}
\DoxyCodeLine{1743   arg.value\_ = make\_value<Context>(value);}
\DoxyCodeLine{1744   \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1745 \}}
\DoxyCodeLine{1746 }
\DoxyCodeLine{1747 \textcolor{comment}{// The type template parameter is there to avoid an ODR violation when using}}
\DoxyCodeLine{1748 \textcolor{comment}{// a fallback formatter in one translation unit and an implicit conversion in}}
\DoxyCodeLine{1749 \textcolor{comment}{// another (not recommended).}}
\DoxyCodeLine{1750 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_PACKED, \textcolor{keyword}{typename} Context, type, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{1751           FMT\_ENABLE\_IF(IS\_PACKED)>}
\DoxyCodeLine{1752 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} make\_arg(T\&\& val) -\/> value<Context> \{}
\DoxyCodeLine{1753   \textcolor{keywordflow}{return} make\_value<Context>(val);}
\DoxyCodeLine{1754 \}}
\DoxyCodeLine{1755 }
\DoxyCodeLine{1756 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_PACKED, \textcolor{keyword}{typename} Context, type, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{1757           FMT\_ENABLE\_IF(!IS\_PACKED)>}
\DoxyCodeLine{1758 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} make\_arg(T\&\& value) -\/> basic\_format\_arg<Context> \{}
\DoxyCodeLine{1759   \textcolor{keywordflow}{return} make\_arg<Context>(value);}
\DoxyCodeLine{1760 \}}
\DoxyCodeLine{1761 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{1762 }
\DoxyCodeLine{1763 \textcolor{comment}{// Formatting context.}}
\DoxyCodeLine{1764 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char> \textcolor{keyword}{class }basic\_format\_context \{}
\DoxyCodeLine{1765  \textcolor{keyword}{public}:}
\DoxyCodeLine{1767   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{1768 }
\DoxyCodeLine{1769  \textcolor{keyword}{private}:}
\DoxyCodeLine{1770   OutputIt out\_;}
\DoxyCodeLine{1771   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_format\_context>}} args\_;}
\DoxyCodeLine{1772   detail::locale\_ref loc\_;}
\DoxyCodeLine{1773 }
\DoxyCodeLine{1774  \textcolor{keyword}{public}:}
\DoxyCodeLine{1775   \textcolor{keyword}{using }iterator = OutputIt;}
\DoxyCodeLine{1776   \textcolor{keyword}{using }format\_arg = basic\_format\_arg<basic\_format\_context>;}
\DoxyCodeLine{1777   \textcolor{keyword}{using }parse\_context\_type = \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}};}
\DoxyCodeLine{1778   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }formatter\_type = formatter<T, char\_type>;}
\DoxyCodeLine{1779 }
\DoxyCodeLine{1780   basic\_format\_context(basic\_format\_context\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1781   basic\_format\_context(\textcolor{keyword}{const} basic\_format\_context\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1782   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} basic\_format\_context\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1787   \textcolor{keyword}{constexpr} basic\_format\_context(}
\DoxyCodeLine{1788       OutputIt out, \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_format\_context>}} ctx\_args,}
\DoxyCodeLine{1789       detail::locale\_ref loc = detail::locale\_ref())}
\DoxyCodeLine{1790       : out\_(out), args\_(ctx\_args), loc\_(loc) \{\}}
\DoxyCodeLine{1791 }
\DoxyCodeLine{1792   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \textcolor{keyword}{const} -\/> format\_arg \{ \textcolor{keywordflow}{return} args\_.\mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{1793   FMT\_CONSTEXPR \textcolor{keyword}{auto} arg(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} name) -\/> format\_arg \{}
\DoxyCodeLine{1794     \textcolor{keywordflow}{return} args\_.\mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(name);}
\DoxyCodeLine{1795   \}}
\DoxyCodeLine{1796   FMT\_CONSTEXPR \textcolor{keyword}{auto} arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} name) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1797     \textcolor{keywordflow}{return} args\_.get\_id(name);}
\DoxyCodeLine{1798   \}}
\DoxyCodeLine{1799   \textcolor{keyword}{auto} args() const -\/> const \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<basic\_format\_context>\& \{}
\DoxyCodeLine{1800     \textcolor{keywordflow}{return} args\_;}
\DoxyCodeLine{1801   \}}
\DoxyCodeLine{1802 }
\DoxyCodeLine{1803   FMT\_CONSTEXPR \textcolor{keyword}{auto} error\_handler() -\/> detail::error\_handler \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{1804   \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{ error\_handler().on\_error(message); \}}
\DoxyCodeLine{1805 }
\DoxyCodeLine{1806   \textcolor{comment}{// Returns an iterator to the beginning of the output range.}}
\DoxyCodeLine{1807   FMT\_CONSTEXPR \textcolor{keyword}{auto} out() -\/> iterator \{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{1808 }
\DoxyCodeLine{1809   \textcolor{comment}{// Advances the begin iterator to ``it``.}}
\DoxyCodeLine{1810   \textcolor{keywordtype}{void} advance\_to(iterator it) \{}
\DoxyCodeLine{1811     \textcolor{keywordflow}{if} (!detail::is\_back\_insert\_iterator<iterator>()) out\_ = it;}
\DoxyCodeLine{1812   \}}
\DoxyCodeLine{1813 }
\DoxyCodeLine{1814   FMT\_CONSTEXPR \textcolor{keyword}{auto} locale() -\/> detail::locale\_ref \{ \textcolor{keywordflow}{return} loc\_; \}}
\DoxyCodeLine{1815 \};}
\DoxyCodeLine{1816 }
\DoxyCodeLine{1817 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1818 \textcolor{keyword}{using }buffer\_context =}
\DoxyCodeLine{1819     basic\_format\_context<detail::buffer\_appender<Char>, Char>;}
\DoxyCodeLine{1820 \textcolor{keyword}{using }format\_context = buffer\_context<char>;}
\DoxyCodeLine{1821 }
\DoxyCodeLine{1822 \textcolor{comment}{// Workaround an alias issue: https://stackoverflow.com/q/62767544/471164.}}
\DoxyCodeLine{1823 \textcolor{preprocessor}{\#define FMT\_BUFFER\_CONTEXT(Char) \(\backslash\)}}
\DoxyCodeLine{1824 \textcolor{preprocessor}{  basic\_format\_context<detail::buffer\_appender<Char>, Char>}}
\DoxyCodeLine{1825 }
\DoxyCodeLine{1826 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{1827 \textcolor{keyword}{using }is\_formattable = bool\_constant<}
\DoxyCodeLine{1828     !std::is\_base\_of<detail::unformattable,}
\DoxyCodeLine{1829                      \textcolor{keyword}{decltype}(detail::arg\_mapper<buffer\_context<Char>>().map(}
\DoxyCodeLine{1830                          std::declval<T>()))>::value \&\&}
\DoxyCodeLine{1831     !detail::has\_fallback\_formatter<T, Char>::value>;}
\DoxyCodeLine{1832 }
\DoxyCodeLine{1840 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1841 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}}
\DoxyCodeLine{1842 \#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}
\DoxyCodeLine{1843     \textcolor{comment}{// Workaround a GCC template argument substitution bug.}}
\DoxyCodeLine{1844     : \textcolor{keyword}{public} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}}}
\DoxyCodeLine{1845 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1846 \{}
\DoxyCodeLine{1847  \textcolor{keyword}{private}:}
\DoxyCodeLine{1848   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} num\_args = \textcolor{keyword}{sizeof}...(Args);}
\DoxyCodeLine{1849   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} num\_named\_args = detail::count\_named\_args<Args...>();}
\DoxyCodeLine{1850   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_packed = num\_args <= detail::max\_packed\_args;}
\DoxyCodeLine{1851 }
\DoxyCodeLine{1852   \textcolor{keyword}{using }value\_type = conditional\_t<is\_packed, detail::value<Context>,}
\DoxyCodeLine{1853                                    basic\_format\_arg<Context>>;}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855   detail::arg\_data<value\_type, \textcolor{keyword}{typename} Context::char\_type, num\_args,}
\DoxyCodeLine{1856                    num\_named\_args>}
\DoxyCodeLine{1857       data\_;}
\DoxyCodeLine{1858 }
\DoxyCodeLine{1859   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<Context>;}
\DoxyCodeLine{1860 }
\DoxyCodeLine{1861   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc =}
\DoxyCodeLine{1862       (is\_packed ? detail::encode\_types<Context, Args...>()}
\DoxyCodeLine{1863                  : detail::is\_unpacked\_bit | num\_args) |}
\DoxyCodeLine{1864       (num\_named\_args != 0}
\DoxyCodeLine{1865            ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(detail::has\_named\_args\_bit)}
\DoxyCodeLine{1866            : 0);}
\DoxyCodeLine{1867 }
\DoxyCodeLine{1868  \textcolor{keyword}{public}:}
\DoxyCodeLine{1869   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1870   FMT\_CONSTEXPR FMT\_INLINE \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}(T\&\&... args)}
\DoxyCodeLine{1871       :}
\DoxyCodeLine{1872 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}}
\DoxyCodeLine{1873         \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}}(*\textcolor{keyword}{this}),}
\DoxyCodeLine{1874 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1875         data\_\{detail::make\_arg<}
\DoxyCodeLine{1876             is\_packed, Context,}
\DoxyCodeLine{1877             detail::mapped\_type\_constant<remove\_cvref\_t<T>, Context>::value>(}
\DoxyCodeLine{1878             std::forward<T>(args))...\} \{}
\DoxyCodeLine{1879     detail::init\_named\_args(data\_.named\_args(), 0, 0, args...);}
\DoxyCodeLine{1880   \}}
\DoxyCodeLine{1881 \};}
\DoxyCodeLine{1882 }
\DoxyCodeLine{1891 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context = format\_context, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1892 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_format\_args(Args\&\&... args)}
\DoxyCodeLine{1893     -\/> \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<Context, remove\_cvref\_t<Args>}}...> \{}
\DoxyCodeLine{1894   \textcolor{keywordflow}{return} \{std::forward<Args>(args)...\};}
\DoxyCodeLine{1895 \}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1908 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1909 \textcolor{keyword}{inline} \textcolor{keyword}{auto} arg(\textcolor{keyword}{const} Char* name, \textcolor{keyword}{const} T\& arg) -\/> detail::named\_arg<Char, T> \{}
\DoxyCodeLine{1910   \textcolor{keyword}{static\_assert}(!detail::is\_named\_arg<T>(), \textcolor{stringliteral}{"{}nested named arguments"{}});}
\DoxyCodeLine{1911   \textcolor{keywordflow}{return} \{name, arg\};}
\DoxyCodeLine{1912 \}}
\DoxyCodeLine{1913 }
\DoxyCodeLine{1924 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}} \{}
\DoxyCodeLine{1925  \textcolor{keyword}{public}:}
\DoxyCodeLine{1926   \textcolor{keyword}{using }size\_type = int;}
\DoxyCodeLine{1927   \textcolor{keyword}{using }format\_arg = basic\_format\_arg<Context>;}
\DoxyCodeLine{1928 }
\DoxyCodeLine{1929  \textcolor{keyword}{private}:}
\DoxyCodeLine{1930   \textcolor{comment}{// A descriptor that contains information about formatting arguments.}}
\DoxyCodeLine{1931   \textcolor{comment}{// If the number of arguments is less or equal to max\_packed\_args then}}
\DoxyCodeLine{1932   \textcolor{comment}{// argument types are passed in the descriptor. This reduces binary code size}}
\DoxyCodeLine{1933   \textcolor{comment}{// per formatting function call.}}
\DoxyCodeLine{1934   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc\_;}
\DoxyCodeLine{1935   \textcolor{keyword}{union }\{}
\DoxyCodeLine{1936     \textcolor{comment}{// If is\_packed() returns true then argument values are stored in values\_;}}
\DoxyCodeLine{1937     \textcolor{comment}{// otherwise they are stored in args\_. This is done to improve cache}}
\DoxyCodeLine{1938     \textcolor{comment}{// locality and reduce compiled code size since storing larger objects}}
\DoxyCodeLine{1939     \textcolor{comment}{// may require more code (at least on x86-\/64) even if the same amount of}}
\DoxyCodeLine{1940     \textcolor{comment}{// data is actually copied to stack. It saves \string~10\% on the bloat test.}}
\DoxyCodeLine{1941     \textcolor{keyword}{const} detail::value<Context>* values\_;}
\DoxyCodeLine{1942     \textcolor{keyword}{const} format\_arg* args\_;}
\DoxyCodeLine{1943   \};}
\DoxyCodeLine{1944 }
\DoxyCodeLine{1945   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_packed() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1946     \textcolor{keywordflow}{return} (desc\_ \& detail::is\_unpacked\_bit) == 0;}
\DoxyCodeLine{1947   \}}
\DoxyCodeLine{1948   \textcolor{keyword}{auto} has\_named\_args() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1949     \textcolor{keywordflow}{return} (desc\_ \& detail::has\_named\_args\_bit) != 0;}
\DoxyCodeLine{1950   \}}
\DoxyCodeLine{1951 }
\DoxyCodeLine{1952   FMT\_CONSTEXPR \textcolor{keyword}{auto} type(\textcolor{keywordtype}{int} index) \textcolor{keyword}{const} -\/> detail::type \{}
\DoxyCodeLine{1953     \textcolor{keywordtype}{int} shift = index * detail::packed\_arg\_bits;}
\DoxyCodeLine{1954     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mask = (1 << detail::packed\_arg\_bits) -\/ 1;}
\DoxyCodeLine{1955     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}detail::type\textcolor{keyword}{>}((desc\_ >> shift) \& mask);}
\DoxyCodeLine{1956   \}}
\DoxyCodeLine{1957 }
\DoxyCodeLine{1958   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc,}
\DoxyCodeLine{1959                                          \textcolor{keyword}{const} detail::value<Context>* values)}
\DoxyCodeLine{1960       : desc\_(desc), values\_(values) \{\}}
\DoxyCodeLine{1961   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc, \textcolor{keyword}{const} format\_arg* args)}
\DoxyCodeLine{1962       : desc\_(desc), args\_(args) \{\}}
\DoxyCodeLine{1963 }
\DoxyCodeLine{1964  \textcolor{keyword}{public}:}
\DoxyCodeLine{1965   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}() : desc\_(0), args\_(\textcolor{keyword}{nullptr}) \{\}}
\DoxyCodeLine{1966 }
\DoxyCodeLine{1972   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1973   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classbasic__format__args_ac40bdd2deb4a1000df76553387588775}{basic\_format\_args}}(}
\DoxyCodeLine{1974       \textcolor{keyword}{const} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<Context, Args...>}}\& store)}
\DoxyCodeLine{1975       : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(\mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<Context, Args...>::desc,}
\DoxyCodeLine{1976                           store.data\_.args()) \{\}}
\DoxyCodeLine{1977 }
\DoxyCodeLine{1984   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classbasic__format__args_a69dd0f6fb0e95f42f57cc3bfb095a397}{basic\_format\_args}}(}
\DoxyCodeLine{1985       \textcolor{keyword}{const} \mbox{\hyperlink{classdynamic__format__arg__store}{dynamic\_format\_arg\_store<Context>}}\& store)}
\DoxyCodeLine{1986       : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(store.get\_types(), store.data()) \{\}}
\DoxyCodeLine{1987 }
\DoxyCodeLine{1993   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__args_a1b6a098d11577f454964b51c2d7f9027}{basic\_format\_args}}(\textcolor{keyword}{const} format\_arg* args, \textcolor{keywordtype}{int} count)}
\DoxyCodeLine{1994       : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(detail::is\_unpacked\_bit | detail::to\_unsigned(count),}
\DoxyCodeLine{1995                           args) \{\}}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1998   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \textcolor{keyword}{const} -\/> format\_arg \{}
\DoxyCodeLine{1999     format\_arg arg;}
\DoxyCodeLine{2000     \textcolor{keywordflow}{if} (!is\_packed()) \{}
\DoxyCodeLine{2001       \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} < max\_size()) arg = args\_[id];}
\DoxyCodeLine{2002       \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{2003     \}}
\DoxyCodeLine{2004     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= detail::max\_packed\_args) \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{2005     arg.type\_ = type(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2006     \textcolor{keywordflow}{if} (arg.type\_ == detail::type::none\_type) \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{2007     arg.value\_ = values\_[id];}
\DoxyCodeLine{2008     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{2009   \}}
\DoxyCodeLine{2010 }
\DoxyCodeLine{2011   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2012   \textcolor{keyword}{auto} get(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) \textcolor{keyword}{const} -\/> format\_arg \{}
\DoxyCodeLine{2013     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = get\_id(name);}
\DoxyCodeLine{2014     \textcolor{keywordflow}{return} \textcolor{keywordtype}{id} >= 0 ? get(\textcolor{keywordtype}{id}) : format\_arg();}
\DoxyCodeLine{2015   \}}
\DoxyCodeLine{2016 }
\DoxyCodeLine{2017   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2018   \textcolor{keyword}{auto} get\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2019     \textcolor{keywordflow}{if} (!has\_named\_args()) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2020     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& named\_args =}
\DoxyCodeLine{2021         (is\_packed() ? values\_[-\/1] : args\_[-\/1].value\_).named\_args;}
\DoxyCodeLine{2022     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < named\_args.size; ++i) \{}
\DoxyCodeLine{2023       \textcolor{keywordflow}{if} (named\_args.data[i].name == name) \textcolor{keywordflow}{return} named\_args.data[i].id;}
\DoxyCodeLine{2024     \}}
\DoxyCodeLine{2025     \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2026   \}}
\DoxyCodeLine{2027 }
\DoxyCodeLine{2028   \textcolor{keyword}{auto} max\_size() const -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2029     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} max\_packed = detail::max\_packed\_args;}
\DoxyCodeLine{2030     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(is\_packed() ? max\_packed}
\DoxyCodeLine{2031                                         : desc\_ \& \string~detail::is\_unpacked\_bit);}
\DoxyCodeLine{2032   \}}
\DoxyCodeLine{2033 \};}
\DoxyCodeLine{2034 }
\DoxyCodeLine{2036 \textcolor{comment}{// A separate type would result in shorter symbols but break ABI compatibility}}
\DoxyCodeLine{2037 \textcolor{comment}{// between clang and gcc on ARM (\#1919).}}
\DoxyCodeLine{2038 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{format\_args}} = \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<format\_context>}};}
\DoxyCodeLine{2039 }
\DoxyCodeLine{2040 \textcolor{comment}{// We cannot use enum classes as bit fields because of a gcc bug, so we put them}}
\DoxyCodeLine{2041 \textcolor{comment}{// in namespaces instead (https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=61414).}}
\DoxyCodeLine{2042 \textcolor{comment}{// Additionally, if an underlying type is specified, older gcc incorrectly warns}}
\DoxyCodeLine{2043 \textcolor{comment}{// that the type is too small. Both bugs are fixed in gcc 9.3.}}
\DoxyCodeLine{2044 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 903}}
\DoxyCodeLine{2045 \textcolor{preprocessor}{\#  define FMT\_ENUM\_UNDERLYING\_TYPE(type)}}
\DoxyCodeLine{2046 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2047 \textcolor{preprocessor}{\#  define FMT\_ENUM\_UNDERLYING\_TYPE(type) : type}}
\DoxyCodeLine{2048 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2049 \textcolor{keyword}{namespace }align \{}
\DoxyCodeLine{2050 \textcolor{keyword}{enum} type FMT\_ENUM\_UNDERLYING\_TYPE(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})\{none, left, right, center,}
\DoxyCodeLine{2051                                                   numeric\};}
\DoxyCodeLine{2052 \}}
\DoxyCodeLine{2053 \textcolor{keyword}{using }align\_t = align::type;}
\DoxyCodeLine{2054 \textcolor{keyword}{namespace }sign \{}
\DoxyCodeLine{2055 \textcolor{keyword}{enum} type FMT\_ENUM\_UNDERLYING\_TYPE(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})\{none, minus, plus, space\};}
\DoxyCodeLine{2056 \}}
\DoxyCodeLine{2057 \textcolor{keyword}{using }sign\_t = sign::type;}
\DoxyCodeLine{2058 }
\DoxyCodeLine{2059 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061 \textcolor{comment}{// Workaround an array initialization issue in gcc 4.8.}}
\DoxyCodeLine{2062 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }fill\_t \{}
\DoxyCodeLine{2063  \textcolor{keyword}{private}:}
\DoxyCodeLine{2064   \textcolor{keyword}{enum} \{ max\_size = 4 \};}
\DoxyCodeLine{2065   Char data\_[max\_size] = \{Char(\textcolor{charliteral}{' '}), Char(0), Char(0), Char(0)\};}
\DoxyCodeLine{2066   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} size\_ = 1;}
\DoxyCodeLine{2067 }
\DoxyCodeLine{2068  \textcolor{keyword}{public}:}
\DoxyCodeLine{2069   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s) \{}
\DoxyCodeLine{2070     \textcolor{keyword}{auto} size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{2071     \textcolor{keywordflow}{if} (size > max\_size) \textcolor{keywordflow}{return} throw\_format\_error(\textcolor{stringliteral}{"{}invalid fill"{}});}
\DoxyCodeLine{2072     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i) data\_[i] = s[i];}
\DoxyCodeLine{2073     size\_ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(size);}
\DoxyCodeLine{2074   \}}
\DoxyCodeLine{2075 }
\DoxyCodeLine{2076   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{2077   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} data() const -\/> const Char* \{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{2078 }
\DoxyCodeLine{2079   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](\textcolor{keywordtype}{size\_t} index) -\/> Char\& \{ \textcolor{keywordflow}{return} data\_[index]; \}}
\DoxyCodeLine{2080   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](\textcolor{keywordtype}{size\_t} index) \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} Char\& \{}
\DoxyCodeLine{2081     \textcolor{keywordflow}{return} data\_[index];}
\DoxyCodeLine{2082   \}}
\DoxyCodeLine{2083 \};}
\DoxyCodeLine{2084 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{2085 }
\DoxyCodeLine{2086 \textcolor{keyword}{enum class} presentation\_type : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{2087   none,}
\DoxyCodeLine{2088   \textcolor{comment}{// Integer types should go first,}}
\DoxyCodeLine{2089   dec,             \textcolor{comment}{// 'd'}}
\DoxyCodeLine{2090   oct,             \textcolor{comment}{// 'o'}}
\DoxyCodeLine{2091   hex\_lower,       \textcolor{comment}{// 'x'}}
\DoxyCodeLine{2092   hex\_upper,       \textcolor{comment}{// 'X'}}
\DoxyCodeLine{2093   bin\_lower,       \textcolor{comment}{// 'b'}}
\DoxyCodeLine{2094   bin\_upper,       \textcolor{comment}{// 'B'}}
\DoxyCodeLine{2095   hexfloat\_lower,  \textcolor{comment}{// 'a'}}
\DoxyCodeLine{2096   hexfloat\_upper,  \textcolor{comment}{// 'A'}}
\DoxyCodeLine{2097   exp\_lower,       \textcolor{comment}{// 'e'}}
\DoxyCodeLine{2098   exp\_upper,       \textcolor{comment}{// 'E'}}
\DoxyCodeLine{2099   fixed\_lower,     \textcolor{comment}{// 'f'}}
\DoxyCodeLine{2100   fixed\_upper,     \textcolor{comment}{// 'F'}}
\DoxyCodeLine{2101   general\_lower,   \textcolor{comment}{// 'g'}}
\DoxyCodeLine{2102   general\_upper,   \textcolor{comment}{// 'G'}}
\DoxyCodeLine{2103   chr,             \textcolor{comment}{// 'c'}}
\DoxyCodeLine{2104   string,          \textcolor{comment}{// 's'}}
\DoxyCodeLine{2105   pointer,         \textcolor{comment}{// 'p'}}
\DoxyCodeLine{2106   debug            \textcolor{comment}{// '?'}}
\DoxyCodeLine{2107 \};}
\DoxyCodeLine{2108 }
\DoxyCodeLine{2109 \textcolor{comment}{// Format specifiers for built-\/in and string types.}}
\DoxyCodeLine{2110 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }basic\_format\_specs \{}
\DoxyCodeLine{2111   \textcolor{keywordtype}{int} width;}
\DoxyCodeLine{2112   \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{2113   presentation\_type type;}
\DoxyCodeLine{2114   align\_t align : 4;}
\DoxyCodeLine{2115   sign\_t sign : 3;}
\DoxyCodeLine{2116   \textcolor{keywordtype}{bool} alt : 1;  \textcolor{comment}{// Alternate form ('\#').}}
\DoxyCodeLine{2117   \textcolor{keywordtype}{bool} localized : 1;}
\DoxyCodeLine{2118   detail::fill\_t<Char> fill;}
\DoxyCodeLine{2119 }
\DoxyCodeLine{2120   \textcolor{keyword}{constexpr} basic\_format\_specs()}
\DoxyCodeLine{2121       : width(0),}
\DoxyCodeLine{2122         precision(-\/1),}
\DoxyCodeLine{2123         type(presentation\_type::none),}
\DoxyCodeLine{2124         align(align::none),}
\DoxyCodeLine{2125         sign(sign::none),}
\DoxyCodeLine{2126         alt(false),}
\DoxyCodeLine{2127         localized(false) \{\}}
\DoxyCodeLine{2128 \};}
\DoxyCodeLine{2129 }
\DoxyCodeLine{2130 \textcolor{keyword}{using }format\_specs = basic\_format\_specs<char>;}
\DoxyCodeLine{2131 }
\DoxyCodeLine{2132 FMT\_BEGIN\_DETAIL\_NAMESPACE}
\DoxyCodeLine{2133 }
\DoxyCodeLine{2134 \textcolor{keyword}{enum class} arg\_id\_kind \{ none, index, name \};}
\DoxyCodeLine{2135 }
\DoxyCodeLine{2136 \textcolor{comment}{// An argument reference.}}
\DoxyCodeLine{2137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }arg\_ref \{}
\DoxyCodeLine{2138   FMT\_CONSTEXPR arg\_ref() : kind(arg\_id\_kind::none), val() \{\}}
\DoxyCodeLine{2139 }
\DoxyCodeLine{2140   FMT\_CONSTEXPR \textcolor{keyword}{explicit} arg\_ref(\textcolor{keywordtype}{int} index)}
\DoxyCodeLine{2141       : kind(arg\_id\_kind::index), val(index) \{\}}
\DoxyCodeLine{2142   FMT\_CONSTEXPR \textcolor{keyword}{explicit} arg\_ref(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name)}
\DoxyCodeLine{2143       : kind(arg\_id\_kind::name), val(name) \{\}}
\DoxyCodeLine{2144 }
\DoxyCodeLine{2145   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator=(\textcolor{keywordtype}{int} idx) -\/> arg\_ref\& \{}
\DoxyCodeLine{2146     kind = arg\_id\_kind::index;}
\DoxyCodeLine{2147     val.index = idx;}
\DoxyCodeLine{2148     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2149   \}}
\DoxyCodeLine{2150 }
\DoxyCodeLine{2151   arg\_id\_kind kind;}
\DoxyCodeLine{2152   \textcolor{keyword}{union }value \{}
\DoxyCodeLine{2153     FMT\_CONSTEXPR value(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = 0) : index\{id\} \{\}}
\DoxyCodeLine{2154     FMT\_CONSTEXPR value(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} n) : name(n) \{\}}
\DoxyCodeLine{2155 }
\DoxyCodeLine{2156     \textcolor{keywordtype}{int} index;}
\DoxyCodeLine{2157     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name;}
\DoxyCodeLine{2158   \} val;}
\DoxyCodeLine{2159 \};}
\DoxyCodeLine{2160 }
\DoxyCodeLine{2161 \textcolor{comment}{// Format specifiers with width and precision resolved at formatting rather}}
\DoxyCodeLine{2162 \textcolor{comment}{// than parsing time to allow re-\/using the same parsed specifiers with}}
\DoxyCodeLine{2163 \textcolor{comment}{// different sets of arguments (precompilation of format strings).}}
\DoxyCodeLine{2164 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2165 \textcolor{keyword}{struct }dynamic\_format\_specs : basic\_format\_specs<Char> \{}
\DoxyCodeLine{2166   arg\_ref<Char> width\_ref;}
\DoxyCodeLine{2167   arg\_ref<Char> precision\_ref;}
\DoxyCodeLine{2168 \};}
\DoxyCodeLine{2169 }
\DoxyCodeLine{2170 \textcolor{keyword}{struct }auto\_id \{\};}
\DoxyCodeLine{2171 }
\DoxyCodeLine{2172 \textcolor{comment}{// A format specifier handler that sets fields in basic\_format\_specs.}}
\DoxyCodeLine{2173 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }specs\_setter \{}
\DoxyCodeLine{2174  \textcolor{keyword}{protected}:}
\DoxyCodeLine{2175   basic\_format\_specs<Char>\& specs\_;}
\DoxyCodeLine{2176 }
\DoxyCodeLine{2177  \textcolor{keyword}{public}:}
\DoxyCodeLine{2178   \textcolor{keyword}{explicit} FMT\_CONSTEXPR specs\_setter(basic\_format\_specs<Char>\& specs)}
\DoxyCodeLine{2179       : specs\_(specs) \{\}}
\DoxyCodeLine{2180 }
\DoxyCodeLine{2181   FMT\_CONSTEXPR specs\_setter(\textcolor{keyword}{const} specs\_setter\& other)}
\DoxyCodeLine{2182       : specs\_(other.specs\_) \{\}}
\DoxyCodeLine{2183 }
\DoxyCodeLine{2184   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_align(align\_t align) \{ specs\_.align = align; \}}
\DoxyCodeLine{2185   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_fill(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fill) \{}
\DoxyCodeLine{2186     specs\_.fill = fill;}
\DoxyCodeLine{2187   \}}
\DoxyCodeLine{2188   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_sign(sign\_t s) \{ specs\_.sign = s; \}}
\DoxyCodeLine{2189   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_hash() \{ specs\_.alt = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2190   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_localized() \{ specs\_.localized = \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2191 }
\DoxyCodeLine{2192   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_zero() \{}
\DoxyCodeLine{2193     \textcolor{keywordflow}{if} (specs\_.align == align::none) specs\_.align = align::numeric;}
\DoxyCodeLine{2194     specs\_.fill[0] = Char(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{2195   \}}
\DoxyCodeLine{2196 }
\DoxyCodeLine{2197   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_width(\textcolor{keywordtype}{int} width) \{ specs\_.width = width; \}}
\DoxyCodeLine{2198   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_precision(\textcolor{keywordtype}{int} precision) \{}
\DoxyCodeLine{2199     specs\_.precision = precision;}
\DoxyCodeLine{2200   \}}
\DoxyCodeLine{2201   FMT\_CONSTEXPR \textcolor{keywordtype}{void} end\_precision() \{\}}
\DoxyCodeLine{2202 }
\DoxyCodeLine{2203   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_type(presentation\_type type) \{ specs\_.type = type; \}}
\DoxyCodeLine{2204 \};}
\DoxyCodeLine{2205 }
\DoxyCodeLine{2206 \textcolor{comment}{// Format spec handler that saves references to arguments representing dynamic}}
\DoxyCodeLine{2207 \textcolor{comment}{// width and precision to be resolved at formatting time.}}
\DoxyCodeLine{2208 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2209 \textcolor{keyword}{class }dynamic\_specs\_handler}
\DoxyCodeLine{2210     : \textcolor{keyword}{public} specs\_setter<typename ParseContext::char\_type> \{}
\DoxyCodeLine{2211  \textcolor{keyword}{public}:}
\DoxyCodeLine{2212   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} ParseContext::char\_type;}
\DoxyCodeLine{2213 }
\DoxyCodeLine{2214   FMT\_CONSTEXPR dynamic\_specs\_handler(dynamic\_format\_specs<char\_type>\& specs,}
\DoxyCodeLine{2215                                       ParseContext\& ctx)}
\DoxyCodeLine{2216       : specs\_setter<char\_type>(specs), specs\_(specs), context\_(ctx) \{\}}
\DoxyCodeLine{2217 }
\DoxyCodeLine{2218   FMT\_CONSTEXPR dynamic\_specs\_handler(\textcolor{keyword}{const} dynamic\_specs\_handler\& other)}
\DoxyCodeLine{2219       : specs\_setter<char\_type>(other),}
\DoxyCodeLine{2220         specs\_(other.specs\_),}
\DoxyCodeLine{2221         context\_(other.context\_) \{\}}
\DoxyCodeLine{2222 }
\DoxyCodeLine{2223   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_width(Id arg\_id) \{}
\DoxyCodeLine{2224     specs\_.width\_ref = make\_arg\_ref(arg\_id);}
\DoxyCodeLine{2225   \}}
\DoxyCodeLine{2226 }
\DoxyCodeLine{2227   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id> FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_precision(Id arg\_id) \{}
\DoxyCodeLine{2228     specs\_.precision\_ref = make\_arg\_ref(arg\_id);}
\DoxyCodeLine{2229   \}}
\DoxyCodeLine{2230 }
\DoxyCodeLine{2231   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{2232     context\_.on\_error(message);}
\DoxyCodeLine{2233   \}}
\DoxyCodeLine{2234 }
\DoxyCodeLine{2235  \textcolor{keyword}{private}:}
\DoxyCodeLine{2236   dynamic\_format\_specs<char\_type>\& specs\_;}
\DoxyCodeLine{2237   ParseContext\& context\_;}
\DoxyCodeLine{2238 }
\DoxyCodeLine{2239   \textcolor{keyword}{using }arg\_ref\_type = arg\_ref<char\_type>;}
\DoxyCodeLine{2240 }
\DoxyCodeLine{2241   FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_arg\_ref(\textcolor{keywordtype}{int} arg\_id) -\/> arg\_ref\_type \{}
\DoxyCodeLine{2242     context\_.check\_arg\_id(arg\_id);}
\DoxyCodeLine{2243     \textcolor{keywordflow}{return} arg\_ref\_type(arg\_id);}
\DoxyCodeLine{2244   \}}
\DoxyCodeLine{2245 }
\DoxyCodeLine{2246   FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_arg\_ref(auto\_id) -\/> arg\_ref\_type \{}
\DoxyCodeLine{2247     \textcolor{keywordflow}{return} arg\_ref\_type(context\_.next\_arg\_id());}
\DoxyCodeLine{2248   \}}
\DoxyCodeLine{2249 }
\DoxyCodeLine{2250   FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_arg\_ref(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} arg\_id)}
\DoxyCodeLine{2251       -\/> arg\_ref\_type \{}
\DoxyCodeLine{2252     context\_.check\_arg\_id(arg\_id);}
\DoxyCodeLine{2253     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} format\_str(}
\DoxyCodeLine{2254         context\_.begin(), to\_unsigned(context\_.end() -\/ context\_.begin()));}
\DoxyCodeLine{2255     \textcolor{keywordflow}{return} arg\_ref\_type(arg\_id);}
\DoxyCodeLine{2256   \}}
\DoxyCodeLine{2257 \};}
\DoxyCodeLine{2258 }
\DoxyCodeLine{2259 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_ascii\_letter(Char c) \{}
\DoxyCodeLine{2260   \textcolor{keywordflow}{return} (c >= \textcolor{charliteral}{'a'} \&\& c <= \textcolor{charliteral}{'z'}) || (c >= \textcolor{charliteral}{'A'} \&\& c <= \textcolor{charliteral}{'Z'});}
\DoxyCodeLine{2261 \}}
\DoxyCodeLine{2262 }
\DoxyCodeLine{2263 \textcolor{comment}{// Converts a character to ASCII. Returns a number > 127 on conversion failure.}}
\DoxyCodeLine{2264 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<Char>::value)>}
\DoxyCodeLine{2265 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_ascii(Char c) -\/> Char \{}
\DoxyCodeLine{2266   \textcolor{keywordflow}{return} c;}
\DoxyCodeLine{2267 \}}
\DoxyCodeLine{2268 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, FMT\_ENABLE\_IF(std::is\_enum<Char>::value)>}
\DoxyCodeLine{2269 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_ascii(Char c) -\/> underlying\_t<Char> \{}
\DoxyCodeLine{2270   \textcolor{keywordflow}{return} c;}
\DoxyCodeLine{2271 \}}
\DoxyCodeLine{2272 }
\DoxyCodeLine{2273 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2274 FMT\_CONSTEXPR \textcolor{keyword}{auto} code\_point\_length(\textcolor{keyword}{const} Char* begin) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2275   \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(Char) != 1)) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2276   \textcolor{keyword}{auto} lengths =}
\DoxyCodeLine{2277       \textcolor{stringliteral}{"{}\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)2\(\backslash\)2\(\backslash\)2\(\backslash\)2\(\backslash\)3\(\backslash\)3\(\backslash\)4"{}};}
\DoxyCodeLine{2278   \textcolor{keywordtype}{int} len = lengths[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(*begin) >> 3];}
\DoxyCodeLine{2279 }
\DoxyCodeLine{2280   \textcolor{comment}{// Compute the pointer to the next character early so that the next}}
\DoxyCodeLine{2281   \textcolor{comment}{// iteration can start working on the next character. Neither Clang}}
\DoxyCodeLine{2282   \textcolor{comment}{// nor GCC figure out this reordering on their own.}}
\DoxyCodeLine{2283   \textcolor{keywordflow}{return} len + !len;}
\DoxyCodeLine{2284 \}}
\DoxyCodeLine{2285 }
\DoxyCodeLine{2286 \textcolor{comment}{// Return the result via the out param to workaround gcc bug 77539.}}
\DoxyCodeLine{2287 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_CONSTEXPR, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Ptr = const T*>}
\DoxyCodeLine{2288 FMT\_CONSTEXPR \textcolor{keyword}{auto} find(Ptr first, Ptr last, T value, Ptr\& out) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2289   \textcolor{keywordflow}{for} (out = first; out != last; ++out) \{}
\DoxyCodeLine{2290     \textcolor{keywordflow}{if} (*out == value) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2291   \}}
\DoxyCodeLine{2292   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2293 \}}
\DoxyCodeLine{2294 }
\DoxyCodeLine{2295 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2296 \textcolor{keyword}{inline} \textcolor{keyword}{auto} find<false, char>(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* first, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* last, \textcolor{keywordtype}{char} value,}
\DoxyCodeLine{2297                               \textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& out) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2298   out = \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(}
\DoxyCodeLine{2299       std::memchr(first, value, to\_unsigned(last -\/ first)));}
\DoxyCodeLine{2300   \textcolor{keywordflow}{return} out != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2301 \}}
\DoxyCodeLine{2302 }
\DoxyCodeLine{2303 \textcolor{comment}{// Parses the range [begin, end) as an unsigned integer. This function assumes}}
\DoxyCodeLine{2304 \textcolor{comment}{// that the range is non-\/empty and the first character is a digit.}}
\DoxyCodeLine{2305 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2306 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_nonnegative\_int(\textcolor{keyword}{const} Char*\& begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2307                                          \textcolor{keywordtype}{int} error\_value) \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2308   FMT\_ASSERT(begin != end \&\& \textcolor{charliteral}{'0'} <= *begin \&\& *begin <= \textcolor{charliteral}{'9'}, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2309   \textcolor{keywordtype}{unsigned} value = 0, prev = 0;}
\DoxyCodeLine{2310   \textcolor{keyword}{auto} p = begin;}
\DoxyCodeLine{2311   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2312     prev = value;}
\DoxyCodeLine{2313     value = value * 10 + unsigned(*p -\/ \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2314     ++p;}
\DoxyCodeLine{2315   \} \textcolor{keywordflow}{while} (p != end \&\& \textcolor{charliteral}{'0'} <= *p \&\& *p <= \textcolor{charliteral}{'9'});}
\DoxyCodeLine{2316   \textcolor{keyword}{auto} num\_digits = p -\/ begin;}
\DoxyCodeLine{2317   begin = p;}
\DoxyCodeLine{2318   \textcolor{keywordflow}{if} (num\_digits <= std::numeric\_limits<int>::digits10)}
\DoxyCodeLine{2319     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2320   \textcolor{comment}{// Check for overflow.}}
\DoxyCodeLine{2321   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} max = to\_unsigned((std::numeric\_limits<int>::max)());}
\DoxyCodeLine{2322   \textcolor{keywordflow}{return} num\_digits == std::numeric\_limits<int>::digits10 + 1 \&\&}
\DoxyCodeLine{2323                  prev * 10ull + unsigned(p[-\/1] -\/ \textcolor{charliteral}{'0'}) <= max}
\DoxyCodeLine{2324              ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value)}
\DoxyCodeLine{2325              : error\_value;}
\DoxyCodeLine{2326 \}}
\DoxyCodeLine{2327 }
\DoxyCodeLine{2328 \textcolor{comment}{// Parses fill and alignment.}}
\DoxyCodeLine{2329 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2330 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_align(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2331                                Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2332   FMT\_ASSERT(begin != end, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2333   \textcolor{keyword}{auto} align = align::none;}
\DoxyCodeLine{2334   \textcolor{keyword}{auto} p = begin + code\_point\_length(begin);}
\DoxyCodeLine{2335   \textcolor{keywordflow}{if} (end -\/ p <= 0) p = begin;}
\DoxyCodeLine{2336   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2337     \textcolor{keywordflow}{switch} (to\_ascii(*p)) \{}
\DoxyCodeLine{2338     \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:}
\DoxyCodeLine{2339       align = align::left;}
\DoxyCodeLine{2340       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2341     \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{2342       align = align::right;}
\DoxyCodeLine{2343       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2344     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string^'}:}
\DoxyCodeLine{2345       align = align::center;}
\DoxyCodeLine{2346       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2347     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2348       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2349     \}}
\DoxyCodeLine{2350     \textcolor{keywordflow}{if} (align != align::none) \{}
\DoxyCodeLine{2351       \textcolor{keywordflow}{if} (p != begin) \{}
\DoxyCodeLine{2352         \textcolor{keyword}{auto} c = *begin;}
\DoxyCodeLine{2353         \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\{'})}
\DoxyCodeLine{2354           \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid fill character '\{'"{}}), begin;}
\DoxyCodeLine{2355         handler.on\_fill(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(begin, to\_unsigned(p -\/ begin)));}
\DoxyCodeLine{2356         begin = p + 1;}
\DoxyCodeLine{2357       \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{2358         ++begin;}
\DoxyCodeLine{2359       handler.on\_align(align);}
\DoxyCodeLine{2360       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2361     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (p == begin) \{}
\DoxyCodeLine{2362       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2363     \}}
\DoxyCodeLine{2364     p = begin;}
\DoxyCodeLine{2365   \}}
\DoxyCodeLine{2366   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2367 \}}
\DoxyCodeLine{2368 }
\DoxyCodeLine{2369 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> FMT\_CONSTEXPR \textcolor{keywordtype}{bool} is\_name\_start(Char c) \{}
\DoxyCodeLine{2370   \textcolor{keywordflow}{return} (\textcolor{charliteral}{'a'} <= c \&\& c <= \textcolor{charliteral}{'z'}) || (\textcolor{charliteral}{'A'} <= c \&\& c <= \textcolor{charliteral}{'Z'}) || \textcolor{charliteral}{'\_'} == c;}
\DoxyCodeLine{2371 \}}
\DoxyCodeLine{2372 }
\DoxyCodeLine{2373 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} IDHandler>}
\DoxyCodeLine{2374 FMT\_CONSTEXPR \textcolor{keyword}{auto} do\_parse\_arg\_id(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2375                                    IDHandler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2376   FMT\_ASSERT(begin != end, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2377   Char c = *begin;}
\DoxyCodeLine{2378   \textcolor{keywordflow}{if} (c >= \textcolor{charliteral}{'0'} \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2379     \textcolor{keywordtype}{int} index = 0;}
\DoxyCodeLine{2380     \textcolor{keywordflow}{if} (c != \textcolor{charliteral}{'0'})}
\DoxyCodeLine{2381       index =}
\DoxyCodeLine{2382           parse\_nonnegative\_int(begin, end, (std::numeric\_limits<int>::max)());}
\DoxyCodeLine{2383     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2384       ++begin;}
\DoxyCodeLine{2385     \textcolor{keywordflow}{if} (begin == end || (*begin != \textcolor{charliteral}{'\}'} \&\& *begin != \textcolor{charliteral}{':'}))}
\DoxyCodeLine{2386       handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2387     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2388       handler(index);}
\DoxyCodeLine{2389     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2390   \}}
\DoxyCodeLine{2391   \textcolor{keywordflow}{if} (!is\_name\_start(c)) \{}
\DoxyCodeLine{2392     handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2393     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2394   \}}
\DoxyCodeLine{2395   \textcolor{keyword}{auto} it = begin;}
\DoxyCodeLine{2396   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2397     ++it;}
\DoxyCodeLine{2398   \} \textcolor{keywordflow}{while} (it != end \&\& (is\_name\_start(c = *it) || (\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'})));}
\DoxyCodeLine{2399   handler(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(begin, to\_unsigned(it -\/ begin)));}
\DoxyCodeLine{2400   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2401 \}}
\DoxyCodeLine{2402 }
\DoxyCodeLine{2403 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} IDHandler>}
\DoxyCodeLine{2404 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} parse\_arg\_id(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2405                                            IDHandler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2406   Char c = *begin;}
\DoxyCodeLine{2407   \textcolor{keywordflow}{if} (c != \textcolor{charliteral}{'\}'} \&\& c != \textcolor{charliteral}{':'}) \textcolor{keywordflow}{return} do\_parse\_arg\_id(begin, end, handler);}
\DoxyCodeLine{2408   handler();}
\DoxyCodeLine{2409   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2410 \}}
\DoxyCodeLine{2411 }
\DoxyCodeLine{2412 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2413 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_width(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2414                                Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2415   \textcolor{keyword}{using }detail::auto\_id;}
\DoxyCodeLine{2416   \textcolor{keyword}{struct }width\_adapter \{}
\DoxyCodeLine{2417     Handler\& handler;}
\DoxyCodeLine{2418 }
\DoxyCodeLine{2419     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()() \{ handler.on\_dynamic\_width(auto\_id()); \}}
\DoxyCodeLine{2420     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{ handler.on\_dynamic\_width(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{2421     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2422       handler.on\_dynamic\_width(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2423     \}}
\DoxyCodeLine{2424     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{2425       \textcolor{keywordflow}{if} (message) handler.on\_error(message);}
\DoxyCodeLine{2426     \}}
\DoxyCodeLine{2427   \};}
\DoxyCodeLine{2428 }
\DoxyCodeLine{2429   FMT\_ASSERT(begin != end, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2430   \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= *begin \&\& *begin <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2431     \textcolor{keywordtype}{int} width = parse\_nonnegative\_int(begin, end, -\/1);}
\DoxyCodeLine{2432     \textcolor{keywordflow}{if} (width != -\/1)}
\DoxyCodeLine{2433       handler.on\_width(width);}
\DoxyCodeLine{2434     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2435       handler.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{2436   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2437     ++begin;}
\DoxyCodeLine{2438     \textcolor{keywordflow}{if} (begin != end) begin = parse\_arg\_id(begin, end, width\_adapter\{handler\});}
\DoxyCodeLine{2439     \textcolor{keywordflow}{if} (begin == end || *begin != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2440       \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}}), begin;}
\DoxyCodeLine{2441     ++begin;}
\DoxyCodeLine{2442   \}}
\DoxyCodeLine{2443   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2444 \}}
\DoxyCodeLine{2445 }
\DoxyCodeLine{2446 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2447 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_precision(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2448                                    Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2449   \textcolor{keyword}{using }detail::auto\_id;}
\DoxyCodeLine{2450   \textcolor{keyword}{struct }precision\_adapter \{}
\DoxyCodeLine{2451     Handler\& handler;}
\DoxyCodeLine{2452 }
\DoxyCodeLine{2453     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()() \{ handler.on\_dynamic\_precision(auto\_id()); \}}
\DoxyCodeLine{2454     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{ handler.on\_dynamic\_precision(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{2455     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2456       handler.on\_dynamic\_precision(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2457     \}}
\DoxyCodeLine{2458     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{2459       \textcolor{keywordflow}{if} (message) handler.on\_error(message);}
\DoxyCodeLine{2460     \}}
\DoxyCodeLine{2461   \};}
\DoxyCodeLine{2462 }
\DoxyCodeLine{2463   ++begin;}
\DoxyCodeLine{2464   \textcolor{keyword}{auto} c = begin != end ? *begin : Char();}
\DoxyCodeLine{2465   \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2466     \textcolor{keyword}{auto} precision = parse\_nonnegative\_int(begin, end, -\/1);}
\DoxyCodeLine{2467     \textcolor{keywordflow}{if} (precision != -\/1)}
\DoxyCodeLine{2468       handler.on\_precision(precision);}
\DoxyCodeLine{2469     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2470       handler.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{2471   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2472     ++begin;}
\DoxyCodeLine{2473     \textcolor{keywordflow}{if} (begin != end)}
\DoxyCodeLine{2474       begin = parse\_arg\_id(begin, end, precision\_adapter\{handler\});}
\DoxyCodeLine{2475     \textcolor{keywordflow}{if} (begin == end || *begin++ != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2476       \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}}), begin;}
\DoxyCodeLine{2477   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2478     \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}missing precision specifier"{}}), begin;}
\DoxyCodeLine{2479   \}}
\DoxyCodeLine{2480   handler.end\_precision();}
\DoxyCodeLine{2481   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2482 \}}
\DoxyCodeLine{2483 }
\DoxyCodeLine{2484 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2485 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_presentation\_type(Char type) -\/> presentation\_type \{}
\DoxyCodeLine{2486   \textcolor{keywordflow}{switch} (to\_ascii(type)) \{}
\DoxyCodeLine{2487   \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{2488     \textcolor{keywordflow}{return} presentation\_type::dec;}
\DoxyCodeLine{2489   \textcolor{keywordflow}{case} \textcolor{charliteral}{'o'}:}
\DoxyCodeLine{2490     \textcolor{keywordflow}{return} presentation\_type::oct;}
\DoxyCodeLine{2491   \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}:}
\DoxyCodeLine{2492     \textcolor{keywordflow}{return} presentation\_type::hex\_lower;}
\DoxyCodeLine{2493   \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}:}
\DoxyCodeLine{2494     \textcolor{keywordflow}{return} presentation\_type::hex\_upper;}
\DoxyCodeLine{2495   \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'}:}
\DoxyCodeLine{2496     \textcolor{keywordflow}{return} presentation\_type::bin\_lower;}
\DoxyCodeLine{2497   \textcolor{keywordflow}{case} \textcolor{charliteral}{'B'}:}
\DoxyCodeLine{2498     \textcolor{keywordflow}{return} presentation\_type::bin\_upper;}
\DoxyCodeLine{2499   \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}:}
\DoxyCodeLine{2500     \textcolor{keywordflow}{return} presentation\_type::hexfloat\_lower;}
\DoxyCodeLine{2501   \textcolor{keywordflow}{case} \textcolor{charliteral}{'A'}:}
\DoxyCodeLine{2502     \textcolor{keywordflow}{return} presentation\_type::hexfloat\_upper;}
\DoxyCodeLine{2503   \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{2504     \textcolor{keywordflow}{return} presentation\_type::exp\_lower;}
\DoxyCodeLine{2505   \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{2506     \textcolor{keywordflow}{return} presentation\_type::exp\_upper;}
\DoxyCodeLine{2507   \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}:}
\DoxyCodeLine{2508     \textcolor{keywordflow}{return} presentation\_type::fixed\_lower;}
\DoxyCodeLine{2509   \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:}
\DoxyCodeLine{2510     \textcolor{keywordflow}{return} presentation\_type::fixed\_upper;}
\DoxyCodeLine{2511   \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}:}
\DoxyCodeLine{2512     \textcolor{keywordflow}{return} presentation\_type::general\_lower;}
\DoxyCodeLine{2513   \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:}
\DoxyCodeLine{2514     \textcolor{keywordflow}{return} presentation\_type::general\_upper;}
\DoxyCodeLine{2515   \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}:}
\DoxyCodeLine{2516     \textcolor{keywordflow}{return} presentation\_type::chr;}
\DoxyCodeLine{2517   \textcolor{keywordflow}{case} \textcolor{charliteral}{'s'}:}
\DoxyCodeLine{2518     \textcolor{keywordflow}{return} presentation\_type::string;}
\DoxyCodeLine{2519   \textcolor{keywordflow}{case} \textcolor{charliteral}{'p'}:}
\DoxyCodeLine{2520     \textcolor{keywordflow}{return} presentation\_type::pointer;}
\DoxyCodeLine{2521   \textcolor{keywordflow}{case} \textcolor{charliteral}{'?'}:}
\DoxyCodeLine{2522     \textcolor{keywordflow}{return} presentation\_type::debug;}
\DoxyCodeLine{2523   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2524     \textcolor{keywordflow}{return} presentation\_type::none;}
\DoxyCodeLine{2525   \}}
\DoxyCodeLine{2526 \}}
\DoxyCodeLine{2527 }
\DoxyCodeLine{2528 \textcolor{comment}{// Parses standard format specifiers and sends notifications about parsed}}
\DoxyCodeLine{2529 \textcolor{comment}{// components to handler.}}
\DoxyCodeLine{2530 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} SpecHandler>}
\DoxyCodeLine{2531 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} parse\_format\_specs(\textcolor{keyword}{const} Char* begin,}
\DoxyCodeLine{2532                                                  \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2533                                                  SpecHandler\&\& handler)}
\DoxyCodeLine{2534     -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2535   \textcolor{keywordflow}{if} (1 < end -\/ begin \&\& begin[1] == \textcolor{charliteral}{'\}'} \&\& is\_ascii\_letter(*begin) \&\&}
\DoxyCodeLine{2536       *begin != \textcolor{charliteral}{'L'}) \{}
\DoxyCodeLine{2537     presentation\_type type = parse\_presentation\_type(*begin++);}
\DoxyCodeLine{2538     \textcolor{keywordflow}{if} (type == presentation\_type::none)}
\DoxyCodeLine{2539       handler.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2540     handler.on\_type(type);}
\DoxyCodeLine{2541     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2542   \}}
\DoxyCodeLine{2543 }
\DoxyCodeLine{2544   \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2545 }
\DoxyCodeLine{2546   begin = parse\_align(begin, end, handler);}
\DoxyCodeLine{2547   \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2548 }
\DoxyCodeLine{2549   \textcolor{comment}{// Parse sign.}}
\DoxyCodeLine{2550   \textcolor{keywordflow}{switch} (to\_ascii(*begin)) \{}
\DoxyCodeLine{2551   \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{2552     handler.on\_sign(sign::plus);}
\DoxyCodeLine{2553     ++begin;}
\DoxyCodeLine{2554     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2555   \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{2556     handler.on\_sign(sign::minus);}
\DoxyCodeLine{2557     ++begin;}
\DoxyCodeLine{2558     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2559   \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{2560     handler.on\_sign(sign::space);}
\DoxyCodeLine{2561     ++begin;}
\DoxyCodeLine{2562     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2563   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2564     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2565   \}}
\DoxyCodeLine{2566   \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2567 }
\DoxyCodeLine{2568   \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\#'}) \{}
\DoxyCodeLine{2569     handler.on\_hash();}
\DoxyCodeLine{2570     \textcolor{keywordflow}{if} (++begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2571   \}}
\DoxyCodeLine{2572 }
\DoxyCodeLine{2573   \textcolor{comment}{// Parse zero flag.}}
\DoxyCodeLine{2574   \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{2575     handler.on\_zero();}
\DoxyCodeLine{2576     \textcolor{keywordflow}{if} (++begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2577   \}}
\DoxyCodeLine{2578 }
\DoxyCodeLine{2579   begin = parse\_width(begin, end, handler);}
\DoxyCodeLine{2580   \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2581 }
\DoxyCodeLine{2582   \textcolor{comment}{// Parse precision.}}
\DoxyCodeLine{2583   \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{2584     begin = parse\_precision(begin, end, handler);}
\DoxyCodeLine{2585     \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2586   \}}
\DoxyCodeLine{2587 }
\DoxyCodeLine{2588   \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'L'}) \{}
\DoxyCodeLine{2589     handler.on\_localized();}
\DoxyCodeLine{2590     ++begin;}
\DoxyCodeLine{2591   \}}
\DoxyCodeLine{2592 }
\DoxyCodeLine{2593   \textcolor{comment}{// Parse type.}}
\DoxyCodeLine{2594   \textcolor{keywordflow}{if} (begin != end \&\& *begin != \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2595     presentation\_type type = parse\_presentation\_type(*begin++);}
\DoxyCodeLine{2596     \textcolor{keywordflow}{if} (type == presentation\_type::none)}
\DoxyCodeLine{2597       handler.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2598     handler.on\_type(type);}
\DoxyCodeLine{2599   \}}
\DoxyCodeLine{2600   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2601 \}}
\DoxyCodeLine{2602 }
\DoxyCodeLine{2603 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2604 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_replacement\_field(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2605                                            Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2606   \textcolor{keyword}{struct }id\_adapter \{}
\DoxyCodeLine{2607     Handler\& handler;}
\DoxyCodeLine{2608     \textcolor{keywordtype}{int} arg\_id;}
\DoxyCodeLine{2609 }
\DoxyCodeLine{2610     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()() \{ arg\_id = handler.on\_arg\_id(); \}}
\DoxyCodeLine{2611     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{ arg\_id = handler.on\_arg\_id(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{2612     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2613       arg\_id = handler.on\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2614     \}}
\DoxyCodeLine{2615     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{2616       \textcolor{keywordflow}{if} (message) handler.on\_error(message);}
\DoxyCodeLine{2617     \}}
\DoxyCodeLine{2618   \};}
\DoxyCodeLine{2619 }
\DoxyCodeLine{2620   ++begin;}
\DoxyCodeLine{2621   \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}}), end;}
\DoxyCodeLine{2622   \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2623     handler.on\_replacement\_field(handler.on\_arg\_id(), begin);}
\DoxyCodeLine{2624   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2625     handler.on\_text(begin, begin + 1);}
\DoxyCodeLine{2626   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2627     \textcolor{keyword}{auto} adapter = id\_adapter\{handler, 0\};}
\DoxyCodeLine{2628     begin = parse\_arg\_id(begin, end, adapter);}
\DoxyCodeLine{2629     Char c = begin != end ? *begin : Char();}
\DoxyCodeLine{2630     \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2631       handler.on\_replacement\_field(adapter.arg\_id, begin);}
\DoxyCodeLine{2632     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{2633       begin = handler.on\_format\_specs(adapter.arg\_id, begin + 1, end);}
\DoxyCodeLine{2634       \textcolor{keywordflow}{if} (begin == end || *begin != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2635         \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}unknown format specifier"{}}), end;}
\DoxyCodeLine{2636     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2637       \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}missing '\}' in format string"{}}), end;}
\DoxyCodeLine{2638     \}}
\DoxyCodeLine{2639   \}}
\DoxyCodeLine{2640   \textcolor{keywordflow}{return} begin + 1;}
\DoxyCodeLine{2641 \}}
\DoxyCodeLine{2642 }
\DoxyCodeLine{2643 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_CONSTEXPR, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2644 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keywordtype}{void} parse\_format\_string(}
\DoxyCodeLine{2645     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, Handler\&\& handler) \{}
\DoxyCodeLine{2646   \textcolor{comment}{// Workaround a name-\/lookup bug in MSVC's modules implementation.}}
\DoxyCodeLine{2647   \textcolor{keyword}{using }detail::find;}
\DoxyCodeLine{2648 }
\DoxyCodeLine{2649   \textcolor{keyword}{auto} begin = format\_str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{2650   \textcolor{keyword}{auto} end = begin + format\_str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{2651   \textcolor{keywordflow}{if} (end -\/ begin < 32) \{}
\DoxyCodeLine{2652     \textcolor{comment}{// Use a simple loop instead of memchr for small strings.}}
\DoxyCodeLine{2653     \textcolor{keyword}{const} Char* p = begin;}
\DoxyCodeLine{2654     \textcolor{keywordflow}{while} (p != end) \{}
\DoxyCodeLine{2655       \textcolor{keyword}{auto} c = *p++;}
\DoxyCodeLine{2656       \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2657         handler.on\_text(begin, p -\/ 1);}
\DoxyCodeLine{2658         begin = p = parse\_replacement\_field(p -\/ 1, end, handler);}
\DoxyCodeLine{2659       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2660         \textcolor{keywordflow}{if} (p == end || *p != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2661           \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}});}
\DoxyCodeLine{2662         handler.on\_text(begin, p);}
\DoxyCodeLine{2663         begin = ++p;}
\DoxyCodeLine{2664       \}}
\DoxyCodeLine{2665     \}}
\DoxyCodeLine{2666     handler.on\_text(begin, end);}
\DoxyCodeLine{2667     \textcolor{keywordflow}{return};}
\DoxyCodeLine{2668   \}}
\DoxyCodeLine{2669   \textcolor{keyword}{struct }writer \{}
\DoxyCodeLine{2670     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Char* from, \textcolor{keyword}{const} Char* to) \{}
\DoxyCodeLine{2671       \textcolor{keywordflow}{if} (from == to) \textcolor{keywordflow}{return};}
\DoxyCodeLine{2672       \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2673         \textcolor{keyword}{const} Char* p = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2674         \textcolor{keywordflow}{if} (!find<IS\_CONSTEXPR>(from, to, Char(\textcolor{charliteral}{'\}'}), p))}
\DoxyCodeLine{2675           \textcolor{keywordflow}{return} handler\_.on\_text(from, to);}
\DoxyCodeLine{2676         ++p;}
\DoxyCodeLine{2677         \textcolor{keywordflow}{if} (p == to || *p != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2678           \textcolor{keywordflow}{return} handler\_.on\_error(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}});}
\DoxyCodeLine{2679         handler\_.on\_text(from, p);}
\DoxyCodeLine{2680         from = p + 1;}
\DoxyCodeLine{2681       \}}
\DoxyCodeLine{2682     \}}
\DoxyCodeLine{2683     Handler\& handler\_;}
\DoxyCodeLine{2684   \} write = \{handler\};}
\DoxyCodeLine{2685   \textcolor{keywordflow}{while} (begin != end) \{}
\DoxyCodeLine{2686     \textcolor{comment}{// Doing two passes with memchr (one for '\{' and another for '\}') is up to}}
\DoxyCodeLine{2687     \textcolor{comment}{// 2.5x faster than the naive one-\/pass implementation on big format strings.}}
\DoxyCodeLine{2688     \textcolor{keyword}{const} Char* p = begin;}
\DoxyCodeLine{2689     \textcolor{keywordflow}{if} (*begin != \textcolor{charliteral}{'\{'} \&\& !find<IS\_CONSTEXPR>(begin + 1, end, Char(\textcolor{charliteral}{'\{'}), p))}
\DoxyCodeLine{2690       \textcolor{keywordflow}{return} write(begin, end);}
\DoxyCodeLine{2691     write(begin, p);}
\DoxyCodeLine{2692     begin = parse\_replacement\_field(p, end, handler);}
\DoxyCodeLine{2693   \}}
\DoxyCodeLine{2694 \}}
\DoxyCodeLine{2695 }
\DoxyCodeLine{2696 template <typename T, bool = is\_named\_arg<T>::value> \textcolor{keyword}{struct }strip\_named\_arg \{}
\DoxyCodeLine{2697   \textcolor{keyword}{using }type = T;}
\DoxyCodeLine{2698 \};}
\DoxyCodeLine{2699 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }strip\_named\_arg<T, true> \{}
\DoxyCodeLine{2700   \textcolor{keyword}{using }type = remove\_cvref\_t<\textcolor{keyword}{decltype}(T::value)>;}
\DoxyCodeLine{2701 \};}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2704 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_format\_specs(ParseContext\& ctx)}
\DoxyCodeLine{2705     -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{2706   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} ParseContext::char\_type;}
\DoxyCodeLine{2707   \textcolor{keyword}{using }context = buffer\_context<char\_type>;}
\DoxyCodeLine{2708   \textcolor{keyword}{using }stripped\_type = \textcolor{keyword}{typename} strip\_named\_arg<T>::type;}
\DoxyCodeLine{2709   \textcolor{keyword}{using }mapped\_type = conditional\_t<}
\DoxyCodeLine{2710       mapped\_type\_constant<T, context>::value != type::custom\_type,}
\DoxyCodeLine{2711       \textcolor{keyword}{decltype}(arg\_mapper<context>().map(std::declval<const T\&>())),}
\DoxyCodeLine{2712       stripped\_type>;}
\DoxyCodeLine{2713   \textcolor{keyword}{auto} f = conditional\_t<has\_formatter<mapped\_type, context>::value,}
\DoxyCodeLine{2714                          formatter<mapped\_type, char\_type>,}
\DoxyCodeLine{2715                          fallback\_formatter<stripped\_type, char\_type>>();}
\DoxyCodeLine{2716   \textcolor{keywordflow}{return} f.parse(ctx);}
\DoxyCodeLine{2717 \}}
\DoxyCodeLine{2718 }
\DoxyCodeLine{2719 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{2720 FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_int\_type\_spec(presentation\_type type,}
\DoxyCodeLine{2721                                        ErrorHandler\&\& eh) \{}
\DoxyCodeLine{2722   \textcolor{keywordflow}{if} (type > presentation\_type::bin\_upper \&\& type != presentation\_type::chr)}
\DoxyCodeLine{2723     eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2724 \}}
\DoxyCodeLine{2725 }
\DoxyCodeLine{2726 \textcolor{comment}{// Checks char specs and returns true if the type spec is char (and not int).}}
\DoxyCodeLine{2727 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler = error\_handler>}
\DoxyCodeLine{2728 FMT\_CONSTEXPR \textcolor{keyword}{auto} check\_char\_specs(\textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2729                                     ErrorHandler\&\& eh = \{\}) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2730   \textcolor{keywordflow}{if} (specs.type != presentation\_type::none \&\&}
\DoxyCodeLine{2731       specs.type != presentation\_type::chr \&\&}
\DoxyCodeLine{2732       specs.type != presentation\_type::debug) \{}
\DoxyCodeLine{2733     check\_int\_type\_spec(specs.type, eh);}
\DoxyCodeLine{2734     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2735   \}}
\DoxyCodeLine{2736   \textcolor{keywordflow}{if} (specs.align == align::numeric || specs.sign != sign::none || specs.alt)}
\DoxyCodeLine{2737     eh.on\_error(\textcolor{stringliteral}{"{}invalid format specifier for char"{}});}
\DoxyCodeLine{2738   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2739 \}}
\DoxyCodeLine{2740 }
\DoxyCodeLine{2741 \textcolor{comment}{// A floating-\/point presentation format.}}
\DoxyCodeLine{2742 \textcolor{keyword}{enum class} float\_format : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{2743   general,  \textcolor{comment}{// General: exponent notation or fixed point based on magnitude.}}
\DoxyCodeLine{2744   exp,      \textcolor{comment}{// Exponent notation with the default precision of 6, e.g. 1.2e-\/3.}}
\DoxyCodeLine{2745   fixed,    \textcolor{comment}{// Fixed point with the default precision of 6, e.g. 0.0012.}}
\DoxyCodeLine{2746   hex}
\DoxyCodeLine{2747 \};}
\DoxyCodeLine{2748 }
\DoxyCodeLine{2749 \textcolor{keyword}{struct }float\_specs \{}
\DoxyCodeLine{2750   \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{2751   float\_format format : 8;}
\DoxyCodeLine{2752   sign\_t sign : 8;}
\DoxyCodeLine{2753   \textcolor{keywordtype}{bool} upper : 1;}
\DoxyCodeLine{2754   \textcolor{keywordtype}{bool} locale : 1;}
\DoxyCodeLine{2755   \textcolor{keywordtype}{bool} binary32 : 1;}
\DoxyCodeLine{2756   \textcolor{keywordtype}{bool} showpoint : 1;}
\DoxyCodeLine{2757 \};}
\DoxyCodeLine{2758 }
\DoxyCodeLine{2759 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler = error\_handler, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2760 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_float\_type\_spec(\textcolor{keyword}{const} basic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2761                                          ErrorHandler\&\& eh = \{\})}
\DoxyCodeLine{2762     -\/> float\_specs \{}
\DoxyCodeLine{2763   \textcolor{keyword}{auto} result = float\_specs();}
\DoxyCodeLine{2764   result.showpoint = specs.alt;}
\DoxyCodeLine{2765   result.locale = specs.localized;}
\DoxyCodeLine{2766   \textcolor{keywordflow}{switch} (specs.type) \{}
\DoxyCodeLine{2767   \textcolor{keywordflow}{case} presentation\_type::none:}
\DoxyCodeLine{2768     result.format = float\_format::general;}
\DoxyCodeLine{2769     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2770   \textcolor{keywordflow}{case} presentation\_type::general\_upper:}
\DoxyCodeLine{2771     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2772     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2773   \textcolor{keywordflow}{case} presentation\_type::general\_lower:}
\DoxyCodeLine{2774     result.format = float\_format::general;}
\DoxyCodeLine{2775     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2776   \textcolor{keywordflow}{case} presentation\_type::exp\_upper:}
\DoxyCodeLine{2777     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2778     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2779   \textcolor{keywordflow}{case} presentation\_type::exp\_lower:}
\DoxyCodeLine{2780     result.format = float\_format::exp;}
\DoxyCodeLine{2781     result.showpoint |= specs.precision != 0;}
\DoxyCodeLine{2782     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2783   \textcolor{keywordflow}{case} presentation\_type::fixed\_upper:}
\DoxyCodeLine{2784     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2785     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2786   \textcolor{keywordflow}{case} presentation\_type::fixed\_lower:}
\DoxyCodeLine{2787     result.format = float\_format::fixed;}
\DoxyCodeLine{2788     result.showpoint |= specs.precision != 0;}
\DoxyCodeLine{2789     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2790   \textcolor{keywordflow}{case} presentation\_type::hexfloat\_upper:}
\DoxyCodeLine{2791     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2792     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2793   \textcolor{keywordflow}{case} presentation\_type::hexfloat\_lower:}
\DoxyCodeLine{2794     result.format = float\_format::hex;}
\DoxyCodeLine{2795     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2796   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2797     eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2798     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2799   \}}
\DoxyCodeLine{2800   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2801 \}}
\DoxyCodeLine{2802 }
\DoxyCodeLine{2803 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler = error\_handler>}
\DoxyCodeLine{2804 FMT\_CONSTEXPR \textcolor{keyword}{auto} check\_cstring\_type\_spec(presentation\_type type,}
\DoxyCodeLine{2805                                            ErrorHandler\&\& eh = \{\}) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2806   \textcolor{keywordflow}{if} (type == presentation\_type::none || type == presentation\_type::string)}
\DoxyCodeLine{2807     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2808   \textcolor{keywordflow}{if} (type != presentation\_type::pointer) eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2809   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2810 \}}
\DoxyCodeLine{2811 }
\DoxyCodeLine{2812 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler = error\_handler>}
\DoxyCodeLine{2813 FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_string\_type\_spec(presentation\_type type,}
\DoxyCodeLine{2814                                           ErrorHandler\&\& eh = \{\}) \{}
\DoxyCodeLine{2815   \textcolor{keywordflow}{if} (type != presentation\_type::none \&\& type != presentation\_type::string \&\&}
\DoxyCodeLine{2816       type != presentation\_type::debug)}
\DoxyCodeLine{2817     eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2818 \}}
\DoxyCodeLine{2819 }
\DoxyCodeLine{2820 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{2821 FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_pointer\_type\_spec(presentation\_type type,}
\DoxyCodeLine{2822                                            ErrorHandler\&\& eh) \{}
\DoxyCodeLine{2823   \textcolor{keywordflow}{if} (type != presentation\_type::none \&\& type != presentation\_type::pointer)}
\DoxyCodeLine{2824     eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{2825 \}}
\DoxyCodeLine{2826 }
\DoxyCodeLine{2827 \textcolor{comment}{// A parse\_format\_specs handler that checks if specifiers are consistent with}}
\DoxyCodeLine{2828 \textcolor{comment}{// the argument type.}}
\DoxyCodeLine{2829 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Handler> \textcolor{keyword}{class }specs\_checker : \textcolor{keyword}{public} Handler \{}
\DoxyCodeLine{2830  \textcolor{keyword}{private}:}
\DoxyCodeLine{2831   detail::type arg\_type\_;}
\DoxyCodeLine{2832 }
\DoxyCodeLine{2833   FMT\_CONSTEXPR \textcolor{keywordtype}{void} require\_numeric\_argument() \{}
\DoxyCodeLine{2834     \textcolor{keywordflow}{if} (!is\_arithmetic\_type(arg\_type\_))}
\DoxyCodeLine{2835       this-\/>on\_error(\textcolor{stringliteral}{"{}format specifier requires numeric argument"{}});}
\DoxyCodeLine{2836   \}}
\DoxyCodeLine{2837 }
\DoxyCodeLine{2838  \textcolor{keyword}{public}:}
\DoxyCodeLine{2839   FMT\_CONSTEXPR specs\_checker(\textcolor{keyword}{const} Handler\& handler, detail::type arg\_type)}
\DoxyCodeLine{2840       : Handler(handler), arg\_type\_(arg\_type) \{\}}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_align(align\_t align) \{}
\DoxyCodeLine{2843     \textcolor{keywordflow}{if} (align == align::numeric) require\_numeric\_argument();}
\DoxyCodeLine{2844     Handler::on\_align(align);}
\DoxyCodeLine{2845   \}}
\DoxyCodeLine{2846 }
\DoxyCodeLine{2847   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_sign(sign\_t s) \{}
\DoxyCodeLine{2848     require\_numeric\_argument();}
\DoxyCodeLine{2849     \textcolor{keywordflow}{if} (is\_integral\_type(arg\_type\_) \&\& arg\_type\_ != type::int\_type \&\&}
\DoxyCodeLine{2850         arg\_type\_ != type::long\_long\_type \&\& arg\_type\_ != type::int128\_type \&\&}
\DoxyCodeLine{2851         arg\_type\_ != type::char\_type) \{}
\DoxyCodeLine{2852       this-\/>on\_error(\textcolor{stringliteral}{"{}format specifier requires signed argument"{}});}
\DoxyCodeLine{2853     \}}
\DoxyCodeLine{2854     Handler::on\_sign(s);}
\DoxyCodeLine{2855   \}}
\DoxyCodeLine{2856 }
\DoxyCodeLine{2857   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_hash() \{}
\DoxyCodeLine{2858     require\_numeric\_argument();}
\DoxyCodeLine{2859     Handler::on\_hash();}
\DoxyCodeLine{2860   \}}
\DoxyCodeLine{2861 }
\DoxyCodeLine{2862   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_localized() \{}
\DoxyCodeLine{2863     require\_numeric\_argument();}
\DoxyCodeLine{2864     Handler::on\_localized();}
\DoxyCodeLine{2865   \}}
\DoxyCodeLine{2866 }
\DoxyCodeLine{2867   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_zero() \{}
\DoxyCodeLine{2868     require\_numeric\_argument();}
\DoxyCodeLine{2869     Handler::on\_zero();}
\DoxyCodeLine{2870   \}}
\DoxyCodeLine{2871 }
\DoxyCodeLine{2872   FMT\_CONSTEXPR \textcolor{keywordtype}{void} end\_precision() \{}
\DoxyCodeLine{2873     \textcolor{keywordflow}{if} (is\_integral\_type(arg\_type\_) || arg\_type\_ == type::pointer\_type)}
\DoxyCodeLine{2874       this-\/>on\_error(\textcolor{stringliteral}{"{}precision not allowed for this argument type"{}});}
\DoxyCodeLine{2875   \}}
\DoxyCodeLine{2876 \};}
\DoxyCodeLine{2877 }
\DoxyCodeLine{2878 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} invalid\_arg\_index = -\/1;}
\DoxyCodeLine{2879 }
\DoxyCodeLine{2880 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{2881 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2882 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} get\_arg\_index\_by\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2883   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::is\_statically\_named\_arg<T>()) \{}
\DoxyCodeLine{2884     \textcolor{keywordflow}{if} (name == T::name) \textcolor{keywordflow}{return} N;}
\DoxyCodeLine{2885   \}}
\DoxyCodeLine{2886   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\textcolor{keyword}{sizeof}...(Args) > 0)}
\DoxyCodeLine{2887     \textcolor{keywordflow}{return} get\_arg\_index\_by\_name<N + 1, Args...>(name);}
\DoxyCodeLine{2888   (void)name;  \textcolor{comment}{// Workaround an MSVC bug about "{}unused"{} parameter.}}
\DoxyCodeLine{2889   \textcolor{keywordflow}{return} invalid\_arg\_index;}
\DoxyCodeLine{2890 \}}
\DoxyCodeLine{2891 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2892 }
\DoxyCodeLine{2893 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2894 FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg\_index\_by\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2895 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{2896   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\textcolor{keyword}{sizeof}...(Args) > 0)}
\DoxyCodeLine{2897     \textcolor{keywordflow}{return} get\_arg\_index\_by\_name<0, Args...>(name);}
\DoxyCodeLine{2898 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2899   (void)name;}
\DoxyCodeLine{2900   \textcolor{keywordflow}{return} invalid\_arg\_index;}
\DoxyCodeLine{2901 \}}
\DoxyCodeLine{2902 }
\DoxyCodeLine{2903 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{2904 \textcolor{keyword}{class }format\_string\_checker \{}
\DoxyCodeLine{2905  \textcolor{keyword}{private}:}
\DoxyCodeLine{2906   \textcolor{comment}{// In the future basic\_format\_parse\_context will replace compile\_parse\_context}}
\DoxyCodeLine{2907   \textcolor{comment}{// here and will use is\_constant\_evaluated and downcasting to access the data}}
\DoxyCodeLine{2908   \textcolor{comment}{// needed for compile-\/time checks: https://godbolt.org/z/GvWzcTjh1.}}
\DoxyCodeLine{2909   \textcolor{keyword}{using }parse\_context\_type = compile\_parse\_context<Char, ErrorHandler>;}
\DoxyCodeLine{2910   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} num\_args = \textcolor{keyword}{sizeof}...(Args);}
\DoxyCodeLine{2911 }
\DoxyCodeLine{2912   \textcolor{comment}{// Format specifier parsing function.}}
\DoxyCodeLine{2913   \textcolor{keyword}{using }parse\_func = \textcolor{keyword}{const} Char* (*)(parse\_context\_type\&);}
\DoxyCodeLine{2914 }
\DoxyCodeLine{2915   parse\_context\_type context\_;}
\DoxyCodeLine{2916   parse\_func parse\_funcs\_[num\_args > 0 ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(num\_args) : 1];}
\DoxyCodeLine{2917   type types\_[num\_args > 0 ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(num\_args) : 1];}
\DoxyCodeLine{2918 }
\DoxyCodeLine{2919  \textcolor{keyword}{public}:}
\DoxyCodeLine{2920   \textcolor{keyword}{explicit} FMT\_CONSTEXPR format\_string\_checker(}
\DoxyCodeLine{2921       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, ErrorHandler eh)}
\DoxyCodeLine{2922       : context\_(format\_str, num\_args, types\_, eh),}
\DoxyCodeLine{2923         parse\_funcs\_\{\&parse\_format\_specs<Args, parse\_context\_type>...\},}
\DoxyCodeLine{2924         types\_\{type\_constant<Args, char>::value...\} \{\}}
\DoxyCodeLine{2925 }
\DoxyCodeLine{2926   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char*, \textcolor{keyword}{const} Char*) \{\}}
\DoxyCodeLine{2927 }
\DoxyCodeLine{2928   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id() -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} context\_.next\_arg\_id(); \}}
\DoxyCodeLine{2929   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2930     \textcolor{keywordflow}{return} context\_.check\_arg\_id(\textcolor{keywordtype}{id}), id;}
\DoxyCodeLine{2931   \}}
\DoxyCodeLine{2932   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2933 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{2934     \textcolor{keyword}{auto} index = get\_arg\_index\_by\_name<Args...>(id);}
\DoxyCodeLine{2935     \textcolor{keywordflow}{if} (index == invalid\_arg\_index) on\_error(\textcolor{stringliteral}{"{}named argument is not found"{}});}
\DoxyCodeLine{2936     \textcolor{keywordflow}{return} context\_.check\_arg\_id(index), index;}
\DoxyCodeLine{2937 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2938     (void)\textcolor{keywordtype}{id};}
\DoxyCodeLine{2939     on\_error(\textcolor{stringliteral}{"{}compile-\/time checks for named arguments require C++20 support"{}});}
\DoxyCodeLine{2940     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2941 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2942   \}}
\DoxyCodeLine{2943 }
\DoxyCodeLine{2944   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_replacement\_field(\textcolor{keywordtype}{int}, \textcolor{keyword}{const} Char*) \{\}}
\DoxyCodeLine{2945 }
\DoxyCodeLine{2946   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_format\_specs(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char*)}
\DoxyCodeLine{2947       -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2948     context\_.advance\_to(context\_.begin() + (begin -\/ \&*context\_.begin()));}
\DoxyCodeLine{2949     \textcolor{comment}{// id >= 0 check is a workaround for gcc 10 bug (\#2065).}}
\DoxyCodeLine{2950     \textcolor{keywordflow}{return} \textcolor{keywordtype}{id} >= 0 \&\& \textcolor{keywordtype}{id} < num\_args ? parse\_funcs\_[id](context\_) : begin;}
\DoxyCodeLine{2951   \}}
\DoxyCodeLine{2952 }
\DoxyCodeLine{2953   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{2954     context\_.on\_error(message);}
\DoxyCodeLine{2955   \}}
\DoxyCodeLine{2956 \};}
\DoxyCodeLine{2957 }
\DoxyCodeLine{2958 \textcolor{comment}{// Reports a compile-\/time error if S is not a valid format string.}}
\DoxyCodeLine{2959 \textcolor{keyword}{template} <\textcolor{keyword}{typename}..., \textcolor{keyword}{typename} S, FMT\_ENABLE\_IF(!is\_compile\_string<S>::value)>}
\DoxyCodeLine{2960 FMT\_INLINE \textcolor{keywordtype}{void} check\_format\_string(\textcolor{keyword}{const} S\&) \{}
\DoxyCodeLine{2961 \textcolor{preprocessor}{\#ifdef FMT\_ENFORCE\_COMPILE\_STRING}}
\DoxyCodeLine{2962   \textcolor{keyword}{static\_assert}(is\_compile\_string<S>::value,}
\DoxyCodeLine{2963                 \textcolor{stringliteral}{"{}FMT\_ENFORCE\_COMPILE\_STRING requires all format strings to use "{}}}
\DoxyCodeLine{2964                 \textcolor{stringliteral}{"{}FMT\_STRING."{}});}
\DoxyCodeLine{2965 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2966 \}}
\DoxyCodeLine{2967 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} S,}
\DoxyCodeLine{2968           FMT\_ENABLE\_IF(is\_compile\_string<S>::value)>}
\DoxyCodeLine{2969 \textcolor{keywordtype}{void} check\_format\_string(S format\_str) \{}
\DoxyCodeLine{2970   FMT\_CONSTEXPR \textcolor{keyword}{auto} s = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(format\_str);}
\DoxyCodeLine{2971   \textcolor{keyword}{using }checker = format\_string\_checker<\textcolor{keyword}{typename} S::char\_type, error\_handler,}
\DoxyCodeLine{2972                                         remove\_cvref\_t<Args>...>;}
\DoxyCodeLine{2973   FMT\_CONSTEXPR \textcolor{keywordtype}{bool} invalid\_format =}
\DoxyCodeLine{2974       (parse\_format\_string<true>(s, checker(s, \{\})), \textcolor{keyword}{true});}
\DoxyCodeLine{2975   ignore\_unused(invalid\_format);}
\DoxyCodeLine{2976 \}}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2978 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2979 \textcolor{keywordtype}{void} vformat\_to(}
\DoxyCodeLine{2980     \mbox{\hyperlink{classbuffer}{buffer<Char>}}\& buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fmt,}
\DoxyCodeLine{2981     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<FMT\_BUFFER\_CONTEXT(type\_identity\_t<Char>)> args,}
\DoxyCodeLine{2982     locale\_ref loc = \{\});}
\DoxyCodeLine{2983 }
\DoxyCodeLine{2984 FMT\_API \textcolor{keywordtype}{void} vprint\_mojibake(std::FILE*, \mbox{\hyperlink{classbasic__string__view}{string\_view}}, \mbox{\hyperlink{classbasic__format__args}{format\_args}});}
\DoxyCodeLine{2985 \textcolor{preprocessor}{\#ifndef \_WIN32}}
\DoxyCodeLine{2986 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} vprint\_mojibake(std::FILE*, \mbox{\hyperlink{classbasic__string__view}{string\_view}}, \mbox{\hyperlink{classbasic__format__args}{format\_args}}) \{\}}
\DoxyCodeLine{2987 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2988 FMT\_END\_DETAIL\_NAMESPACE}
\DoxyCodeLine{2989 }
\DoxyCodeLine{2990 \textcolor{comment}{// A formatter specialization for the core types corresponding to detail::type}}
\DoxyCodeLine{2991 \textcolor{comment}{// constants.}}
\DoxyCodeLine{2992 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2993 \textcolor{keyword}{struct }formatter<T, Char,}
\DoxyCodeLine{2994                  enable\_if\_t<detail::type\_constant<T, Char>::value !=}
\DoxyCodeLine{2995                              detail::type::custom\_type>> \{}
\DoxyCodeLine{2996  \textcolor{keyword}{private}:}
\DoxyCodeLine{2997   detail::dynamic\_format\_specs<Char> specs\_;}
\DoxyCodeLine{2998 }
\DoxyCodeLine{2999  \textcolor{keyword}{public}:}
\DoxyCodeLine{3000   \textcolor{comment}{// Parses format specifiers stopping either at the end of the range or at the}}
\DoxyCodeLine{3001   \textcolor{comment}{// terminating '\}'.}}
\DoxyCodeLine{3002   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3003   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{3004     \textcolor{keyword}{auto} begin = ctx.begin(), end = ctx.end();}
\DoxyCodeLine{3005     \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{3006     \textcolor{keyword}{using }handler\_type = detail::dynamic\_specs\_handler<ParseContext>;}
\DoxyCodeLine{3007     \textcolor{keyword}{auto} type = detail::type\_constant<T, Char>::value;}
\DoxyCodeLine{3008     \textcolor{keyword}{auto} checker =}
\DoxyCodeLine{3009         detail::specs\_checker<handler\_type>(handler\_type(specs\_, ctx), type);}
\DoxyCodeLine{3010     \textcolor{keyword}{auto} it = detail::parse\_format\_specs(begin, end, checker);}
\DoxyCodeLine{3011     \textcolor{keyword}{auto} eh = ctx.error\_handler();}
\DoxyCodeLine{3012     \textcolor{keywordflow}{switch} (type) \{}
\DoxyCodeLine{3013     \textcolor{keywordflow}{case} detail::type::none\_type:}
\DoxyCodeLine{3014       FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}invalid argument type"{}});}
\DoxyCodeLine{3015       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3016     \textcolor{keywordflow}{case} detail::type::bool\_type:}
\DoxyCodeLine{3017       \textcolor{keywordflow}{if} (specs\_.type == presentation\_type::none ||}
\DoxyCodeLine{3018           specs\_.type == presentation\_type::string) \{}
\DoxyCodeLine{3019         \textcolor{keywordflow}{break};}
\DoxyCodeLine{3020       \}}
\DoxyCodeLine{3021       FMT\_FALLTHROUGH;}
\DoxyCodeLine{3022     \textcolor{keywordflow}{case} detail::type::int\_type:}
\DoxyCodeLine{3023     \textcolor{keywordflow}{case} detail::type::uint\_type:}
\DoxyCodeLine{3024     \textcolor{keywordflow}{case} detail::type::long\_long\_type:}
\DoxyCodeLine{3025     \textcolor{keywordflow}{case} detail::type::ulong\_long\_type:}
\DoxyCodeLine{3026     \textcolor{keywordflow}{case} detail::type::int128\_type:}
\DoxyCodeLine{3027     \textcolor{keywordflow}{case} detail::type::uint128\_type:}
\DoxyCodeLine{3028       detail::check\_int\_type\_spec(specs\_.type, eh);}
\DoxyCodeLine{3029       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3030     \textcolor{keywordflow}{case} detail::type::char\_type:}
\DoxyCodeLine{3031       detail::check\_char\_specs(specs\_, eh);}
\DoxyCodeLine{3032       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3033     \textcolor{keywordflow}{case} detail::type::float\_type:}
\DoxyCodeLine{3034       \textcolor{keywordflow}{if} (detail::const\_check(FMT\_USE\_FLOAT))}
\DoxyCodeLine{3035         detail::parse\_float\_type\_spec(specs\_, eh);}
\DoxyCodeLine{3036       \textcolor{keywordflow}{else}}
\DoxyCodeLine{3037         FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}float support disabled"{}});}
\DoxyCodeLine{3038       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3039     \textcolor{keywordflow}{case} detail::type::double\_type:}
\DoxyCodeLine{3040       \textcolor{keywordflow}{if} (detail::const\_check(FMT\_USE\_DOUBLE))}
\DoxyCodeLine{3041         detail::parse\_float\_type\_spec(specs\_, eh);}
\DoxyCodeLine{3042       \textcolor{keywordflow}{else}}
\DoxyCodeLine{3043         FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}double support disabled"{}});}
\DoxyCodeLine{3044       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3045     \textcolor{keywordflow}{case} detail::type::long\_double\_type:}
\DoxyCodeLine{3046       \textcolor{keywordflow}{if} (detail::const\_check(FMT\_USE\_LONG\_DOUBLE))}
\DoxyCodeLine{3047         detail::parse\_float\_type\_spec(specs\_, eh);}
\DoxyCodeLine{3048       \textcolor{keywordflow}{else}}
\DoxyCodeLine{3049         FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}long double support disabled"{}});}
\DoxyCodeLine{3050       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3051     \textcolor{keywordflow}{case} detail::type::cstring\_type:}
\DoxyCodeLine{3052       detail::check\_cstring\_type\_spec(specs\_.type, eh);}
\DoxyCodeLine{3053       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3054     \textcolor{keywordflow}{case} detail::type::string\_type:}
\DoxyCodeLine{3055       detail::check\_string\_type\_spec(specs\_.type, eh);}
\DoxyCodeLine{3056       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3057     \textcolor{keywordflow}{case} detail::type::pointer\_type:}
\DoxyCodeLine{3058       detail::check\_pointer\_type\_spec(specs\_.type, eh);}
\DoxyCodeLine{3059       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3060     \textcolor{keywordflow}{case} detail::type::custom\_type:}
\DoxyCodeLine{3061       \textcolor{comment}{// Custom format specifiers are checked in parse functions of}}
\DoxyCodeLine{3062       \textcolor{comment}{// formatter specializations.}}
\DoxyCodeLine{3063       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3064     \}}
\DoxyCodeLine{3065     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{3066   \}}
\DoxyCodeLine{3067 }
\DoxyCodeLine{3068   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3069   FMT\_CONSTEXPR \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T\& val, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{3070       -\/> \textcolor{keyword}{decltype}(ctx.out());}
\DoxyCodeLine{3071 \};}
\DoxyCodeLine{3072 }
\DoxyCodeLine{3073 \textcolor{preprocessor}{\#define FMT\_FORMAT\_AS(Type, Base)                                        \(\backslash\)}}
\DoxyCodeLine{3074 \textcolor{preprocessor}{  template <typename Char>                                               \(\backslash\)}}
\DoxyCodeLine{3075 \textcolor{preprocessor}{  struct formatter<Type, Char> : formatter<Base, Char> \{                 \(\backslash\)}}
\DoxyCodeLine{3076 \textcolor{preprocessor}{    template <typename FormatContext>                                    \(\backslash\)}}
\DoxyCodeLine{3077 \textcolor{preprocessor}{    auto format(Type const\& val, FormatContext\& ctx) const               \(\backslash\)}}
\DoxyCodeLine{3078 \textcolor{preprocessor}{        -\/> decltype(ctx.out()) \{                                         \(\backslash\)}}
\DoxyCodeLine{3079 \textcolor{preprocessor}{      return formatter<Base, Char>::format(static\_cast<Base>(val), ctx); \(\backslash\)}}
\DoxyCodeLine{3080 \textcolor{preprocessor}{    \}                                                                    \(\backslash\)}}
\DoxyCodeLine{3081 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{3082 }
\DoxyCodeLine{3083 FMT\_FORMAT\_AS(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}, \textcolor{keywordtype}{int});}
\DoxyCodeLine{3084 FMT\_FORMAT\_AS(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \textcolor{keywordtype}{unsigned});}
\DoxyCodeLine{3085 FMT\_FORMAT\_AS(\textcolor{keywordtype}{short}, \textcolor{keywordtype}{int});}
\DoxyCodeLine{3086 FMT\_FORMAT\_AS(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}, \textcolor{keywordtype}{unsigned});}
\DoxyCodeLine{3087 FMT\_FORMAT\_AS(\textcolor{keywordtype}{long}, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long});}
\DoxyCodeLine{3088 FMT\_FORMAT\_AS(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long});}
\DoxyCodeLine{3089 FMT\_FORMAT\_AS(Char*, \textcolor{keyword}{const} Char*);}
\DoxyCodeLine{3090 FMT\_FORMAT\_AS(std::basic\_string<Char>, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}});}
\DoxyCodeLine{3091 FMT\_FORMAT\_AS(std::nullptr\_t, \textcolor{keyword}{const} \textcolor{keywordtype}{void}*);}
\DoxyCodeLine{3092 FMT\_FORMAT\_AS(detail::std\_string\_view<Char>, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}});}
\DoxyCodeLine{3093 }
\DoxyCodeLine{3094 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }basic\_runtime \{ \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str; \};}
\DoxyCodeLine{3095 }
\DoxyCodeLine{3097 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... Args> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}} \{}
\DoxyCodeLine{3098  \textcolor{keyword}{private}:}
\DoxyCodeLine{3099   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str\_;}
\DoxyCodeLine{3100 }
\DoxyCodeLine{3101  \textcolor{keyword}{public}:}
\DoxyCodeLine{3102   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S,}
\DoxyCodeLine{3103             FMT\_ENABLE\_IF(}
\DoxyCodeLine{3104                 std::is\_convertible<\textcolor{keyword}{const} S\&, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}>::value)>}
\DoxyCodeLine{3105   FMT\_CONSTEVAL FMT\_INLINE \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}(\textcolor{keyword}{const} S\& s) : str\_(s) \{}
\DoxyCodeLine{3106     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{3107         detail::count<}
\DoxyCodeLine{3108             (std::is\_base\_of<detail::view, remove\_reference\_t<Args>>::value \&\&}
\DoxyCodeLine{3109              std::is\_reference<Args>::value)...>() == 0,}
\DoxyCodeLine{3110         \textcolor{stringliteral}{"{}passing views as lvalues is disallowed"{}});}
\DoxyCodeLine{3111 \textcolor{preprocessor}{\#ifdef FMT\_HAS\_CONSTEVAL}}
\DoxyCodeLine{3112     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::count\_named\_args<Args...>() ==}
\DoxyCodeLine{3113                   detail::count\_statically\_named\_args<Args...>()) \{}
\DoxyCodeLine{3114       \textcolor{keyword}{using }checker = detail::format\_string\_checker<Char, detail::error\_handler,}
\DoxyCodeLine{3115                                                     remove\_cvref\_t<Args>...>;}
\DoxyCodeLine{3116       detail::parse\_format\_string<true>(str\_, checker(s, \{\}));}
\DoxyCodeLine{3117     \}}
\DoxyCodeLine{3118 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3119     detail::check\_format\_string<Args...>(s);}
\DoxyCodeLine{3120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3121   \}}
\DoxyCodeLine{3122   \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}(basic\_runtime<Char> r) : str\_(r.str) \{\}}
\DoxyCodeLine{3123 }
\DoxyCodeLine{3124   FMT\_INLINE \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} str\_; \}}
\DoxyCodeLine{3125 \};}
\DoxyCodeLine{3126 }
\DoxyCodeLine{3127 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}}
\DoxyCodeLine{3128 \textcolor{comment}{// Workaround broken conversion on older gcc.}}
\DoxyCodeLine{3129 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__string}{format\_string}} = \mbox{\hyperlink{classbasic__string__view}{string\_view}};}
\DoxyCodeLine{3130 \textcolor{keyword}{inline} \textcolor{keyword}{auto} runtime(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char>}} \{ \textcolor{keywordflow}{return} s; \}}
\DoxyCodeLine{3131 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3132 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3133 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__string}{format\_string}} = \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string<char, type\_identity\_t<Args>}}...>;}
\DoxyCodeLine{3144 \textcolor{keyword}{inline} \textcolor{keyword}{auto} runtime(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) -\/> basic\_runtime<char> \{ \textcolor{keywordflow}{return} \{\{s\}\}; \}}
\DoxyCodeLine{3145 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3146 }
\DoxyCodeLine{3147 FMT\_API \textcolor{keyword}{auto} vformat(\mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> std::string;}
\DoxyCodeLine{3148 }
\DoxyCodeLine{3160 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3161 FMT\_NODISCARD FMT\_INLINE \textcolor{keyword}{auto} format(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{3162     -\/> std::string \{}
\DoxyCodeLine{3163   \textcolor{keywordflow}{return} vformat(fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{3164 \}}
\DoxyCodeLine{3165 }
\DoxyCodeLine{3167 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{3168           FMT\_ENABLE\_IF(detail::is\_output\_iterator<OutputIt, char>::value)>}
\DoxyCodeLine{3169 \textcolor{keyword}{auto} vformat\_to(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> OutputIt \{}
\DoxyCodeLine{3170   \textcolor{keyword}{using }detail::get\_buffer;}
\DoxyCodeLine{3171   \textcolor{keyword}{auto}\&\& buf = get\_buffer<char>(out);}
\DoxyCodeLine{3172   detail::vformat\_to(buf, fmt, args, \{\});}
\DoxyCodeLine{3173   \textcolor{keywordflow}{return} detail::get\_iterator(buf);}
\DoxyCodeLine{3174 \}}
\DoxyCodeLine{3175 }
\DoxyCodeLine{3188 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{3189           FMT\_ENABLE\_IF(detail::is\_output\_iterator<OutputIt, char>::value)>}
\DoxyCodeLine{3190 FMT\_INLINE \textcolor{keyword}{auto} format\_to(OutputIt out, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{3191     -\/> OutputIt \{}
\DoxyCodeLine{3192   \textcolor{keywordflow}{return} vformat\_to(out, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{3193 \}}
\DoxyCodeLine{3194 }
\DoxyCodeLine{3195 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt> \textcolor{keyword}{struct }format\_to\_n\_result \{}
\DoxyCodeLine{3197   OutputIt out;}
\DoxyCodeLine{3199   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{3200 \};}
\DoxyCodeLine{3201 }
\DoxyCodeLine{3202 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{3203           FMT\_ENABLE\_IF(detail::is\_output\_iterator<OutputIt, char>::value)>}
\DoxyCodeLine{3204 \textcolor{keyword}{auto} vformat\_to\_n(OutputIt out, \textcolor{keywordtype}{size\_t} n, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args)}
\DoxyCodeLine{3205     -\/> format\_to\_n\_result<OutputIt> \{}
\DoxyCodeLine{3206   \textcolor{keyword}{using }traits = detail::fixed\_buffer\_traits;}
\DoxyCodeLine{3207   \textcolor{keyword}{auto} buf = detail::iterator\_buffer<OutputIt, char, traits>(out, n);}
\DoxyCodeLine{3208   detail::vformat\_to(buf, fmt, args, \{\});}
\DoxyCodeLine{3209   \textcolor{keywordflow}{return} \{buf.out(), buf.count()\};}
\DoxyCodeLine{3210 \}}
\DoxyCodeLine{3211 }
\DoxyCodeLine{3220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{3221           FMT\_ENABLE\_IF(detail::is\_output\_iterator<OutputIt, char>::value)>}
\DoxyCodeLine{3222 FMT\_INLINE \textcolor{keyword}{auto} format\_to\_n(OutputIt out, \textcolor{keywordtype}{size\_t} n, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt,}
\DoxyCodeLine{3223                             T\&\&... args) -\/> format\_to\_n\_result<OutputIt> \{}
\DoxyCodeLine{3224   \textcolor{keywordflow}{return} vformat\_to\_n(out, n, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{3225 \}}
\DoxyCodeLine{3226 }
\DoxyCodeLine{3228 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3229 FMT\_NODISCARD FMT\_INLINE \textcolor{keyword}{auto} formatted\_size(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt,}
\DoxyCodeLine{3230                                              T\&\&... args) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{3231   \textcolor{keyword}{auto} buf = detail::counting\_buffer<>();}
\DoxyCodeLine{3232   detail::vformat\_to(buf, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(fmt), fmt::make\_format\_args(args...), \{\});}
\DoxyCodeLine{3233   \textcolor{keywordflow}{return} buf.count();}
\DoxyCodeLine{3234 \}}
\DoxyCodeLine{3235 }
\DoxyCodeLine{3236 FMT\_API \textcolor{keywordtype}{void} vprint(\mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args);}
\DoxyCodeLine{3237 FMT\_API \textcolor{keywordtype}{void} vprint(std::FILE* f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args);}
\DoxyCodeLine{3238 }
\DoxyCodeLine{3249 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3250 FMT\_INLINE \textcolor{keywordtype}{void} print(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{3251   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs = fmt::make\_format\_args(args...);}
\DoxyCodeLine{3252   \textcolor{keywordflow}{return} detail::is\_utf8() ? vprint(fmt, vargs)}
\DoxyCodeLine{3253                            : detail::vprint\_mojibake(stdout, fmt, vargs);}
\DoxyCodeLine{3254 \}}
\DoxyCodeLine{3255 }
\DoxyCodeLine{3266 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3267 FMT\_INLINE \textcolor{keywordtype}{void} print(std::FILE* f, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{3268   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs = fmt::make\_format\_args(args...);}
\DoxyCodeLine{3269   \textcolor{keywordflow}{return} detail::is\_utf8() ? vprint(f, fmt, vargs)}
\DoxyCodeLine{3270                            : detail::vprint\_mojibake(f, fmt, vargs);}
\DoxyCodeLine{3271 \}}
\DoxyCodeLine{3272 }
\DoxyCodeLine{3273 FMT\_MODULE\_EXPORT\_END}
\DoxyCodeLine{3274 FMT\_GCC\_PRAGMA(\textcolor{stringliteral}{"{}GCC pop\_options"{}})}
\DoxyCodeLine{3275 FMT\_END\_NAMESPACE}
\DoxyCodeLine{3276 }
\DoxyCodeLine{3277 \textcolor{preprocessor}{\#ifdef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{3278 \textcolor{preprocessor}{\#  include "{}format.h"{}}}
\DoxyCodeLine{3279 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3280 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_CORE\_H\_}}

\end{DoxyCode}

\hypertarget{ostream_8h_source}{}\doxysection{ostream.\+h}
\label{ostream_8h_source}\index{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/ostream.h@{out/build/x64/vcpkg\_installed/x86-\/windows/include/fmt/ostream.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ std::ostream support}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_OSTREAM\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_OSTREAM\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char> \textcolor{keyword}{class }basic\_printf\_context;}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{comment}{// Checks if T has a user-\/defined operator<<.}}
\DoxyCodeLine{23 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{24 \textcolor{keyword}{class }is\_streamable \{}
\DoxyCodeLine{25  \textcolor{keyword}{private}:}
\DoxyCodeLine{26   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{27   \textcolor{keyword}{static} \textcolor{keyword}{auto} test(\textcolor{keywordtype}{int})}
\DoxyCodeLine{28       -\/> bool\_constant<\textcolor{keyword}{sizeof}(std::declval<std::basic\_ostream<Char>\&>()}
\DoxyCodeLine{29                               << std::declval<U>()) != 0>;}
\DoxyCodeLine{30 }
\DoxyCodeLine{31   \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{static} \textcolor{keyword}{auto} test(...) -\/> std::false\_type;}
\DoxyCodeLine{32 }
\DoxyCodeLine{33   \textcolor{keyword}{using }result = \textcolor{keyword}{decltype}(test<T>(0));}
\DoxyCodeLine{34 }
\DoxyCodeLine{35  \textcolor{keyword}{public}:}
\DoxyCodeLine{36   is\_streamable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{37 }
\DoxyCodeLine{38   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = result::value;}
\DoxyCodeLine{39 \};}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 \textcolor{comment}{// Formatting of built-\/in types and arrays is intentionally disabled because}}
\DoxyCodeLine{42 \textcolor{comment}{// it's handled by standard (non-\/ostream) formatters.}}
\DoxyCodeLine{43 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{44 \textcolor{keyword}{struct }is\_streamable<}
\DoxyCodeLine{45     T, Char,}
\DoxyCodeLine{46     enable\_if\_t<}
\DoxyCodeLine{47         std::is\_arithmetic<T>::value || std::is\_array<T>::value ||}
\DoxyCodeLine{48         std::is\_pointer<T>::value || std::is\_same<T, char8\_type>::value ||}
\DoxyCodeLine{49         std::is\_convertible<T, fmt::basic\_string\_view<Char>>::value ||}
\DoxyCodeLine{50         std::is\_same<T, std\_string\_view<Char>>::value ||}
\DoxyCodeLine{51         (std::is\_convertible<T, int>::value \&\& !std::is\_enum<T>::value)>>}
\DoxyCodeLine{52     : std::false\_type \{\};}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> FILE* get\_file(std::basic\_filebuf<Char>\&) \{}
\DoxyCodeLine{55   \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{56 \}}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 \textcolor{keyword}{struct }dummy\_filebuf \{}
\DoxyCodeLine{59   FILE* \_Myfile;}
\DoxyCodeLine{60 \};}
\DoxyCodeLine{61 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U = \textcolor{keywordtype}{int}> \textcolor{keyword}{struct }ms\_filebuf \{}
\DoxyCodeLine{62   \textcolor{keyword}{using }type = dummy\_filebuf;}
\DoxyCodeLine{63 \};}
\DoxyCodeLine{64 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }ms\_filebuf<T, decltype(T::\_Myfile, 0)> \{}
\DoxyCodeLine{65   \textcolor{keyword}{using }type = T;}
\DoxyCodeLine{66 \};}
\DoxyCodeLine{67 \textcolor{keyword}{using }filebuf\_type = ms\_filebuf<std::filebuf>::type;}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 FILE* get\_file(filebuf\_type\& buf);}
\DoxyCodeLine{70 }
\DoxyCodeLine{71 \textcolor{comment}{// Generate a unique explicit instantion in every translation unit using a tag}}
\DoxyCodeLine{72 \textcolor{comment}{// type in an anonymous namespace.}}
\DoxyCodeLine{73 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{74 \textcolor{keyword}{struct }filebuf\_access\_tag \{\};}
\DoxyCodeLine{75 \}  \textcolor{comment}{// namespace}}
\DoxyCodeLine{76 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tag, \textcolor{keyword}{typename} FileMemberPtr, FileMemberPtr file>}
\DoxyCodeLine{77 \textcolor{keyword}{class }filebuf\_access \{}
\DoxyCodeLine{78   \textcolor{keyword}{friend} FILE* get\_file(filebuf\_type\& buf) \{ \textcolor{keywordflow}{return} buf.*file; \}}
\DoxyCodeLine{79 \};}
\DoxyCodeLine{80 \textcolor{keyword}{template} \textcolor{keyword}{class }filebuf\_access<filebuf\_access\_tag,}
\DoxyCodeLine{81                               \textcolor{keyword}{decltype}(\&filebuf\_type::\_Myfile),}
\DoxyCodeLine{82                               \&filebuf\_type::\_Myfile>;}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} write(std::filebuf\& buf, fmt::string\_view data) \{}
\DoxyCodeLine{85   FILE* f = get\_file(buf);}
\DoxyCodeLine{86   \textcolor{keywordflow}{if} (!f) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{87   print(f, data);}
\DoxyCodeLine{88   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{89 \}}
\DoxyCodeLine{90 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} write(std::wfilebuf\&, fmt::basic\_string\_view<wchar\_t>) \{}
\DoxyCodeLine{91   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{92 \}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94 \textcolor{comment}{// Write the content of buf to os.}}
\DoxyCodeLine{95 \textcolor{comment}{// It is a separate function rather than a part of vprint to simplify testing.}}
\DoxyCodeLine{96 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{97 \textcolor{keywordtype}{void} write\_buffer(std::basic\_ostream<Char>\& os, \mbox{\hyperlink{classbuffer}{buffer<Char>}}\& buf) \{}
\DoxyCodeLine{98   \textcolor{keywordflow}{if} (const\_check(FMT\_MSC\_VERSION)) \{}
\DoxyCodeLine{99     \textcolor{keyword}{auto} filebuf = \textcolor{keyword}{dynamic\_cast<}std::basic\_filebuf<Char>*\textcolor{keyword}{>}(os.rdbuf());}
\DoxyCodeLine{100     \textcolor{keywordflow}{if} (filebuf \&\& write(*filebuf, \{buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()\})) \textcolor{keywordflow}{return};}
\DoxyCodeLine{101   \}}
\DoxyCodeLine{102   \textcolor{keyword}{const} Char* buf\_data = buf.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}();}
\DoxyCodeLine{103   \textcolor{keyword}{using }unsigned\_streamsize = std::make\_unsigned<std::streamsize>::type;}
\DoxyCodeLine{104   unsigned\_streamsize size = buf.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}();}
\DoxyCodeLine{105   unsigned\_streamsize max\_size = to\_unsigned(max\_value<std::streamsize>());}
\DoxyCodeLine{106   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{107     unsigned\_streamsize n = size <= max\_size ? size : max\_size;}
\DoxyCodeLine{108     os.write(buf\_data, \textcolor{keyword}{static\_cast<}std::streamsize\textcolor{keyword}{>}(n));}
\DoxyCodeLine{109     buf\_data += n;}
\DoxyCodeLine{110     size -\/= n;}
\DoxyCodeLine{111   \} \textcolor{keywordflow}{while} (size != 0);}
\DoxyCodeLine{112 \}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{115 \textcolor{keywordtype}{void} format\_value(\mbox{\hyperlink{classbuffer}{buffer<Char>}}\& buf, \textcolor{keyword}{const} T\& value,}
\DoxyCodeLine{116                   locale\_ref loc = locale\_ref()) \{}
\DoxyCodeLine{117   \textcolor{keyword}{auto}\&\& format\_buf = formatbuf<std::basic\_streambuf<Char>>(buf);}
\DoxyCodeLine{118   \textcolor{keyword}{auto}\&\& output = std::basic\_ostream<Char>(\&format\_buf);}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#if !defined(FMT\_STATIC\_THOUSANDS\_SEPARATOR)}}
\DoxyCodeLine{120   \textcolor{keywordflow}{if} (loc) output.imbue(loc.get<std::locale>());}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{122   output << value;}
\DoxyCodeLine{123   output.exceptions(std::ios\_base::failbit | std::ios\_base::badbit);}
\DoxyCodeLine{124 \}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }streamed\_view \{ \textcolor{keyword}{const} T\& value; \};}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{comment}{// Formats an object of type T that has an overloaded ostream operator<<.}}
\DoxyCodeLine{131 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{132 \textcolor{keyword}{struct }basic\_ostream\_formatter : formatter<basic\_string\_view<Char>, Char> \{}
\DoxyCodeLine{133   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{134   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T\& value, basic\_format\_context<OutputIt, Char>\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{135       -\/> OutputIt \{}
\DoxyCodeLine{136     \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer}{buffer}} = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{137     format\_value(\mbox{\hyperlink{classbuffer}{buffer}}, value, ctx.locale());}
\DoxyCodeLine{138     \textcolor{keywordflow}{return} formatter<basic\_string\_view<Char>, Char>::format(}
\DoxyCodeLine{139         \{\mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_a5fe8b50555561bfb4d77a2adcd5f79b2}{data}}(), \mbox{\hyperlink{classbuffer}{buffer}}.\mbox{\hyperlink{classbuffer_aebcfda1cf597e92fdd876bb1b9a1ba2a}{size}}()\}, ctx);}
\DoxyCodeLine{140   \}}
\DoxyCodeLine{141 \};}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{using }ostream\_formatter = basic\_ostream\_formatter<char>;}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{146 \textcolor{keyword}{struct }formatter<detail::streamed\_view<T>> : ostream\_formatter \{}
\DoxyCodeLine{147   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{148   \textcolor{keyword}{auto} format(detail::streamed\_view<T> view,}
\DoxyCodeLine{149               basic\_format\_context<OutputIt, char>\& ctx) \textcolor{keyword}{const} -\/> OutputIt \{}
\DoxyCodeLine{150     \textcolor{keywordflow}{return} ostream\_formatter::format(view.value, ctx);}
\DoxyCodeLine{151   \}}
\DoxyCodeLine{152 \};}
\DoxyCodeLine{153 }
\DoxyCodeLine{164 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{165 \textcolor{keyword}{auto} streamed(\textcolor{keyword}{const} T\& value) -\/> detail::streamed\_view<T> \{}
\DoxyCodeLine{166   \textcolor{keywordflow}{return} \{value\};}
\DoxyCodeLine{167 \}}
\DoxyCodeLine{168 }
\DoxyCodeLine{169 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{170 }
\DoxyCodeLine{171 \textcolor{comment}{// Formats an object of type T that has an overloaded ostream operator<<.}}
\DoxyCodeLine{172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{173 \textcolor{keyword}{struct }fallback\_formatter<T, Char, enable\_if\_t<is\_streamable<T, Char>::value>>}
\DoxyCodeLine{174     : basic\_ostream\_formatter<Char> \{}
\DoxyCodeLine{175   \textcolor{keyword}{using }basic\_ostream\_formatter<Char>::format;}
\DoxyCodeLine{176 \};}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{179 }
\DoxyCodeLine{180 FMT\_MODULE\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{181 \textcolor{keywordtype}{void} vprint(std::basic\_ostream<Char>\& os,}
\DoxyCodeLine{182             \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}<type\_identity\_t<Char>> format\_str,}
\DoxyCodeLine{183             \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<buffer\_context<type\_identity\_t<Char>>> args) \{}
\DoxyCodeLine{184   \textcolor{keyword}{auto} \mbox{\hyperlink{classbuffer}{buffer}} = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{185   detail::vformat\_to(\mbox{\hyperlink{classbuffer}{buffer}}, format\_str, args);}
\DoxyCodeLine{186   detail::write\_buffer(os, \mbox{\hyperlink{classbuffer}{buffer}});}
\DoxyCodeLine{187 \}}
\DoxyCodeLine{188 }
\DoxyCodeLine{198 FMT\_MODULE\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{199 \textcolor{keywordtype}{void} print(std::ostream\& os, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{200   vprint(os, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{201 \}}
\DoxyCodeLine{202 }
\DoxyCodeLine{203 FMT\_MODULE\_EXPORT}
\DoxyCodeLine{204 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{205 \textcolor{keywordtype}{void} print(std::wostream\& os,}
\DoxyCodeLine{206            \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}<\textcolor{keywordtype}{wchar\_t}, type\_identity\_t<Args>...> fmt,}
\DoxyCodeLine{207            Args\&\&... args) \{}
\DoxyCodeLine{208   vprint(os, fmt, fmt::make\_format\_args<buffer\_context<wchar\_t>>(args...));}
\DoxyCodeLine{209 \}}
\DoxyCodeLine{210 }
\DoxyCodeLine{211 FMT\_END\_NAMESPACE}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_OSTREAM\_H\_}}

\end{DoxyCode}
